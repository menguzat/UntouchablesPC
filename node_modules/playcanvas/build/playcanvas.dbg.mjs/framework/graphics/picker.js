import { Color } from '../../core/math/color.js';
import { PIXELFORMAT_RGBA8, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, CLEARFLAG_DEPTH } from '../../platform/graphics/constants.js';
import { GraphicsDevice } from '../../platform/graphics/graphics-device.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { Texture } from '../../platform/graphics/texture.js';
import { DebugGraphics } from '../../platform/graphics/debug-graphics.js';
import { SHADER_PICK, SORTMODE_NONE } from '../../scene/constants.js';
import { Camera } from '../../scene/camera.js';
import { Command } from '../../scene/mesh-instance.js';
import { Layer } from '../../scene/layer.js';
import { LayerComposition } from '../../scene/composition/layer-composition.js';
import { getApplication } from '../globals.js';
import { Entity } from '../entity.js';
import { Debug } from '../../core/debug.js';
import { BlendState } from '../../platform/graphics/blend-state.js';

const tempSet = new Set();
const clearDepthOptions = {
  depth: 1.0,
  flags: CLEARFLAG_DEPTH
};

/**
 * Picker object used to select mesh instances from screen coordinates.
 *
 * @property {number} width Width of the pick buffer in pixels (read-only).
 * @property {number} height Height of the pick buffer in pixels (read-only).
 * @property {RenderTarget} renderTarget The render target used by the picker internally
 * (read-only).
 */
class Picker {
  /**
   * Create a new Picker instance.
   *
   * @param {import('../app-base.js').AppBase} app - The application managing this picker
   * instance.
   * @param {number} width - The width of the pick buffer in pixels.
   * @param {number} height - The height of the pick buffer in pixels.
   */
  constructor(app, width, height) {
    // internal render target
    this.renderTarget = null;
    if (app instanceof GraphicsDevice) {
      app = getApplication();
      Debug.deprecated('pc.Picker now takes pc.AppBase as first argument. Passing pc.GraphicsDevice is deprecated.');
    }
    this.app = app;
    this.device = app.graphicsDevice;

    // uniform for the mesh index encoded into rgba
    this.pickColor = new Float32Array(4);
    this.pickColor[3] = 1;

    // mapping table from ids to meshInstances
    this.mapping = [];

    // create layer composition with the layer and camera
    this.cameraEntity = null;
    this.layer = null;
    this.layerComp = null;
    this.initLayerComposition();

    // clear command user to simulate layer clearing, required due to storing meshes from multiple layers on a singe layer
    const device = this.device;
    this.clearDepthCommand = new Command(0, 0, function () {
      device.clear(clearDepthOptions);
    });
    this.width = 0;
    this.height = 0;
    this.resize(width, height);
  }

  /**
   * Return the list of mesh instances selected by the specified rectangle in the previously
   * prepared pick buffer.The rectangle using top-left coordinate system.
   *
   * @param {number} x - The left edge of the rectangle.
   * @param {number} y - The top edge of the rectangle.
   * @param {number} [width] - The width of the rectangle.
   * @param {number} [height] - The height of the rectangle.
   * @returns {import('../../scene/mesh-instance.js').MeshInstance[]} An array of mesh instances
   * that are in the selection.
   * @example
   * // Get the selection at the point (10,20)
   * const selection = picker.getSelection(10, 20);
   * @example
   * // Get all models in rectangle with corners at (10,20) and (20,40)
   * const selection = picker.getSelection(10, 20, 10, 20);
   */
  getSelection(x, y, width, height) {
    const device = this.device;
    if (typeof x === 'object') {
      Debug.deprecated('Picker.getSelection:param \'rect\' is deprecated, use \'x, y, width, height\' instead.');
      const rect = x;
      x = rect.x;
      y = rect.y;
      width = rect.width;
      height = rect.height;
    } else {
      y = this.renderTarget.height - (y + (height || 1));
    }

    // make sure we have nice numbers to work with
    x = Math.floor(x);
    y = Math.floor(y);
    width = Math.floor(Math.max(width || 1, 1));
    height = Math.floor(Math.max(height || 1, 1));

    // backup active render target
    const origRenderTarget = device.renderTarget;
    DebugGraphics.pushGpuMarker(device, 'PICKER');

    // Ready the device for rendering to the pick buffer
    device.setRenderTarget(this.renderTarget);
    device.updateBegin();
    const pixels = new Uint8Array(4 * width * height);
    device.readPixels(x, y, width, height, pixels);
    device.updateEnd();

    // Restore render target
    device.setRenderTarget(origRenderTarget);
    DebugGraphics.popGpuMarker(device);
    const mapping = this.mapping;
    for (let i = 0; i < width * height; i++) {
      const r = pixels[4 * i + 0];
      const g = pixels[4 * i + 1];
      const b = pixels[4 * i + 2];
      const index = r << 16 | g << 8 | b;

      // White is 'no selection'
      if (index !== 0xffffff) {
        tempSet.add(mapping[index]);
      }
    }

    // return the content of the set as an array
    const selection = [];
    tempSet.forEach(meshInstance => selection.push(meshInstance));
    tempSet.clear();
    return selection;
  }
  allocateRenderTarget() {
    const colorBuffer = new Texture(this.device, {
      format: PIXELFORMAT_RGBA8,
      width: this.width,
      height: this.height,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name: 'pick'
    });
    this.renderTarget = new RenderTarget({
      colorBuffer: colorBuffer,
      depth: true
    });
  }
  releaseRenderTarget() {
    // unset it from the camera
    this.cameraEntity.camera.renderTarget = null;
    if (this.renderTarget) {
      this.renderTarget.destroyTextureBuffers();
      this.renderTarget.destroy();
      this.renderTarget = null;
    }
  }
  initLayerComposition() {
    const device = this.device;
    const self = this;
    const pickColorId = device.scope.resolve('uColor');

    // camera
    this.cameraEntity = new Entity();
    this.cameraEntity.addComponent('camera');

    // layer all meshes rendered for picking at added to
    this.layer = new Layer({
      name: 'Picker',
      shaderPass: SHADER_PICK,
      opaqueSortMode: SORTMODE_NONE,
      // executes just before the mesh is rendered. And index encoded in rgb is assigned to it
      onDrawCall: function (meshInstance, index) {
        self.pickColor[0] = (index >> 16 & 0xff) / 255;
        self.pickColor[1] = (index >> 8 & 0xff) / 255;
        self.pickColor[2] = (index & 0xff) / 255;
        pickColorId.setValue(self.pickColor);
        device.setBlendState(BlendState.DEFAULT);

        // keep the index -> meshInstance index mapping
        self.mapping[index] = meshInstance;
      }
    });
    this.layer.addCamera(this.cameraEntity.camera);

    // composition
    this.layerComp = new LayerComposition('picker');
    this.layerComp.pushOpaque(this.layer);
  }

  /**
   * Primes the pick buffer with a rendering of the specified models from the point of view of
   * the supplied camera. Once the pick buffer has been prepared, {@link Picker#getSelection} can
   * be called multiple times on the same picker object. Therefore, if the models or camera do
   * not change in any way, {@link Picker#prepare} does not need to be called again.
   *
   * @param {import('../components/camera/component.js').CameraComponent} camera - The camera
   * component used to render the scene.
   * @param {import('../../scene/scene.js').Scene} scene - The scene containing the pickable mesh
   * instances.
   * @param {Layer[]} [layers] - Layers from which objects will be picked. If not supplied, all layers of the specified camera will be used.
   */
  prepare(camera, scene, layers) {
    // handle deprecated arguments
    if (camera instanceof Camera) {
      Debug.deprecated('pc.Picker#prepare now takes pc.CameraComponent as first argument. Passing pc.Camera is deprecated.');

      // Get the camera component
      camera = camera.node.camera;
    }
    if (layers instanceof Layer) {
      layers = [layers];
    }

    // populate the layer with meshes and depth clear commands
    this.layer.clearMeshInstances();
    const destMeshInstances = this.layer.opaqueMeshInstances;

    // source mesh instances
    const srcLayers = scene.layers.layerList;
    const subLayerEnabled = scene.layers.subLayerEnabled;
    const isTransparent = scene.layers.subLayerList;
    for (let i = 0; i < srcLayers.length; i++) {
      const srcLayer = srcLayers[i];

      // skip the layer if it does not match the provided ones
      if (layers && layers.indexOf(srcLayer) < 0) {
        continue;
      }
      if (srcLayer.enabled && subLayerEnabled[i]) {
        // if the layer is rendered by the camera
        const layerCamId = srcLayer.cameras.indexOf(camera);
        if (layerCamId >= 0) {
          // if the layer clears the depth, add command to clear it
          if (srcLayer._clearDepthBuffer) {
            destMeshInstances.push(this.clearDepthCommand);
          }

          // copy all pickable mesh instances
          const meshInstances = isTransparent[i] ? srcLayer.instances.transparentMeshInstances : srcLayer.instances.opaqueMeshInstances;
          for (let j = 0; j < meshInstances.length; j++) {
            const meshInstance = meshInstances[j];
            if (meshInstance.pick) {
              destMeshInstances.push(meshInstance);
            }
          }
        }
      }
    }

    // make the render target the right size
    if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
      this.releaseRenderTarget();
      this.allocateRenderTarget();
    }

    // prepare the rendering camera
    this.updateCamera(camera);

    // clear registered meshes mapping
    this.mapping.length = 0;

    // render
    this.app.renderComposition(this.layerComp);
  }
  updateCamera(srcCamera) {
    // copy transform
    this.cameraEntity.copy(srcCamera.entity);
    this.cameraEntity.name = 'PickerCamera';

    // copy camera component properties - which overwrites few properties we change to what is needed later
    const destCamera = this.cameraEntity.camera;
    destCamera.copy(srcCamera);

    // set up clears
    destCamera.clearColorBuffer = true;
    destCamera.clearDepthBuffer = true;
    destCamera.clearStencilBuffer = true;
    destCamera.clearColor = Color.WHITE;

    // render target
    destCamera.renderTarget = this.renderTarget;

    // layers
    this.layer.clearCameras();
    this.layer.addCamera(destCamera);
    destCamera.layers = [this.layer.id];
  }

  /**
   * Sets the resolution of the pick buffer. The pick buffer resolution does not need to match
   * the resolution of the corresponding frame buffer use for general rendering of the 3D scene.
   * However, the lower the resolution of the pick buffer, the less accurate the selection
   * results returned by {@link Picker#getSelection}. On the other hand, smaller pick buffers
   * will yield greater performance, so there is a trade off.
   *
   * @param {number} width - The width of the pick buffer in pixels.
   * @param {number} height - The height of the pick buffer in pixels.
   */
  resize(width, height) {
    this.width = Math.floor(width);
    this.height = Math.floor(height);
  }
}

export { Picker };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlja2VyLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvZnJhbWV3b3JrL2dyYXBoaWNzL3BpY2tlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL2NvcmUvbWF0aC9jb2xvci5qcyc7XG5cbmltcG9ydCB7IEFERFJFU1NfQ0xBTVBfVE9fRURHRSwgQ0xFQVJGTEFHX0RFUFRILCBGSUxURVJfTkVBUkVTVCwgUElYRUxGT1JNQVRfUkdCQTggfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NEZXZpY2UgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9ncmFwaGljcy1kZXZpY2UuanMnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvcmVuZGVyLXRhcmdldC5qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvdGV4dHVyZS5qcyc7XG5pbXBvcnQgeyBEZWJ1Z0dyYXBoaWNzIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvZGVidWctZ3JhcGhpY3MuanMnO1xuXG5pbXBvcnQgeyBTSEFERVJfUElDSywgU09SVE1PREVfTk9ORSB9IGZyb20gJy4uLy4uL3NjZW5lL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tICcuLi8uLi9zY2VuZS9jYW1lcmEuanMnO1xuaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJy4uLy4uL3NjZW5lL21lc2gtaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9zY2VuZS9sYXllci5qcyc7XG5pbXBvcnQgeyBMYXllckNvbXBvc2l0aW9uIH0gZnJvbSAnLi4vLi4vc2NlbmUvY29tcG9zaXRpb24vbGF5ZXItY29tcG9zaXRpb24uanMnO1xuXG5pbXBvcnQgeyBnZXRBcHBsaWNhdGlvbiB9IGZyb20gJy4uL2dsb2JhbHMuanMnO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnLi4vZW50aXR5LmpzJztcbmltcG9ydCB7IERlYnVnIH0gZnJvbSAnLi4vLi4vY29yZS9kZWJ1Zy5qcyc7XG5pbXBvcnQgeyBCbGVuZFN0YXRlIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvYmxlbmQtc3RhdGUuanMnO1xuXG5jb25zdCB0ZW1wU2V0ID0gbmV3IFNldCgpO1xuXG5jb25zdCBjbGVhckRlcHRoT3B0aW9ucyA9IHtcbiAgICBkZXB0aDogMS4wLFxuICAgIGZsYWdzOiBDTEVBUkZMQUdfREVQVEhcbn07XG5cbi8qKlxuICogUGlja2VyIG9iamVjdCB1c2VkIHRvIHNlbGVjdCBtZXNoIGluc3RhbmNlcyBmcm9tIHNjcmVlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHBpY2sgYnVmZmVyIGluIHBpeGVscyAocmVhZC1vbmx5KS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBwaWNrIGJ1ZmZlciBpbiBwaXhlbHMgKHJlYWQtb25seSkuXG4gKiBAcHJvcGVydHkge1JlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0IFRoZSByZW5kZXIgdGFyZ2V0IHVzZWQgYnkgdGhlIHBpY2tlciBpbnRlcm5hbGx5XG4gKiAocmVhZC1vbmx5KS5cbiAqL1xuY2xhc3MgUGlja2VyIHtcbiAgICAvLyBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0XG4gICAgcmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQaWNrZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vYXBwLWJhc2UuanMnKS5BcHBCYXNlfSBhcHAgLSBUaGUgYXBwbGljYXRpb24gbWFuYWdpbmcgdGhpcyBwaWNrZXJcbiAgICAgKiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHBpY2sgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcGljayBidWZmZXIgaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoYXBwIGluc3RhbmNlb2YgR3JhcGhpY3NEZXZpY2UpIHtcbiAgICAgICAgICAgIGFwcCA9IGdldEFwcGxpY2F0aW9uKCk7XG4gICAgICAgICAgICBEZWJ1Zy5kZXByZWNhdGVkKCdwYy5QaWNrZXIgbm93IHRha2VzIHBjLkFwcEJhc2UgYXMgZmlyc3QgYXJndW1lbnQuIFBhc3NpbmcgcGMuR3JhcGhpY3NEZXZpY2UgaXMgZGVwcmVjYXRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLmRldmljZSA9IGFwcC5ncmFwaGljc0RldmljZTtcblxuICAgICAgICAvLyB1bmlmb3JtIGZvciB0aGUgbWVzaCBpbmRleCBlbmNvZGVkIGludG8gcmdiYVxuICAgICAgICB0aGlzLnBpY2tDb2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIHRoaXMucGlja0NvbG9yWzNdID0gMTtcblxuICAgICAgICAvLyBtYXBwaW5nIHRhYmxlIGZyb20gaWRzIHRvIG1lc2hJbnN0YW5jZXNcbiAgICAgICAgdGhpcy5tYXBwaW5nID0gW107XG5cbiAgICAgICAgLy8gY3JlYXRlIGxheWVyIGNvbXBvc2l0aW9uIHdpdGggdGhlIGxheWVyIGFuZCBjYW1lcmFcbiAgICAgICAgdGhpcy5jYW1lcmFFbnRpdHkgPSBudWxsO1xuICAgICAgICB0aGlzLmxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXllckNvbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRMYXllckNvbXBvc2l0aW9uKCk7XG5cbiAgICAgICAgLy8gY2xlYXIgY29tbWFuZCB1c2VyIHRvIHNpbXVsYXRlIGxheWVyIGNsZWFyaW5nLCByZXF1aXJlZCBkdWUgdG8gc3RvcmluZyBtZXNoZXMgZnJvbSBtdWx0aXBsZSBsYXllcnMgb24gYSBzaW5nZSBsYXllclxuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgICAgICAgdGhpcy5jbGVhckRlcHRoQ29tbWFuZCA9IG5ldyBDb21tYW5kKDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRldmljZS5jbGVhcihjbGVhckRlcHRoT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbGlzdCBvZiBtZXNoIGluc3RhbmNlcyBzZWxlY3RlZCBieSB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSBpbiB0aGUgcHJldmlvdXNseVxuICAgICAqIHByZXBhcmVkIHBpY2sgYnVmZmVyLlRoZSByZWN0YW5nbGUgdXNpbmcgdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB0b3AgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoJy4uLy4uL3NjZW5lL21lc2gtaW5zdGFuY2UuanMnKS5NZXNoSW5zdGFuY2VbXX0gQW4gYXJyYXkgb2YgbWVzaCBpbnN0YW5jZXNcbiAgICAgKiB0aGF0IGFyZSBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gR2V0IHRoZSBzZWxlY3Rpb24gYXQgdGhlIHBvaW50ICgxMCwyMClcbiAgICAgKiBjb25zdCBzZWxlY3Rpb24gPSBwaWNrZXIuZ2V0U2VsZWN0aW9uKDEwLCAyMCk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBHZXQgYWxsIG1vZGVscyBpbiByZWN0YW5nbGUgd2l0aCBjb3JuZXJzIGF0ICgxMCwyMCkgYW5kICgyMCw0MClcbiAgICAgKiBjb25zdCBzZWxlY3Rpb24gPSBwaWNrZXIuZ2V0U2VsZWN0aW9uKDEwLCAyMCwgMTAsIDIwKTtcbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcblxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBEZWJ1Zy5kZXByZWNhdGVkKCdQaWNrZXIuZ2V0U2VsZWN0aW9uOnBhcmFtIFxcJ3JlY3RcXCcgaXMgZGVwcmVjYXRlZCwgdXNlIFxcJ3gsIHksIHdpZHRoLCBoZWlnaHRcXCcgaW5zdGVhZC4nKTtcblxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHg7XG4gICAgICAgICAgICB4ID0gcmVjdC54O1xuICAgICAgICAgICAgeSA9IHJlY3QueTtcbiAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHRoaXMucmVuZGVyVGFyZ2V0LmhlaWdodCAtICh5ICsgKGhlaWdodCB8fCAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBuaWNlIG51bWJlcnMgdG8gd29yayB3aXRoXG4gICAgICAgIHggPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICB5ID0gTWF0aC5mbG9vcih5KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKE1hdGgubWF4KHdpZHRoIHx8IDEsIDEpKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihNYXRoLm1heChoZWlnaHQgfHwgMSwgMSkpO1xuXG4gICAgICAgIC8vIGJhY2t1cCBhY3RpdmUgcmVuZGVyIHRhcmdldFxuICAgICAgICBjb25zdCBvcmlnUmVuZGVyVGFyZ2V0ID0gZGV2aWNlLnJlbmRlclRhcmdldDtcblxuICAgICAgICBEZWJ1Z0dyYXBoaWNzLnB1c2hHcHVNYXJrZXIoZGV2aWNlLCAnUElDS0VSJyk7XG5cbiAgICAgICAgLy8gUmVhZHkgdGhlIGRldmljZSBmb3IgcmVuZGVyaW5nIHRvIHRoZSBwaWNrIGJ1ZmZlclxuICAgICAgICBkZXZpY2Uuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgZGV2aWNlLnVwZGF0ZUJlZ2luKCk7XG5cbiAgICAgICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgZGV2aWNlLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgcGl4ZWxzKTtcblxuICAgICAgICBkZXZpY2UudXBkYXRlRW5kKCk7XG5cbiAgICAgICAgLy8gUmVzdG9yZSByZW5kZXIgdGFyZ2V0XG4gICAgICAgIGRldmljZS5zZXRSZW5kZXJUYXJnZXQob3JpZ1JlbmRlclRhcmdldCk7XG5cbiAgICAgICAgRGVidWdHcmFwaGljcy5wb3BHcHVNYXJrZXIoZGV2aWNlKTtcblxuICAgICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5tYXBwaW5nO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoICogaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBwaXhlbHNbNCAqIGkgKyAwXTtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBwaXhlbHNbNCAqIGkgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwaXhlbHNbNCAqIGkgKyAyXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gciA8PCAxNiB8IGcgPDwgOCB8IGI7XG5cbiAgICAgICAgICAgIC8vIFdoaXRlIGlzICdubyBzZWxlY3Rpb24nXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IDB4ZmZmZmZmKSB7XG4gICAgICAgICAgICAgICAgdGVtcFNldC5hZGQobWFwcGluZ1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBjb250ZW50IG9mIHRoZSBzZXQgYXMgYW4gYXJyYXlcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gW107XG4gICAgICAgIHRlbXBTZXQuZm9yRWFjaChtZXNoSW5zdGFuY2UgPT4gc2VsZWN0aW9uLnB1c2gobWVzaEluc3RhbmNlKSk7XG4gICAgICAgIHRlbXBTZXQuY2xlYXIoKTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIGFsbG9jYXRlUmVuZGVyVGFyZ2V0KCkge1xuXG4gICAgICAgIGNvbnN0IGNvbG9yQnVmZmVyID0gbmV3IFRleHR1cmUodGhpcy5kZXZpY2UsIHtcbiAgICAgICAgICAgIGZvcm1hdDogUElYRUxGT1JNQVRfUkdCQTgsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtaXBtYXBzOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbkZpbHRlcjogRklMVEVSX05FQVJFU1QsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6IEZJTFRFUl9ORUFSRVNULFxuICAgICAgICAgICAgYWRkcmVzc1U6IEFERFJFU1NfQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgICAgIGFkZHJlc3NWOiBBRERSRVNTX0NMQU1QX1RPX0VER0UsXG4gICAgICAgICAgICBuYW1lOiAncGljaydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0KHtcbiAgICAgICAgICAgIGNvbG9yQnVmZmVyOiBjb2xvckJ1ZmZlcixcbiAgICAgICAgICAgIGRlcHRoOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbGVhc2VSZW5kZXJUYXJnZXQoKSB7XG5cbiAgICAgICAgLy8gdW5zZXQgaXQgZnJvbSB0aGUgY2FtZXJhXG4gICAgICAgIHRoaXMuY2FtZXJhRW50aXR5LmNhbWVyYS5yZW5kZXJUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuZGVzdHJveVRleHR1cmVCdWZmZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0TGF5ZXJDb21wb3NpdGlvbigpIHtcblxuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHBpY2tDb2xvcklkID0gZGV2aWNlLnNjb3BlLnJlc29sdmUoJ3VDb2xvcicpO1xuXG4gICAgICAgIC8vIGNhbWVyYVxuICAgICAgICB0aGlzLmNhbWVyYUVudGl0eSA9IG5ldyBFbnRpdHkoKTtcbiAgICAgICAgdGhpcy5jYW1lcmFFbnRpdHkuYWRkQ29tcG9uZW50KCdjYW1lcmEnKTtcblxuICAgICAgICAvLyBsYXllciBhbGwgbWVzaGVzIHJlbmRlcmVkIGZvciBwaWNraW5nIGF0IGFkZGVkIHRvXG4gICAgICAgIHRoaXMubGF5ZXIgPSBuZXcgTGF5ZXIoe1xuICAgICAgICAgICAgbmFtZTogJ1BpY2tlcicsXG4gICAgICAgICAgICBzaGFkZXJQYXNzOiBTSEFERVJfUElDSyxcbiAgICAgICAgICAgIG9wYXF1ZVNvcnRNb2RlOiBTT1JUTU9ERV9OT05FLFxuXG4gICAgICAgICAgICAvLyBleGVjdXRlcyBqdXN0IGJlZm9yZSB0aGUgbWVzaCBpcyByZW5kZXJlZC4gQW5kIGluZGV4IGVuY29kZWQgaW4gcmdiIGlzIGFzc2lnbmVkIHRvIGl0XG4gICAgICAgICAgICBvbkRyYXdDYWxsOiBmdW5jdGlvbiAobWVzaEluc3RhbmNlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHNlbGYucGlja0NvbG9yWzBdID0gKChpbmRleCA+PiAxNikgJiAweGZmKSAvIDI1NTtcbiAgICAgICAgICAgICAgICBzZWxmLnBpY2tDb2xvclsxXSA9ICgoaW5kZXggPj4gOCkgJiAweGZmKSAvIDI1NTtcbiAgICAgICAgICAgICAgICBzZWxmLnBpY2tDb2xvclsyXSA9IChpbmRleCAmIDB4ZmYpIC8gMjU1O1xuICAgICAgICAgICAgICAgIHBpY2tDb2xvcklkLnNldFZhbHVlKHNlbGYucGlja0NvbG9yKTtcbiAgICAgICAgICAgICAgICBkZXZpY2Uuc2V0QmxlbmRTdGF0ZShCbGVuZFN0YXRlLkRFRkFVTFQpO1xuXG4gICAgICAgICAgICAgICAgLy8ga2VlcCB0aGUgaW5kZXggLT4gbWVzaEluc3RhbmNlIGluZGV4IG1hcHBpbmdcbiAgICAgICAgICAgICAgICBzZWxmLm1hcHBpbmdbaW5kZXhdID0gbWVzaEluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXllci5hZGRDYW1lcmEodGhpcy5jYW1lcmFFbnRpdHkuY2FtZXJhKTtcblxuICAgICAgICAvLyBjb21wb3NpdGlvblxuICAgICAgICB0aGlzLmxheWVyQ29tcCA9IG5ldyBMYXllckNvbXBvc2l0aW9uKCdwaWNrZXInKTtcbiAgICAgICAgdGhpcy5sYXllckNvbXAucHVzaE9wYXF1ZSh0aGlzLmxheWVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmltZXMgdGhlIHBpY2sgYnVmZmVyIHdpdGggYSByZW5kZXJpbmcgb2YgdGhlIHNwZWNpZmllZCBtb2RlbHMgZnJvbSB0aGUgcG9pbnQgb2YgdmlldyBvZlxuICAgICAqIHRoZSBzdXBwbGllZCBjYW1lcmEuIE9uY2UgdGhlIHBpY2sgYnVmZmVyIGhhcyBiZWVuIHByZXBhcmVkLCB7QGxpbmsgUGlja2VyI2dldFNlbGVjdGlvbn0gY2FuXG4gICAgICogYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIHBpY2tlciBvYmplY3QuIFRoZXJlZm9yZSwgaWYgdGhlIG1vZGVscyBvciBjYW1lcmEgZG9cbiAgICAgKiBub3QgY2hhbmdlIGluIGFueSB3YXksIHtAbGluayBQaWNrZXIjcHJlcGFyZX0gZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgYWdhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29tcG9uZW50cy9jYW1lcmEvY29tcG9uZW50LmpzJykuQ2FtZXJhQ29tcG9uZW50fSBjYW1lcmEgLSBUaGUgY2FtZXJhXG4gICAgICogY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIHRoZSBzY2VuZS5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vc2NlbmUvc2NlbmUuanMnKS5TY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgY29udGFpbmluZyB0aGUgcGlja2FibGUgbWVzaFxuICAgICAqIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge0xheWVyW119IFtsYXllcnNdIC0gTGF5ZXJzIGZyb20gd2hpY2ggb2JqZWN0cyB3aWxsIGJlIHBpY2tlZC4gSWYgbm90IHN1cHBsaWVkLCBhbGwgbGF5ZXJzIG9mIHRoZSBzcGVjaWZpZWQgY2FtZXJhIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBwcmVwYXJlKGNhbWVyYSwgc2NlbmUsIGxheWVycykge1xuXG4gICAgICAgIC8vIGhhbmRsZSBkZXByZWNhdGVkIGFyZ3VtZW50c1xuICAgICAgICBpZiAoY2FtZXJhIGluc3RhbmNlb2YgQ2FtZXJhKSB7XG4gICAgICAgICAgICBEZWJ1Zy5kZXByZWNhdGVkKCdwYy5QaWNrZXIjcHJlcGFyZSBub3cgdGFrZXMgcGMuQ2FtZXJhQ29tcG9uZW50IGFzIGZpcnN0IGFyZ3VtZW50LiBQYXNzaW5nIHBjLkNhbWVyYSBpcyBkZXByZWNhdGVkLicpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNhbWVyYSBjb21wb25lbnRcbiAgICAgICAgICAgIGNhbWVyYSA9IGNhbWVyYS5ub2RlLmNhbWVyYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICAgICAgbGF5ZXJzID0gW2xheWVyc107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwb3B1bGF0ZSB0aGUgbGF5ZXIgd2l0aCBtZXNoZXMgYW5kIGRlcHRoIGNsZWFyIGNvbW1hbmRzXG4gICAgICAgIHRoaXMubGF5ZXIuY2xlYXJNZXNoSW5zdGFuY2VzKCk7XG4gICAgICAgIGNvbnN0IGRlc3RNZXNoSW5zdGFuY2VzID0gdGhpcy5sYXllci5vcGFxdWVNZXNoSW5zdGFuY2VzO1xuXG4gICAgICAgIC8vIHNvdXJjZSBtZXNoIGluc3RhbmNlc1xuICAgICAgICBjb25zdCBzcmNMYXllcnMgPSBzY2VuZS5sYXllcnMubGF5ZXJMaXN0O1xuICAgICAgICBjb25zdCBzdWJMYXllckVuYWJsZWQgPSBzY2VuZS5sYXllcnMuc3ViTGF5ZXJFbmFibGVkO1xuICAgICAgICBjb25zdCBpc1RyYW5zcGFyZW50ID0gc2NlbmUubGF5ZXJzLnN1YkxheWVyTGlzdDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyY0xheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3JjTGF5ZXIgPSBzcmNMYXllcnNbaV07XG5cbiAgICAgICAgICAgIC8vIHNraXAgdGhlIGxheWVyIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBvbmVzXG4gICAgICAgICAgICBpZiAobGF5ZXJzICYmIGxheWVycy5pbmRleE9mKHNyY0xheWVyKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNyY0xheWVyLmVuYWJsZWQgJiYgc3ViTGF5ZXJFbmFibGVkW2ldKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGF5ZXIgaXMgcmVuZGVyZWQgYnkgdGhlIGNhbWVyYVxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyQ2FtSWQgPSBzcmNMYXllci5jYW1lcmFzLmluZGV4T2YoY2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJDYW1JZCA+PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxheWVyIGNsZWFycyB0aGUgZGVwdGgsIGFkZCBjb21tYW5kIHRvIGNsZWFyIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNMYXllci5fY2xlYXJEZXB0aEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdE1lc2hJbnN0YW5jZXMucHVzaCh0aGlzLmNsZWFyRGVwdGhDb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYWxsIHBpY2thYmxlIG1lc2ggaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2hJbnN0YW5jZXMgPSBpc1RyYW5zcGFyZW50W2ldID8gc3JjTGF5ZXIuaW5zdGFuY2VzLnRyYW5zcGFyZW50TWVzaEluc3RhbmNlcyA6IHNyY0xheWVyLmluc3RhbmNlcy5vcGFxdWVNZXNoSW5zdGFuY2VzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1lc2hJbnN0YW5jZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2hJbnN0YW5jZSA9IG1lc2hJbnN0YW5jZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzaEluc3RhbmNlLnBpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0TWVzaEluc3RhbmNlcy5wdXNoKG1lc2hJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHRoZSByZW5kZXIgdGFyZ2V0IHRoZSByaWdodCBzaXplXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJUYXJnZXQgfHwgKHRoaXMud2lkdGggIT09IHRoaXMucmVuZGVyVGFyZ2V0LndpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSB0aGlzLnJlbmRlclRhcmdldC5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VSZW5kZXJUYXJnZXQoKTtcbiAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVSZW5kZXJUYXJnZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXBhcmUgdGhlIHJlbmRlcmluZyBjYW1lcmFcbiAgICAgICAgdGhpcy51cGRhdGVDYW1lcmEoY2FtZXJhKTtcblxuICAgICAgICAvLyBjbGVhciByZWdpc3RlcmVkIG1lc2hlcyBtYXBwaW5nXG4gICAgICAgIHRoaXMubWFwcGluZy5sZW5ndGggPSAwO1xuXG4gICAgICAgIC8vIHJlbmRlclxuICAgICAgICB0aGlzLmFwcC5yZW5kZXJDb21wb3NpdGlvbih0aGlzLmxheWVyQ29tcCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQ2FtZXJhKHNyY0NhbWVyYSkge1xuXG4gICAgICAgIC8vIGNvcHkgdHJhbnNmb3JtXG4gICAgICAgIHRoaXMuY2FtZXJhRW50aXR5LmNvcHkoc3JjQ2FtZXJhLmVudGl0eSk7XG4gICAgICAgIHRoaXMuY2FtZXJhRW50aXR5Lm5hbWUgPSAnUGlja2VyQ2FtZXJhJztcblxuICAgICAgICAvLyBjb3B5IGNhbWVyYSBjb21wb25lbnQgcHJvcGVydGllcyAtIHdoaWNoIG92ZXJ3cml0ZXMgZmV3IHByb3BlcnRpZXMgd2UgY2hhbmdlIHRvIHdoYXQgaXMgbmVlZGVkIGxhdGVyXG4gICAgICAgIGNvbnN0IGRlc3RDYW1lcmEgPSB0aGlzLmNhbWVyYUVudGl0eS5jYW1lcmE7XG4gICAgICAgIGRlc3RDYW1lcmEuY29weShzcmNDYW1lcmEpO1xuXG4gICAgICAgIC8vIHNldCB1cCBjbGVhcnNcbiAgICAgICAgZGVzdENhbWVyYS5jbGVhckNvbG9yQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgZGVzdENhbWVyYS5jbGVhckRlcHRoQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgZGVzdENhbWVyYS5jbGVhclN0ZW5jaWxCdWZmZXIgPSB0cnVlO1xuICAgICAgICBkZXN0Q2FtZXJhLmNsZWFyQ29sb3IgPSBDb2xvci5XSElURTtcblxuICAgICAgICAvLyByZW5kZXIgdGFyZ2V0XG4gICAgICAgIGRlc3RDYW1lcmEucmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG5cbiAgICAgICAgLy8gbGF5ZXJzXG4gICAgICAgIHRoaXMubGF5ZXIuY2xlYXJDYW1lcmFzKCk7XG4gICAgICAgIHRoaXMubGF5ZXIuYWRkQ2FtZXJhKGRlc3RDYW1lcmEpO1xuICAgICAgICBkZXN0Q2FtZXJhLmxheWVycyA9IFt0aGlzLmxheWVyLmlkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBwaWNrIGJ1ZmZlci4gVGhlIHBpY2sgYnVmZmVyIHJlc29sdXRpb24gZG9lcyBub3QgbmVlZCB0byBtYXRjaFxuICAgICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nIGZyYW1lIGJ1ZmZlciB1c2UgZm9yIGdlbmVyYWwgcmVuZGVyaW5nIG9mIHRoZSAzRCBzY2VuZS5cbiAgICAgKiBIb3dldmVyLCB0aGUgbG93ZXIgdGhlIHJlc29sdXRpb24gb2YgdGhlIHBpY2sgYnVmZmVyLCB0aGUgbGVzcyBhY2N1cmF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICogcmVzdWx0cyByZXR1cm5lZCBieSB7QGxpbmsgUGlja2VyI2dldFNlbGVjdGlvbn0uIE9uIHRoZSBvdGhlciBoYW5kLCBzbWFsbGVyIHBpY2sgYnVmZmVyc1xuICAgICAqIHdpbGwgeWllbGQgZ3JlYXRlciBwZXJmb3JtYW5jZSwgc28gdGhlcmUgaXMgYSB0cmFkZSBvZmYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHBpY2sgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcGljayBidWZmZXIgaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBQaWNrZXIgfTtcbiJdLCJuYW1lcyI6WyJ0ZW1wU2V0IiwiU2V0IiwiY2xlYXJEZXB0aE9wdGlvbnMiLCJkZXB0aCIsImZsYWdzIiwiQ0xFQVJGTEFHX0RFUFRIIiwiUGlja2VyIiwiY29uc3RydWN0b3IiLCJhcHAiLCJ3aWR0aCIsImhlaWdodCIsInJlbmRlclRhcmdldCIsIkdyYXBoaWNzRGV2aWNlIiwiZ2V0QXBwbGljYXRpb24iLCJEZWJ1ZyIsImRlcHJlY2F0ZWQiLCJkZXZpY2UiLCJncmFwaGljc0RldmljZSIsInBpY2tDb2xvciIsIkZsb2F0MzJBcnJheSIsIm1hcHBpbmciLCJjYW1lcmFFbnRpdHkiLCJsYXllciIsImxheWVyQ29tcCIsImluaXRMYXllckNvbXBvc2l0aW9uIiwiY2xlYXJEZXB0aENvbW1hbmQiLCJDb21tYW5kIiwiY2xlYXIiLCJyZXNpemUiLCJnZXRTZWxlY3Rpb24iLCJ4IiwieSIsInJlY3QiLCJNYXRoIiwiZmxvb3IiLCJtYXgiLCJvcmlnUmVuZGVyVGFyZ2V0IiwiRGVidWdHcmFwaGljcyIsInB1c2hHcHVNYXJrZXIiLCJzZXRSZW5kZXJUYXJnZXQiLCJ1cGRhdGVCZWdpbiIsInBpeGVscyIsIlVpbnQ4QXJyYXkiLCJyZWFkUGl4ZWxzIiwidXBkYXRlRW5kIiwicG9wR3B1TWFya2VyIiwiaSIsInIiLCJnIiwiYiIsImluZGV4IiwiYWRkIiwic2VsZWN0aW9uIiwiZm9yRWFjaCIsIm1lc2hJbnN0YW5jZSIsInB1c2giLCJhbGxvY2F0ZVJlbmRlclRhcmdldCIsImNvbG9yQnVmZmVyIiwiVGV4dHVyZSIsImZvcm1hdCIsIlBJWEVMRk9STUFUX1JHQkE4IiwibWlwbWFwcyIsIm1pbkZpbHRlciIsIkZJTFRFUl9ORUFSRVNUIiwibWFnRmlsdGVyIiwiYWRkcmVzc1UiLCJBRERSRVNTX0NMQU1QX1RPX0VER0UiLCJhZGRyZXNzViIsIm5hbWUiLCJSZW5kZXJUYXJnZXQiLCJyZWxlYXNlUmVuZGVyVGFyZ2V0IiwiY2FtZXJhIiwiZGVzdHJveVRleHR1cmVCdWZmZXJzIiwiZGVzdHJveSIsInNlbGYiLCJwaWNrQ29sb3JJZCIsInNjb3BlIiwicmVzb2x2ZSIsIkVudGl0eSIsImFkZENvbXBvbmVudCIsIkxheWVyIiwic2hhZGVyUGFzcyIsIlNIQURFUl9QSUNLIiwib3BhcXVlU29ydE1vZGUiLCJTT1JUTU9ERV9OT05FIiwib25EcmF3Q2FsbCIsInNldFZhbHVlIiwic2V0QmxlbmRTdGF0ZSIsIkJsZW5kU3RhdGUiLCJERUZBVUxUIiwiYWRkQ2FtZXJhIiwiTGF5ZXJDb21wb3NpdGlvbiIsInB1c2hPcGFxdWUiLCJwcmVwYXJlIiwic2NlbmUiLCJsYXllcnMiLCJDYW1lcmEiLCJub2RlIiwiY2xlYXJNZXNoSW5zdGFuY2VzIiwiZGVzdE1lc2hJbnN0YW5jZXMiLCJvcGFxdWVNZXNoSW5zdGFuY2VzIiwic3JjTGF5ZXJzIiwibGF5ZXJMaXN0Iiwic3ViTGF5ZXJFbmFibGVkIiwiaXNUcmFuc3BhcmVudCIsInN1YkxheWVyTGlzdCIsImxlbmd0aCIsInNyY0xheWVyIiwiaW5kZXhPZiIsImVuYWJsZWQiLCJsYXllckNhbUlkIiwiY2FtZXJhcyIsIl9jbGVhckRlcHRoQnVmZmVyIiwibWVzaEluc3RhbmNlcyIsImluc3RhbmNlcyIsInRyYW5zcGFyZW50TWVzaEluc3RhbmNlcyIsImoiLCJwaWNrIiwidXBkYXRlQ2FtZXJhIiwicmVuZGVyQ29tcG9zaXRpb24iLCJzcmNDYW1lcmEiLCJjb3B5IiwiZW50aXR5IiwiZGVzdENhbWVyYSIsImNsZWFyQ29sb3JCdWZmZXIiLCJjbGVhckRlcHRoQnVmZmVyIiwiY2xlYXJTdGVuY2lsQnVmZmVyIiwiY2xlYXJDb2xvciIsIkNvbG9yIiwiV0hJVEUiLCJjbGVhckNhbWVyYXMiLCJpZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxNQUFNQSxPQUFPLEdBQUcsSUFBSUMsR0FBRyxFQUFFLENBQUE7QUFFekIsTUFBTUMsaUJBQWlCLEdBQUc7QUFDdEJDLEVBQUFBLEtBQUssRUFBRSxHQUFHO0FBQ1ZDLEVBQUFBLEtBQUssRUFBRUMsZUFBQUE7QUFDWCxDQUFDLENBQUE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLE1BQU0sQ0FBQztBQUlUO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsRUFBQUEsV0FBV0EsQ0FBQ0MsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtBQVhoQztJQUFBLElBQ0FDLENBQUFBLFlBQVksR0FBRyxJQUFJLENBQUE7SUFXZixJQUFJSCxHQUFHLFlBQVlJLGNBQWMsRUFBRTtNQUMvQkosR0FBRyxHQUFHSyxjQUFjLEVBQUUsQ0FBQTtBQUN0QkMsTUFBQUEsS0FBSyxDQUFDQyxVQUFVLENBQUMsNEZBQTRGLENBQUMsQ0FBQTtBQUNsSCxLQUFBO0lBRUEsSUFBSSxDQUFDUCxHQUFHLEdBQUdBLEdBQUcsQ0FBQTtBQUNkLElBQUEsSUFBSSxDQUFDUSxNQUFNLEdBQUdSLEdBQUcsQ0FBQ1MsY0FBYyxDQUFBOztBQUVoQztBQUNBLElBQUEsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3BDLElBQUEsSUFBSSxDQUFDRCxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFBOztBQUVyQjtJQUNBLElBQUksQ0FBQ0UsT0FBTyxHQUFHLEVBQUUsQ0FBQTs7QUFFakI7SUFDQSxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJLENBQUE7SUFDeEIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSSxDQUFBO0lBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUksQ0FBQTtJQUNyQixJQUFJLENBQUNDLG9CQUFvQixFQUFFLENBQUE7O0FBRTNCO0FBQ0EsSUFBQSxNQUFNUixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUE7SUFDMUIsSUFBSSxDQUFDUyxpQkFBaUIsR0FBRyxJQUFJQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFZO0FBQ25EVixNQUFBQSxNQUFNLENBQUNXLEtBQUssQ0FBQ3pCLGlCQUFpQixDQUFDLENBQUE7QUFDbkMsS0FBQyxDQUFDLENBQUE7SUFFRixJQUFJLENBQUNPLEtBQUssR0FBRyxDQUFDLENBQUE7SUFDZCxJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDLENBQUE7QUFDZixJQUFBLElBQUksQ0FBQ2tCLE1BQU0sQ0FBQ25CLEtBQUssRUFBRUMsTUFBTSxDQUFDLENBQUE7QUFDOUIsR0FBQTs7QUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ltQixZQUFZQSxDQUFDQyxDQUFDLEVBQUVDLENBQUMsRUFBRXRCLEtBQUssRUFBRUMsTUFBTSxFQUFFO0FBQzlCLElBQUEsTUFBTU0sTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFBO0FBRTFCLElBQUEsSUFBSSxPQUFPYyxDQUFDLEtBQUssUUFBUSxFQUFFO0FBQ3ZCaEIsTUFBQUEsS0FBSyxDQUFDQyxVQUFVLENBQUMsd0ZBQXdGLENBQUMsQ0FBQTtNQUUxRyxNQUFNaUIsSUFBSSxHQUFHRixDQUFDLENBQUE7TUFDZEEsQ0FBQyxHQUFHRSxJQUFJLENBQUNGLENBQUMsQ0FBQTtNQUNWQyxDQUFDLEdBQUdDLElBQUksQ0FBQ0QsQ0FBQyxDQUFBO01BQ1Z0QixLQUFLLEdBQUd1QixJQUFJLENBQUN2QixLQUFLLENBQUE7TUFDbEJDLE1BQU0sR0FBR3NCLElBQUksQ0FBQ3RCLE1BQU0sQ0FBQTtBQUN4QixLQUFDLE1BQU07QUFDSHFCLE1BQUFBLENBQUMsR0FBRyxJQUFJLENBQUNwQixZQUFZLENBQUNELE1BQU0sSUFBSXFCLENBQUMsSUFBSXJCLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3RELEtBQUE7O0FBRUE7QUFDQW9CLElBQUFBLENBQUMsR0FBR0csSUFBSSxDQUFDQyxLQUFLLENBQUNKLENBQUMsQ0FBQyxDQUFBO0FBQ2pCQyxJQUFBQSxDQUFDLEdBQUdFLElBQUksQ0FBQ0MsS0FBSyxDQUFDSCxDQUFDLENBQUMsQ0FBQTtBQUNqQnRCLElBQUFBLEtBQUssR0FBR3dCLElBQUksQ0FBQ0MsS0FBSyxDQUFDRCxJQUFJLENBQUNFLEdBQUcsQ0FBQzFCLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUMzQ0MsSUFBQUEsTUFBTSxHQUFHdUIsSUFBSSxDQUFDQyxLQUFLLENBQUNELElBQUksQ0FBQ0UsR0FBRyxDQUFDekIsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBOztBQUU3QztBQUNBLElBQUEsTUFBTTBCLGdCQUFnQixHQUFHcEIsTUFBTSxDQUFDTCxZQUFZLENBQUE7QUFFNUMwQixJQUFBQSxhQUFhLENBQUNDLGFBQWEsQ0FBQ3RCLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQTs7QUFFN0M7QUFDQUEsSUFBQUEsTUFBTSxDQUFDdUIsZUFBZSxDQUFDLElBQUksQ0FBQzVCLFlBQVksQ0FBQyxDQUFBO0lBQ3pDSyxNQUFNLENBQUN3QixXQUFXLEVBQUUsQ0FBQTtJQUVwQixNQUFNQyxNQUFNLEdBQUcsSUFBSUMsVUFBVSxDQUFDLENBQUMsR0FBR2pDLEtBQUssR0FBR0MsTUFBTSxDQUFDLENBQUE7QUFDakRNLElBQUFBLE1BQU0sQ0FBQzJCLFVBQVUsQ0FBQ2IsQ0FBQyxFQUFFQyxDQUFDLEVBQUV0QixLQUFLLEVBQUVDLE1BQU0sRUFBRStCLE1BQU0sQ0FBQyxDQUFBO0lBRTlDekIsTUFBTSxDQUFDNEIsU0FBUyxFQUFFLENBQUE7O0FBRWxCO0FBQ0E1QixJQUFBQSxNQUFNLENBQUN1QixlQUFlLENBQUNILGdCQUFnQixDQUFDLENBQUE7QUFFeENDLElBQUFBLGFBQWEsQ0FBQ1EsWUFBWSxDQUFDN0IsTUFBTSxDQUFDLENBQUE7QUFFbEMsSUFBQSxNQUFNSSxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUE7QUFDNUIsSUFBQSxLQUFLLElBQUkwQixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdyQyxLQUFLLEdBQUdDLE1BQU0sRUFBRW9DLENBQUMsRUFBRSxFQUFFO01BQ3JDLE1BQU1DLENBQUMsR0FBR04sTUFBTSxDQUFDLENBQUMsR0FBR0ssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO01BQzNCLE1BQU1FLENBQUMsR0FBR1AsTUFBTSxDQUFDLENBQUMsR0FBR0ssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO01BQzNCLE1BQU1HLENBQUMsR0FBR1IsTUFBTSxDQUFDLENBQUMsR0FBR0ssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO01BQzNCLE1BQU1JLEtBQUssR0FBR0gsQ0FBQyxJQUFJLEVBQUUsR0FBR0MsQ0FBQyxJQUFJLENBQUMsR0FBR0MsQ0FBQyxDQUFBOztBQUVsQztNQUNBLElBQUlDLEtBQUssS0FBSyxRQUFRLEVBQUU7QUFDcEJsRCxRQUFBQSxPQUFPLENBQUNtRCxHQUFHLENBQUMvQixPQUFPLENBQUM4QixLQUFLLENBQUMsQ0FBQyxDQUFBO0FBQy9CLE9BQUE7QUFDSixLQUFBOztBQUVBO0lBQ0EsTUFBTUUsU0FBUyxHQUFHLEVBQUUsQ0FBQTtJQUNwQnBELE9BQU8sQ0FBQ3FELE9BQU8sQ0FBQ0MsWUFBWSxJQUFJRixTQUFTLENBQUNHLElBQUksQ0FBQ0QsWUFBWSxDQUFDLENBQUMsQ0FBQTtJQUM3RHRELE9BQU8sQ0FBQzJCLEtBQUssRUFBRSxDQUFBO0FBRWYsSUFBQSxPQUFPeUIsU0FBUyxDQUFBO0FBQ3BCLEdBQUE7QUFFQUksRUFBQUEsb0JBQW9CQSxHQUFHO0lBRW5CLE1BQU1DLFdBQVcsR0FBRyxJQUFJQyxPQUFPLENBQUMsSUFBSSxDQUFDMUMsTUFBTSxFQUFFO0FBQ3pDMkMsTUFBQUEsTUFBTSxFQUFFQyxpQkFBaUI7TUFDekJuRCxLQUFLLEVBQUUsSUFBSSxDQUFDQSxLQUFLO01BQ2pCQyxNQUFNLEVBQUUsSUFBSSxDQUFDQSxNQUFNO0FBQ25CbUQsTUFBQUEsT0FBTyxFQUFFLEtBQUs7QUFDZEMsTUFBQUEsU0FBUyxFQUFFQyxjQUFjO0FBQ3pCQyxNQUFBQSxTQUFTLEVBQUVELGNBQWM7QUFDekJFLE1BQUFBLFFBQVEsRUFBRUMscUJBQXFCO0FBQy9CQyxNQUFBQSxRQUFRLEVBQUVELHFCQUFxQjtBQUMvQkUsTUFBQUEsSUFBSSxFQUFFLE1BQUE7QUFDVixLQUFDLENBQUMsQ0FBQTtBQUVGLElBQUEsSUFBSSxDQUFDekQsWUFBWSxHQUFHLElBQUkwRCxZQUFZLENBQUM7QUFDakNaLE1BQUFBLFdBQVcsRUFBRUEsV0FBVztBQUN4QnRELE1BQUFBLEtBQUssRUFBRSxJQUFBO0FBQ1gsS0FBQyxDQUFDLENBQUE7QUFDTixHQUFBO0FBRUFtRSxFQUFBQSxtQkFBbUJBLEdBQUc7QUFFbEI7QUFDQSxJQUFBLElBQUksQ0FBQ2pELFlBQVksQ0FBQ2tELE1BQU0sQ0FBQzVELFlBQVksR0FBRyxJQUFJLENBQUE7SUFFNUMsSUFBSSxJQUFJLENBQUNBLFlBQVksRUFBRTtBQUNuQixNQUFBLElBQUksQ0FBQ0EsWUFBWSxDQUFDNkQscUJBQXFCLEVBQUUsQ0FBQTtBQUN6QyxNQUFBLElBQUksQ0FBQzdELFlBQVksQ0FBQzhELE9BQU8sRUFBRSxDQUFBO01BQzNCLElBQUksQ0FBQzlELFlBQVksR0FBRyxJQUFJLENBQUE7QUFDNUIsS0FBQTtBQUNKLEdBQUE7QUFFQWEsRUFBQUEsb0JBQW9CQSxHQUFHO0FBRW5CLElBQUEsTUFBTVIsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFBO0lBQzFCLE1BQU0wRCxJQUFJLEdBQUcsSUFBSSxDQUFBO0lBQ2pCLE1BQU1DLFdBQVcsR0FBRzNELE1BQU0sQ0FBQzRELEtBQUssQ0FBQ0MsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFBOztBQUVsRDtBQUNBLElBQUEsSUFBSSxDQUFDeEQsWUFBWSxHQUFHLElBQUl5RCxNQUFNLEVBQUUsQ0FBQTtBQUNoQyxJQUFBLElBQUksQ0FBQ3pELFlBQVksQ0FBQzBELFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQTs7QUFFeEM7QUFDQSxJQUFBLElBQUksQ0FBQ3pELEtBQUssR0FBRyxJQUFJMEQsS0FBSyxDQUFDO0FBQ25CWixNQUFBQSxJQUFJLEVBQUUsUUFBUTtBQUNkYSxNQUFBQSxVQUFVLEVBQUVDLFdBQVc7QUFDdkJDLE1BQUFBLGNBQWMsRUFBRUMsYUFBYTtBQUU3QjtBQUNBQyxNQUFBQSxVQUFVLEVBQUUsVUFBVS9CLFlBQVksRUFBRUosS0FBSyxFQUFFO0FBQ3ZDd0IsUUFBQUEsSUFBSSxDQUFDeEQsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUVnQyxLQUFLLElBQUksRUFBRSxHQUFJLElBQUksSUFBSSxHQUFHLENBQUE7QUFDaER3QixRQUFBQSxJQUFJLENBQUN4RCxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBRWdDLEtBQUssSUFBSSxDQUFDLEdBQUksSUFBSSxJQUFJLEdBQUcsQ0FBQTtRQUMvQ3dCLElBQUksQ0FBQ3hELFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDZ0MsS0FBSyxHQUFHLElBQUksSUFBSSxHQUFHLENBQUE7QUFDeEN5QixRQUFBQSxXQUFXLENBQUNXLFFBQVEsQ0FBQ1osSUFBSSxDQUFDeEQsU0FBUyxDQUFDLENBQUE7QUFDcENGLFFBQUFBLE1BQU0sQ0FBQ3VFLGFBQWEsQ0FBQ0MsVUFBVSxDQUFDQyxPQUFPLENBQUMsQ0FBQTs7QUFFeEM7QUFDQWYsUUFBQUEsSUFBSSxDQUFDdEQsT0FBTyxDQUFDOEIsS0FBSyxDQUFDLEdBQUdJLFlBQVksQ0FBQTtBQUN0QyxPQUFBO0FBQ0osS0FBQyxDQUFDLENBQUE7SUFDRixJQUFJLENBQUNoQyxLQUFLLENBQUNvRSxTQUFTLENBQUMsSUFBSSxDQUFDckUsWUFBWSxDQUFDa0QsTUFBTSxDQUFDLENBQUE7O0FBRTlDO0FBQ0EsSUFBQSxJQUFJLENBQUNoRCxTQUFTLEdBQUcsSUFBSW9FLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFBO0lBQy9DLElBQUksQ0FBQ3BFLFNBQVMsQ0FBQ3FFLFVBQVUsQ0FBQyxJQUFJLENBQUN0RSxLQUFLLENBQUMsQ0FBQTtBQUN6QyxHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJdUUsRUFBQUEsT0FBT0EsQ0FBQ3RCLE1BQU0sRUFBRXVCLEtBQUssRUFBRUMsTUFBTSxFQUFFO0FBRTNCO0lBQ0EsSUFBSXhCLE1BQU0sWUFBWXlCLE1BQU0sRUFBRTtBQUMxQmxGLE1BQUFBLEtBQUssQ0FBQ0MsVUFBVSxDQUFDLG9HQUFvRyxDQUFDLENBQUE7O0FBRXRIO0FBQ0F3RCxNQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQzBCLElBQUksQ0FBQzFCLE1BQU0sQ0FBQTtBQUMvQixLQUFBO0lBRUEsSUFBSXdCLE1BQU0sWUFBWWYsS0FBSyxFQUFFO01BQ3pCZSxNQUFNLEdBQUcsQ0FBQ0EsTUFBTSxDQUFDLENBQUE7QUFDckIsS0FBQTs7QUFFQTtBQUNBLElBQUEsSUFBSSxDQUFDekUsS0FBSyxDQUFDNEUsa0JBQWtCLEVBQUUsQ0FBQTtBQUMvQixJQUFBLE1BQU1DLGlCQUFpQixHQUFHLElBQUksQ0FBQzdFLEtBQUssQ0FBQzhFLG1CQUFtQixDQUFBOztBQUV4RDtBQUNBLElBQUEsTUFBTUMsU0FBUyxHQUFHUCxLQUFLLENBQUNDLE1BQU0sQ0FBQ08sU0FBUyxDQUFBO0FBQ3hDLElBQUEsTUFBTUMsZUFBZSxHQUFHVCxLQUFLLENBQUNDLE1BQU0sQ0FBQ1EsZUFBZSxDQUFBO0FBQ3BELElBQUEsTUFBTUMsYUFBYSxHQUFHVixLQUFLLENBQUNDLE1BQU0sQ0FBQ1UsWUFBWSxDQUFBO0FBRS9DLElBQUEsS0FBSyxJQUFJM0QsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHdUQsU0FBUyxDQUFDSyxNQUFNLEVBQUU1RCxDQUFDLEVBQUUsRUFBRTtBQUN2QyxNQUFBLE1BQU02RCxRQUFRLEdBQUdOLFNBQVMsQ0FBQ3ZELENBQUMsQ0FBQyxDQUFBOztBQUU3QjtNQUNBLElBQUlpRCxNQUFNLElBQUlBLE1BQU0sQ0FBQ2EsT0FBTyxDQUFDRCxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDeEMsUUFBQSxTQUFBO0FBQ0osT0FBQTtNQUVBLElBQUlBLFFBQVEsQ0FBQ0UsT0FBTyxJQUFJTixlQUFlLENBQUN6RCxDQUFDLENBQUMsRUFBRTtBQUV4QztRQUNBLE1BQU1nRSxVQUFVLEdBQUdILFFBQVEsQ0FBQ0ksT0FBTyxDQUFDSCxPQUFPLENBQUNyQyxNQUFNLENBQUMsQ0FBQTtRQUNuRCxJQUFJdUMsVUFBVSxJQUFJLENBQUMsRUFBRTtBQUVqQjtVQUNBLElBQUlILFFBQVEsQ0FBQ0ssaUJBQWlCLEVBQUU7QUFDNUJiLFlBQUFBLGlCQUFpQixDQUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQzlCLGlCQUFpQixDQUFDLENBQUE7QUFDbEQsV0FBQTs7QUFFQTtBQUNBLFVBQUEsTUFBTXdGLGFBQWEsR0FBR1QsYUFBYSxDQUFDMUQsQ0FBQyxDQUFDLEdBQUc2RCxRQUFRLENBQUNPLFNBQVMsQ0FBQ0Msd0JBQXdCLEdBQUdSLFFBQVEsQ0FBQ08sU0FBUyxDQUFDZCxtQkFBbUIsQ0FBQTtBQUM3SCxVQUFBLEtBQUssSUFBSWdCLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0gsYUFBYSxDQUFDUCxNQUFNLEVBQUVVLENBQUMsRUFBRSxFQUFFO0FBQzNDLFlBQUEsTUFBTTlELFlBQVksR0FBRzJELGFBQWEsQ0FBQ0csQ0FBQyxDQUFDLENBQUE7WUFDckMsSUFBSTlELFlBQVksQ0FBQytELElBQUksRUFBRTtBQUNuQmxCLGNBQUFBLGlCQUFpQixDQUFDNUMsSUFBSSxDQUFDRCxZQUFZLENBQUMsQ0FBQTtBQUN4QyxhQUFBO0FBQ0osV0FBQTtBQUNKLFNBQUE7QUFDSixPQUFBO0FBQ0osS0FBQTs7QUFFQTtJQUNBLElBQUksQ0FBQyxJQUFJLENBQUMzQyxZQUFZLElBQUssSUFBSSxDQUFDRixLQUFLLEtBQUssSUFBSSxDQUFDRSxZQUFZLENBQUNGLEtBQUssSUFBSSxJQUFJLENBQUNDLE1BQU0sS0FBSyxJQUFJLENBQUNDLFlBQVksQ0FBQ0QsTUFBTyxFQUFFO01BQzVHLElBQUksQ0FBQzRELG1CQUFtQixFQUFFLENBQUE7TUFDMUIsSUFBSSxDQUFDZCxvQkFBb0IsRUFBRSxDQUFBO0FBQy9CLEtBQUE7O0FBRUE7QUFDQSxJQUFBLElBQUksQ0FBQzhELFlBQVksQ0FBQy9DLE1BQU0sQ0FBQyxDQUFBOztBQUV6QjtBQUNBLElBQUEsSUFBSSxDQUFDbkQsT0FBTyxDQUFDc0YsTUFBTSxHQUFHLENBQUMsQ0FBQTs7QUFFdkI7SUFDQSxJQUFJLENBQUNsRyxHQUFHLENBQUMrRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUNoRyxTQUFTLENBQUMsQ0FBQTtBQUM5QyxHQUFBO0VBRUErRixZQUFZQSxDQUFDRSxTQUFTLEVBQUU7QUFFcEI7SUFDQSxJQUFJLENBQUNuRyxZQUFZLENBQUNvRyxJQUFJLENBQUNELFNBQVMsQ0FBQ0UsTUFBTSxDQUFDLENBQUE7QUFDeEMsSUFBQSxJQUFJLENBQUNyRyxZQUFZLENBQUMrQyxJQUFJLEdBQUcsY0FBYyxDQUFBOztBQUV2QztBQUNBLElBQUEsTUFBTXVELFVBQVUsR0FBRyxJQUFJLENBQUN0RyxZQUFZLENBQUNrRCxNQUFNLENBQUE7QUFDM0NvRCxJQUFBQSxVQUFVLENBQUNGLElBQUksQ0FBQ0QsU0FBUyxDQUFDLENBQUE7O0FBRTFCO0lBQ0FHLFVBQVUsQ0FBQ0MsZ0JBQWdCLEdBQUcsSUFBSSxDQUFBO0lBQ2xDRCxVQUFVLENBQUNFLGdCQUFnQixHQUFHLElBQUksQ0FBQTtJQUNsQ0YsVUFBVSxDQUFDRyxrQkFBa0IsR0FBRyxJQUFJLENBQUE7QUFDcENILElBQUFBLFVBQVUsQ0FBQ0ksVUFBVSxHQUFHQyxLQUFLLENBQUNDLEtBQUssQ0FBQTs7QUFFbkM7QUFDQU4sSUFBQUEsVUFBVSxDQUFDaEgsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWSxDQUFBOztBQUUzQztBQUNBLElBQUEsSUFBSSxDQUFDVyxLQUFLLENBQUM0RyxZQUFZLEVBQUUsQ0FBQTtBQUN6QixJQUFBLElBQUksQ0FBQzVHLEtBQUssQ0FBQ29FLFNBQVMsQ0FBQ2lDLFVBQVUsQ0FBQyxDQUFBO0lBQ2hDQSxVQUFVLENBQUM1QixNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUN6RSxLQUFLLENBQUM2RyxFQUFFLENBQUMsQ0FBQTtBQUN2QyxHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0l2RyxFQUFBQSxNQUFNQSxDQUFDbkIsS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFDbEIsSUFBSSxDQUFDRCxLQUFLLEdBQUd3QixJQUFJLENBQUNDLEtBQUssQ0FBQ3pCLEtBQUssQ0FBQyxDQUFBO0lBQzlCLElBQUksQ0FBQ0MsTUFBTSxHQUFHdUIsSUFBSSxDQUFDQyxLQUFLLENBQUN4QixNQUFNLENBQUMsQ0FBQTtBQUNwQyxHQUFBO0FBQ0o7Ozs7In0=
