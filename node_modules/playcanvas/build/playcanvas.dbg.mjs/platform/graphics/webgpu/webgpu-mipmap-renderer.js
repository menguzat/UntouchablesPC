import { Shader } from '../shader.js';
import { SHADERLANGUAGE_WGSL } from '../constants.js';
import { Debug, DebugHelper } from '../../../core/debug.js';
import { DebugGraphics } from '../debug-graphics.js';

/**
 * A WebGPU helper class implementing texture mipmap generation.
 *
 * @ignore
 */
class WebgpuMipmapRenderer {
  constructor(device) {
    /** @type {import('./webgpu-graphics-device.js').WebgpuGraphicsDevice} */
    this.device = void 0;
    this.device = device;
    const wgpu = device.wgpu;

    // Shader that renders a fullscreen textured quad
    const code = `
 
            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
                vec2(-1.0, 1.0), vec2(1.0, 1.0),
                vec2(-1.0, -1.0), vec2(1.0, -1.0)
            );

            struct VertexOutput {
                @builtin(position) position : vec4f,
                @location(0) texCoord : vec2f
            };

            @vertex
            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
              var output : VertexOutput;
              output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
              output.position = vec4f(pos[vertexIndex], 0, 1);
              return output;
            }

            @group(0) @binding(0) var imgSampler : sampler;
            @group(0) @binding(1) var img : texture_2d<f32>;

            @fragment
            fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
              return textureSample(img, imgSampler, texCoord);
            }
        `;
    this.shader = new Shader(device, {
      name: 'WebGPUMipmapRendererShader',
      shaderLanguage: SHADERLANGUAGE_WGSL,
      vshader: code,
      fshader: code
    });

    // using minified rendering, so that's the only filter mode we need to set.
    this.minSampler = wgpu.createSampler({
      minFilter: 'linear'
    });
  }

  /**
   * Generates mipmaps for the specified WebGPU texture.
   *
   * @param {import('./webgpu-texture.js').WebgpuTexture} webgpuTexture - The texture to generate mipmaps for.
   */
  generate(webgpuTexture) {
    // ignore texture with no mipmaps
    const textureDescr = webgpuTexture.descr;
    if (textureDescr.mipLevelCount <= 1) {
      return;
    }

    // not all types are currently supported
    if (webgpuTexture.texture.cubemap || webgpuTexture.texture.volume) {
      Debug.warnOnce('WebGPU mipmap generation is not supported for cubemaps or volume texture.', webgpuTexture.texture);
      return;
    }
    const device = this.device;
    DebugGraphics.pushGpuMarker(device, 'MIPMAP-RENDERER');

    // cannot run this inside render pass
    Debug.assert(!device.insideRenderPass);
    const wgpu = device.wgpu;

    /** @type {import('./webgpu-shader.js').WebgpuShader} */
    const webgpuShader = this.shader.impl;
    const pipeline = wgpu.createRenderPipeline({
      layout: 'auto',
      vertex: {
        module: webgpuShader.getVertexShaderModule(),
        entryPoint: webgpuShader.vertexEntryPoint
      },
      fragment: {
        module: webgpuShader.getFragmentShaderModule(),
        entryPoint: webgpuShader.fragmentEntryPoint,
        targets: [{
          format: textureDescr.format // use the same format as the texture
        }]
      },

      primitive: {
        topology: 'triangle-strip'
      }
    });
    let srcView = webgpuTexture.createView({
      baseMipLevel: 0,
      mipLevelCount: 1
    });

    // loop through each mip level and render the previous level's contents into it.
    const commandEncoder = wgpu.createCommandEncoder();
    for (let i = 1; i < textureDescr.mipLevelCount; i++) {
      const dstView = webgpuTexture.createView({
        baseMipLevel: i,
        mipLevelCount: 1
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: dstView,
          loadOp: 'clear',
          storeOp: 'store'
        }]
      });
      DebugHelper.setLabel(passEncoder, `MipmapRenderer-PassEncoder_${i}`);
      const bindGroup = wgpu.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [{
          binding: 0,
          resource: this.minSampler
        }, {
          binding: 1,
          resource: srcView
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4);
      passEncoder.end();

      // next iteration
      srcView = dstView;
    }
    wgpu.queue.submit([commandEncoder.finish()]);

    // clear invalidated state
    device.pipeline = null;
    DebugGraphics.popGpuMarker(device);
  }
}

export { WebgpuMipmapRenderer };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ3B1LW1pcG1hcC1yZW5kZXJlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3BsYXRmb3JtL2dyYXBoaWNzL3dlYmdwdS93ZWJncHUtbWlwbWFwLXJlbmRlcmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlciB9IGZyb20gXCIuLi9zaGFkZXIuanNcIjtcbmltcG9ydCB7IFNIQURFUkxBTkdVQUdFX1dHU0wgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBEZWJ1ZywgRGVidWdIZWxwZXIgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9kZWJ1Zy5qc1wiO1xuaW1wb3J0IHsgRGVidWdHcmFwaGljcyB9IGZyb20gXCIuLi9kZWJ1Zy1ncmFwaGljcy5qc1wiO1xuXG4vKipcbiAqIEEgV2ViR1BVIGhlbHBlciBjbGFzcyBpbXBsZW1lbnRpbmcgdGV4dHVyZSBtaXBtYXAgZ2VuZXJhdGlvbi5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIFdlYmdwdU1pcG1hcFJlbmRlcmVyIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi93ZWJncHUtZ3JhcGhpY3MtZGV2aWNlLmpzJykuV2ViZ3B1R3JhcGhpY3NEZXZpY2V9ICovXG4gICAgZGV2aWNlO1xuXG4gICAgY29uc3RydWN0b3IoZGV2aWNlKSB7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gZGV2aWNlO1xuICAgICAgICBjb25zdCB3Z3B1ID0gZGV2aWNlLndncHU7XG5cbiAgICAgICAgLy8gU2hhZGVyIHRoYXQgcmVuZGVycyBhIGZ1bGxzY3JlZW4gdGV4dHVyZWQgcXVhZFxuICAgICAgICBjb25zdCBjb2RlID0gYFxuIFxuICAgICAgICAgICAgdmFyPHByaXZhdGU+IHBvcyA6IGFycmF5PHZlYzJmLCA0PiA9IGFycmF5PHZlYzJmLCA0PihcbiAgICAgICAgICAgICAgICB2ZWMyKC0xLjAsIDEuMCksIHZlYzIoMS4wLCAxLjApLFxuICAgICAgICAgICAgICAgIHZlYzIoLTEuMCwgLTEuMCksIHZlYzIoMS4wLCAtMS4wKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc3RydWN0IFZlcnRleE91dHB1dCB7XG4gICAgICAgICAgICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uIDogdmVjNGYsXG4gICAgICAgICAgICAgICAgQGxvY2F0aW9uKDApIHRleENvb3JkIDogdmVjMmZcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEB2ZXJ0ZXhcbiAgICAgICAgICAgIGZuIHZlcnRleE1haW4oQGJ1aWx0aW4odmVydGV4X2luZGV4KSB2ZXJ0ZXhJbmRleCA6IHUzMikgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgICAgICAgdmFyIG91dHB1dCA6IFZlcnRleE91dHB1dDtcbiAgICAgICAgICAgICAgb3V0cHV0LnRleENvb3JkID0gcG9zW3ZlcnRleEluZGV4XSAqIHZlYzJmKDAuNSwgLTAuNSkgKyB2ZWMyZigwLjUpO1xuICAgICAgICAgICAgICBvdXRwdXQucG9zaXRpb24gPSB2ZWM0Zihwb3NbdmVydGV4SW5kZXhdLCAwLCAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhciBpbWdTYW1wbGVyIDogc2FtcGxlcjtcbiAgICAgICAgICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgaW1nIDogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgICAgICAgICBAZnJhZ21lbnRcbiAgICAgICAgICAgIGZuIGZyYWdtZW50TWFpbihAbG9jYXRpb24oMCkgdGV4Q29vcmQgOiB2ZWMyZikgLT4gQGxvY2F0aW9uKDApIHZlYzRmIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVTYW1wbGUoaW1nLCBpbWdTYW1wbGVyLCB0ZXhDb29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICAgICAgdGhpcy5zaGFkZXIgPSBuZXcgU2hhZGVyKGRldmljZSwge1xuICAgICAgICAgICAgbmFtZTogJ1dlYkdQVU1pcG1hcFJlbmRlcmVyU2hhZGVyJyxcbiAgICAgICAgICAgIHNoYWRlckxhbmd1YWdlOiBTSEFERVJMQU5HVUFHRV9XR1NMLFxuICAgICAgICAgICAgdnNoYWRlcjogY29kZSxcbiAgICAgICAgICAgIGZzaGFkZXI6IGNvZGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdXNpbmcgbWluaWZpZWQgcmVuZGVyaW5nLCBzbyB0aGF0J3MgdGhlIG9ubHkgZmlsdGVyIG1vZGUgd2UgbmVlZCB0byBzZXQuXG4gICAgICAgIHRoaXMubWluU2FtcGxlciA9IHdncHUuY3JlYXRlU2FtcGxlcih7IG1pbkZpbHRlcjogJ2xpbmVhcicgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIG1pcG1hcHMgZm9yIHRoZSBzcGVjaWZpZWQgV2ViR1BVIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJncHUtdGV4dHVyZS5qcycpLldlYmdwdVRleHR1cmV9IHdlYmdwdVRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byBnZW5lcmF0ZSBtaXBtYXBzIGZvci5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZSh3ZWJncHVUZXh0dXJlKSB7XG5cbiAgICAgICAgLy8gaWdub3JlIHRleHR1cmUgd2l0aCBubyBtaXBtYXBzXG4gICAgICAgIGNvbnN0IHRleHR1cmVEZXNjciA9IHdlYmdwdVRleHR1cmUuZGVzY3I7XG4gICAgICAgIGlmICh0ZXh0dXJlRGVzY3IubWlwTGV2ZWxDb3VudCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3QgYWxsIHR5cGVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkXG4gICAgICAgIGlmICh3ZWJncHVUZXh0dXJlLnRleHR1cmUuY3ViZW1hcCB8fCB3ZWJncHVUZXh0dXJlLnRleHR1cmUudm9sdW1lKSB7XG4gICAgICAgICAgICBEZWJ1Zy53YXJuT25jZSgnV2ViR1BVIG1pcG1hcCBnZW5lcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGN1YmVtYXBzIG9yIHZvbHVtZSB0ZXh0dXJlLicsIHdlYmdwdVRleHR1cmUudGV4dHVyZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgICAgICAgRGVidWdHcmFwaGljcy5wdXNoR3B1TWFya2VyKGRldmljZSwgJ01JUE1BUC1SRU5ERVJFUicpO1xuXG4gICAgICAgIC8vIGNhbm5vdCBydW4gdGhpcyBpbnNpZGUgcmVuZGVyIHBhc3NcbiAgICAgICAgRGVidWcuYXNzZXJ0KCFkZXZpY2UuaW5zaWRlUmVuZGVyUGFzcyk7XG5cbiAgICAgICAgY29uc3Qgd2dwdSA9IGRldmljZS53Z3B1O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3dlYmdwdS1zaGFkZXIuanMnKS5XZWJncHVTaGFkZXJ9ICovXG4gICAgICAgIGNvbnN0IHdlYmdwdVNoYWRlciA9IHRoaXMuc2hhZGVyLmltcGw7XG5cbiAgICAgICAgY29uc3QgcGlwZWxpbmUgPSB3Z3B1LmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgICAgIGxheW91dDogJ2F1dG8nLFxuICAgICAgICAgICAgdmVydGV4OiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiB3ZWJncHVTaGFkZXIuZ2V0VmVydGV4U2hhZGVyTW9kdWxlKCksXG4gICAgICAgICAgICAgICAgZW50cnlQb2ludDogd2ViZ3B1U2hhZGVyLnZlcnRleEVudHJ5UG9pbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmFnbWVudDoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogd2ViZ3B1U2hhZGVyLmdldEZyYWdtZW50U2hhZGVyTW9kdWxlKCksXG4gICAgICAgICAgICAgICAgZW50cnlQb2ludDogd2ViZ3B1U2hhZGVyLmZyYWdtZW50RW50cnlQb2ludCxcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiBbe1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRleHR1cmVEZXNjci5mb3JtYXQgLy8gdXNlIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpbWl0aXZlOiB7XG4gICAgICAgICAgICAgICAgdG9wb2xvZ3k6ICd0cmlhbmdsZS1zdHJpcCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHNyY1ZpZXcgPSB3ZWJncHVUZXh0dXJlLmNyZWF0ZVZpZXcoe1xuICAgICAgICAgICAgYmFzZU1pcExldmVsOiAwLFxuICAgICAgICAgICAgbWlwTGV2ZWxDb3VudDogMVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBtaXAgbGV2ZWwgYW5kIHJlbmRlciB0aGUgcHJldmlvdXMgbGV2ZWwncyBjb250ZW50cyBpbnRvIGl0LlxuICAgICAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHdncHUuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0ZXh0dXJlRGVzY3IubWlwTGV2ZWxDb3VudDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGRzdFZpZXcgPSB3ZWJncHVUZXh0dXJlLmNyZWF0ZVZpZXcoe1xuICAgICAgICAgICAgICAgIGJhc2VNaXBMZXZlbDogaSxcbiAgICAgICAgICAgICAgICBtaXBMZXZlbENvdW50OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcGFzc0VuY29kZXIgPSBjb21tYW5kRW5jb2Rlci5iZWdpblJlbmRlclBhc3Moe1xuICAgICAgICAgICAgICAgIGNvbG9yQXR0YWNobWVudHM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGRzdFZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRPcDogJ2NsZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVPcDogJ3N0b3JlJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIERlYnVnSGVscGVyLnNldExhYmVsKHBhc3NFbmNvZGVyLCBgTWlwbWFwUmVuZGVyZXItUGFzc0VuY29kZXJfJHtpfWApO1xuXG4gICAgICAgICAgICBjb25zdCBiaW5kR3JvdXAgPSB3Z3B1LmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgICAgICAgICAgbGF5b3V0OiBwaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksXG4gICAgICAgICAgICAgICAgZW50cmllczogW3tcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMubWluU2FtcGxlclxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHNyY1ZpZXdcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIHBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCBiaW5kR3JvdXApO1xuICAgICAgICAgICAgcGFzc0VuY29kZXIuZHJhdyg0KTtcbiAgICAgICAgICAgIHBhc3NFbmNvZGVyLmVuZCgpO1xuXG4gICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgc3JjVmlldyA9IGRzdFZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICB3Z3B1LnF1ZXVlLnN1Ym1pdChbY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcblxuICAgICAgICAvLyBjbGVhciBpbnZhbGlkYXRlZCBzdGF0ZVxuICAgICAgICBkZXZpY2UucGlwZWxpbmUgPSBudWxsO1xuXG4gICAgICAgIERlYnVnR3JhcGhpY3MucG9wR3B1TWFya2VyKGRldmljZSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBXZWJncHVNaXBtYXBSZW5kZXJlciB9O1xuIl0sIm5hbWVzIjpbIldlYmdwdU1pcG1hcFJlbmRlcmVyIiwiY29uc3RydWN0b3IiLCJkZXZpY2UiLCJ3Z3B1IiwiY29kZSIsInNoYWRlciIsIlNoYWRlciIsIm5hbWUiLCJzaGFkZXJMYW5ndWFnZSIsIlNIQURFUkxBTkdVQUdFX1dHU0wiLCJ2c2hhZGVyIiwiZnNoYWRlciIsIm1pblNhbXBsZXIiLCJjcmVhdGVTYW1wbGVyIiwibWluRmlsdGVyIiwiZ2VuZXJhdGUiLCJ3ZWJncHVUZXh0dXJlIiwidGV4dHVyZURlc2NyIiwiZGVzY3IiLCJtaXBMZXZlbENvdW50IiwidGV4dHVyZSIsImN1YmVtYXAiLCJ2b2x1bWUiLCJEZWJ1ZyIsIndhcm5PbmNlIiwiRGVidWdHcmFwaGljcyIsInB1c2hHcHVNYXJrZXIiLCJhc3NlcnQiLCJpbnNpZGVSZW5kZXJQYXNzIiwid2ViZ3B1U2hhZGVyIiwiaW1wbCIsInBpcGVsaW5lIiwiY3JlYXRlUmVuZGVyUGlwZWxpbmUiLCJsYXlvdXQiLCJ2ZXJ0ZXgiLCJtb2R1bGUiLCJnZXRWZXJ0ZXhTaGFkZXJNb2R1bGUiLCJlbnRyeVBvaW50IiwidmVydGV4RW50cnlQb2ludCIsImZyYWdtZW50IiwiZ2V0RnJhZ21lbnRTaGFkZXJNb2R1bGUiLCJmcmFnbWVudEVudHJ5UG9pbnQiLCJ0YXJnZXRzIiwiZm9ybWF0IiwicHJpbWl0aXZlIiwidG9wb2xvZ3kiLCJzcmNWaWV3IiwiY3JlYXRlVmlldyIsImJhc2VNaXBMZXZlbCIsImNvbW1hbmRFbmNvZGVyIiwiY3JlYXRlQ29tbWFuZEVuY29kZXIiLCJpIiwiZHN0VmlldyIsInBhc3NFbmNvZGVyIiwiYmVnaW5SZW5kZXJQYXNzIiwiY29sb3JBdHRhY2htZW50cyIsInZpZXciLCJsb2FkT3AiLCJzdG9yZU9wIiwiRGVidWdIZWxwZXIiLCJzZXRMYWJlbCIsImJpbmRHcm91cCIsImNyZWF0ZUJpbmRHcm91cCIsImdldEJpbmRHcm91cExheW91dCIsImVudHJpZXMiLCJiaW5kaW5nIiwicmVzb3VyY2UiLCJzZXRQaXBlbGluZSIsInNldEJpbmRHcm91cCIsImRyYXciLCJlbmQiLCJxdWV1ZSIsInN1Ym1pdCIsImZpbmlzaCIsInBvcEdwdU1hcmtlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsb0JBQW9CLENBQUM7RUFJdkJDLFdBQVdBLENBQUNDLE1BQU0sRUFBRTtBQUhwQjtBQUFBLElBQUEsSUFBQSxDQUNBQSxNQUFNLEdBQUEsS0FBQSxDQUFBLENBQUE7SUFHRixJQUFJLENBQUNBLE1BQU0sR0FBR0EsTUFBTSxDQUFBO0FBQ3BCLElBQUEsTUFBTUMsSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUksQ0FBQTs7QUFFeEI7QUFDQSxJQUFBLE1BQU1DLElBQUksR0FBSSxDQUFBO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFTLENBQUEsQ0FBQTtBQUVELElBQUEsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUMsTUFBTSxDQUFDSixNQUFNLEVBQUU7QUFDN0JLLE1BQUFBLElBQUksRUFBRSw0QkFBNEI7QUFDbENDLE1BQUFBLGNBQWMsRUFBRUMsbUJBQW1CO0FBQ25DQyxNQUFBQSxPQUFPLEVBQUVOLElBQUk7QUFDYk8sTUFBQUEsT0FBTyxFQUFFUCxJQUFBQTtBQUNiLEtBQUMsQ0FBQyxDQUFBOztBQUVGO0FBQ0EsSUFBQSxJQUFJLENBQUNRLFVBQVUsR0FBR1QsSUFBSSxDQUFDVSxhQUFhLENBQUM7QUFBRUMsTUFBQUEsU0FBUyxFQUFFLFFBQUE7QUFBUyxLQUFDLENBQUMsQ0FBQTtBQUNq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
