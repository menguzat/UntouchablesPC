import { Debug } from '../../core/debug.js';
import { hashCode } from '../../core/hash.js';
import { math } from '../../core/math/math.js';
import { typedArrayTypesByteSize, vertexTypesNames, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_COLOR, SEMANTIC_TANGENT, SEMANTIC_ATTR12, TYPE_FLOAT32, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15 } from './constants.js';

/**
 * A vertex format is a descriptor that defines the layout of vertex data inside a
 * {@link VertexBuffer}.
 *
 * @property {object[]} elements The vertex attribute elements.
 * @property {string} elements[].name The meaning of the vertex element. This is used to link the
 * vertex data to a shader input. Can be:
 *
 * - {@link SEMANTIC_POSITION}
 * - {@link SEMANTIC_NORMAL}
 * - {@link SEMANTIC_TANGENT}
 * - {@link SEMANTIC_BLENDWEIGHT}
 * - {@link SEMANTIC_BLENDINDICES}
 * - {@link SEMANTIC_COLOR}
 * - {@link SEMANTIC_TEXCOORD0}
 * - {@link SEMANTIC_TEXCOORD1}
 * - {@link SEMANTIC_TEXCOORD2}
 * - {@link SEMANTIC_TEXCOORD3}
 * - {@link SEMANTIC_TEXCOORD4}
 * - {@link SEMANTIC_TEXCOORD5}
 * - {@link SEMANTIC_TEXCOORD6}
 * - {@link SEMANTIC_TEXCOORD7}
 *
 * If vertex data has a meaning other that one of those listed above, use the user-defined
 * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
 * @property {number} elements[].numComponents The number of components of the vertex attribute.
 * Can be 1, 2, 3 or 4.
 * @property {number} elements[].dataType The data type of the attribute. Can be:
 *
 * - {@link TYPE_INT8}
 * - {@link TYPE_UINT8}
 * - {@link TYPE_INT16}
 * - {@link TYPE_UINT16}
 * - {@link TYPE_INT32}
 * - {@link TYPE_UINT32}
 * - {@link TYPE_FLOAT32}
 * @property {boolean} elements[].normalize If true, vertex attribute data will be mapped from a 0
 * to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
 * unchanged. If this property is unspecified, false is assumed.
 * @property {number} elements[].offset The number of initial bytes at the start of a vertex that
 * are not relevant to this attribute.
 * @property {number} elements[].stride The number of total bytes that are between the start of one
 * vertex, and the start of the next.
 * @property {number} elements[].size The size of the attribute in bytes.
 */
class VertexFormat {
  /**
   * Create a new VertexFormat instance.
   *
   * @param {import('./graphics-device.js').GraphicsDevice} graphicsDevice - The graphics device
   * used to manage this vertex format.
   * @param {object[]} description - An array of vertex attribute descriptions.
   * @param {string} description[].semantic - The meaning of the vertex element. This is used to
   * link the vertex data to a shader input. Can be:
   *
   * - {@link SEMANTIC_POSITION}
   * - {@link SEMANTIC_NORMAL}
   * - {@link SEMANTIC_TANGENT}
   * - {@link SEMANTIC_BLENDWEIGHT}
   * - {@link SEMANTIC_BLENDINDICES}
   * - {@link SEMANTIC_COLOR}
   * - {@link SEMANTIC_TEXCOORD0}
   * - {@link SEMANTIC_TEXCOORD1}
   * - {@link SEMANTIC_TEXCOORD2}
   * - {@link SEMANTIC_TEXCOORD3}
   * - {@link SEMANTIC_TEXCOORD4}
   * - {@link SEMANTIC_TEXCOORD5}
   * - {@link SEMANTIC_TEXCOORD6}
   * - {@link SEMANTIC_TEXCOORD7}
   *
   * If vertex data has a meaning other that one of those listed above, use the user-defined
   * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
   * @param {number} description[].components - The number of components of the vertex attribute.
   * Can be 1, 2, 3 or 4.
   * @param {number} description[].type - The data type of the attribute. Can be:
   *
   * - {@link TYPE_INT8}
   * - {@link TYPE_UINT8}
   * - {@link TYPE_INT16}
   * - {@link TYPE_UINT16}
   * - {@link TYPE_INT32}
   * - {@link TYPE_UINT32}
   * - {@link TYPE_FLOAT32}
   *
   * @param {boolean} [description[].normalize] - If true, vertex attribute data will be mapped
   * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data
   * is left unchanged. If this property is unspecified, false is assumed.
   * @param {number} [vertexCount] - When specified, vertex format will be set up for
   * non-interleaved format with a specified number of vertices. (example: PPPPNNNNCCCC), where
   * arrays of individual attributes will be stored one right after the other (subject to
   * alignment requirements). Note that in this case, the format depends on the number of
   * vertices, and needs to change when the number of vertices changes. When not specified,
   * vertex format will be interleaved. (example: PNCPNCPNCPNC).
   * @example
   * // Specify 3-component positions (x, y, z)
   * const vertexFormat = new pc.VertexFormat(graphicsDevice, [
   *     { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
   * ]);
   * @example
   * // Specify 2-component positions (x, y), a texture coordinate (u, v) and a vertex color (r, g, b, a)
   * const vertexFormat = new pc.VertexFormat(graphicsDevice, [
   *     { semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 },
   *     { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 },
   *     { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: true }
   * ]);
   */
  constructor(graphicsDevice, description, vertexCount) {
    this.device = graphicsDevice;
    this._elements = [];
    this.hasUv0 = false;
    this.hasUv1 = false;
    this.hasColor = false;
    this.hasTangents = false;
    this.verticesByteSize = 0;
    this.vertexCount = vertexCount;
    this.interleaved = vertexCount === undefined;

    // true if the vertex format represents an instancing vertex buffer
    this.instancing = false;

    // calculate total size of the vertex
    this.size = description.reduce((total, desc) => {
      return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
    }, 0);
    let offset = 0,
      elementSize;
    for (let i = 0, len = description.length; i < len; i++) {
      var _elementDesc$normaliz;
      const elementDesc = description[i];
      elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];

      // WebGPU has limited element size support (for example uint16x3 is not supported)
      Debug.assert(!graphicsDevice.isWebGPU || [2, 4, 8, 12, 16].includes(elementSize), `WebGPU does not support the format of vertex element ${elementDesc.semantic} : ${vertexTypesNames[elementDesc.type]} x ${elementDesc.components}`);

      // align up the offset to elementSize (when vertexCount is specified only - case of non-interleaved format)
      if (vertexCount) {
        offset = math.roundUp(offset, elementSize);

        // non-interleaved format with elementSize not multiple of 4 might be slower on some platforms - padding is recommended to align its size
        // example: use 4 x TYPE_UINT8 instead of 3 x TYPE_UINT8
        Debug.assert(elementSize % 4 === 0, `Non-interleaved vertex format with element size not multiple of 4 can have performance impact on some platforms. Element size: ${elementSize}`);
      }
      const element = {
        name: elementDesc.semantic,
        offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
        stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
        dataType: elementDesc.type,
        numComponents: elementDesc.components,
        normalize: (_elementDesc$normaliz = elementDesc.normalize) != null ? _elementDesc$normaliz : false,
        size: elementSize
      };
      this._elements.push(element);
      if (vertexCount) {
        offset += elementSize * vertexCount;
      } else {
        offset += Math.ceil(elementSize / 4) * 4;
      }
      if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
        this.hasUv0 = true;
      } else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
        this.hasUv1 = true;
      } else if (elementDesc.semantic === SEMANTIC_COLOR) {
        this.hasColor = true;
      } else if (elementDesc.semantic === SEMANTIC_TANGENT) {
        this.hasTangents = true;
      }
    }
    if (vertexCount) {
      this.verticesByteSize = offset;
    }
    this._evaluateHash();
  }
  get elements() {
    return this._elements;
  }

  /**
   * @type {VertexFormat}
   * @private
   */

  /**
   * The {@link VertexFormat} used to store matrices of type {@link Mat4} for hardware instancing.
   *
   * @param {import('./graphics-device.js').GraphicsDevice} graphicsDevice - The graphics device
   * used to create this vertex format.
   *
   * @returns {VertexFormat} The default instancing vertex format.
   */
  static getDefaultInstancingFormat(graphicsDevice) {
    if (!VertexFormat._defaultInstancingFormat) {
      VertexFormat._defaultInstancingFormat = new VertexFormat(graphicsDevice, [{
        semantic: SEMANTIC_ATTR12,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR13,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR14,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR15,
        components: 4,
        type: TYPE_FLOAT32
      }]);
    }
    return VertexFormat._defaultInstancingFormat;
  }

  /**
   * Applies any changes made to the VertexFormat's properties.
   *
   * @private
   */
  update() {
    // Note that this is used only by vertex attribute morphing on the WebGL.
    Debug.assert(!this.device.isWebGPU, `VertexFormat#update is not supported on WebGPU and VertexFormat cannot be modified.`);
    this._evaluateHash();
  }

  /**
   * Evaluates hash values for the format allowing fast compare of batching / rendering compatibility.
   *
   * @private
   */
  _evaluateHash() {
    let stringElementBatch;
    const stringElementsBatch = [];
    let stringElementRender;
    const stringElementsRender = [];
    const len = this._elements.length;
    for (let i = 0; i < len; i++) {
      const element = this._elements[i];

      // create string description of each element that is relevant for batching
      stringElementBatch = element.name;
      stringElementBatch += element.dataType;
      stringElementBatch += element.numComponents;
      stringElementBatch += element.normalize;
      stringElementsBatch.push(stringElementBatch);

      // create string description of each element that is relevant for rendering
      stringElementRender = stringElementBatch;
      stringElementRender += element.offset;
      stringElementRender += element.stride;
      stringElementRender += element.size;
      stringElementsRender.push(stringElementRender);
    }

    // sort batching ones alphabetically to make the hash order independent
    stringElementsBatch.sort();
    this.batchingHash = hashCode(stringElementsBatch.join());

    // rendering hash
    this.renderingHashString = stringElementsRender.join('_');
    this.renderingHash = hashCode(this.renderingHashString);
  }
}
VertexFormat._defaultInstancingFormat = null;

export { VertexFormat };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVydGV4LWZvcm1hdC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3BsYXRmb3JtL2dyYXBoaWNzL3ZlcnRleC1mb3JtYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IGhhc2hDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9oYXNoLmpzJztcblxuaW1wb3J0IHsgbWF0aCB9IGZyb20gJy4uLy4uL2NvcmUvbWF0aC9tYXRoLmpzJztcblxuaW1wb3J0IHtcbiAgICBTRU1BTlRJQ19URVhDT09SRDAsIFNFTUFOVElDX1RFWENPT1JEMSwgU0VNQU5USUNfQVRUUjEyLCBTRU1BTlRJQ19BVFRSMTMsIFNFTUFOVElDX0FUVFIxNCwgU0VNQU5USUNfQVRUUjE1LFxuICAgIFNFTUFOVElDX0NPTE9SLCBTRU1BTlRJQ19UQU5HRU5ULCBUWVBFX0ZMT0FUMzIsIHR5cGVkQXJyYXlUeXBlc0J5dGVTaXplLCB2ZXJ0ZXhUeXBlc05hbWVzXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuLyoqXG4gKiBBIHZlcnRleCBmb3JtYXQgaXMgYSBkZXNjcmlwdG9yIHRoYXQgZGVmaW5lcyB0aGUgbGF5b3V0IG9mIHZlcnRleCBkYXRhIGluc2lkZSBhXG4gKiB7QGxpbmsgVmVydGV4QnVmZmVyfS5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdFtdfSBlbGVtZW50cyBUaGUgdmVydGV4IGF0dHJpYnV0ZSBlbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbGVtZW50c1tdLm5hbWUgVGhlIG1lYW5pbmcgb2YgdGhlIHZlcnRleCBlbGVtZW50LiBUaGlzIGlzIHVzZWQgdG8gbGluayB0aGVcbiAqIHZlcnRleCBkYXRhIHRvIGEgc2hhZGVyIGlucHV0LiBDYW4gYmU6XG4gKlxuICogLSB7QGxpbmsgU0VNQU5USUNfUE9TSVRJT059XG4gKiAtIHtAbGluayBTRU1BTlRJQ19OT1JNQUx9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19UQU5HRU5UfVxuICogLSB7QGxpbmsgU0VNQU5USUNfQkxFTkRXRUlHSFR9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19CTEVORElORElDRVN9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19DT0xPUn1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMH1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMX1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMn1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEM31cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENH1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENX1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENn1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEN31cbiAqXG4gKiBJZiB2ZXJ0ZXggZGF0YSBoYXMgYSBtZWFuaW5nIG90aGVyIHRoYXQgb25lIG9mIHRob3NlIGxpc3RlZCBhYm92ZSwgdXNlIHRoZSB1c2VyLWRlZmluZWRcbiAqIHNlbWFudGljczoge0BsaW5rIFNFTUFOVElDX0FUVFIwfSB0byB7QGxpbmsgU0VNQU5USUNfQVRUUjE1fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50c1tdLm51bUNvbXBvbmVudHMgVGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLlxuICogQ2FuIGJlIDEsIDIsIDMgb3IgNC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50c1tdLmRhdGFUeXBlIFRoZSBkYXRhIHR5cGUgb2YgdGhlIGF0dHJpYnV0ZS4gQ2FuIGJlOlxuICpcbiAqIC0ge0BsaW5rIFRZUEVfSU5UOH1cbiAqIC0ge0BsaW5rIFRZUEVfVUlOVDh9XG4gKiAtIHtAbGluayBUWVBFX0lOVDE2fVxuICogLSB7QGxpbmsgVFlQRV9VSU5UMTZ9XG4gKiAtIHtAbGluayBUWVBFX0lOVDMyfVxuICogLSB7QGxpbmsgVFlQRV9VSU5UMzJ9XG4gKiAtIHtAbGluayBUWVBFX0ZMT0FUMzJ9XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVsZW1lbnRzW10ubm9ybWFsaXplIElmIHRydWUsIHZlcnRleCBhdHRyaWJ1dGUgZGF0YSB3aWxsIGJlIG1hcHBlZCBmcm9tIGEgMFxuICogdG8gMjU1IHJhbmdlIGRvd24gdG8gMCB0byAxIHdoZW4gZmVkIHRvIGEgc2hhZGVyLiBJZiBmYWxzZSwgdmVydGV4IGF0dHJpYnV0ZSBkYXRhIGlzIGxlZnRcbiAqIHVuY2hhbmdlZC4gSWYgdGhpcyBwcm9wZXJ0eSBpcyB1bnNwZWNpZmllZCwgZmFsc2UgaXMgYXNzdW1lZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50c1tdLm9mZnNldCBUaGUgbnVtYmVyIG9mIGluaXRpYWwgYnl0ZXMgYXQgdGhlIHN0YXJ0IG9mIGEgdmVydGV4IHRoYXRcbiAqIGFyZSBub3QgcmVsZXZhbnQgdG8gdGhpcyBhdHRyaWJ1dGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudHNbXS5zdHJpZGUgVGhlIG51bWJlciBvZiB0b3RhbCBieXRlcyB0aGF0IGFyZSBiZXR3ZWVuIHRoZSBzdGFydCBvZiBvbmVcbiAqIHZlcnRleCwgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50c1tdLnNpemUgVGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZSBpbiBieXRlcy5cbiAqL1xuY2xhc3MgVmVydGV4Rm9ybWF0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgVmVydGV4Rm9ybWF0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4vZ3JhcGhpY3MtZGV2aWNlLmpzJykuR3JhcGhpY3NEZXZpY2V9IGdyYXBoaWNzRGV2aWNlIC0gVGhlIGdyYXBoaWNzIGRldmljZVxuICAgICAqIHVzZWQgdG8gbWFuYWdlIHRoaXMgdmVydGV4IGZvcm1hdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBkZXNjcmlwdGlvbiAtIEFuIGFycmF5IG9mIHZlcnRleCBhdHRyaWJ1dGUgZGVzY3JpcHRpb25zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjcmlwdGlvbltdLnNlbWFudGljIC0gVGhlIG1lYW5pbmcgb2YgdGhlIHZlcnRleCBlbGVtZW50LiBUaGlzIGlzIHVzZWQgdG9cbiAgICAgKiBsaW5rIHRoZSB2ZXJ0ZXggZGF0YSB0byBhIHNoYWRlciBpbnB1dC4gQ2FuIGJlOlxuICAgICAqXG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfUE9TSVRJT059XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfTk9STUFMfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RBTkdFTlR9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfQkxFTkRXRUlHSFR9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfQkxFTkRJTkRJQ0VTfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX0NPTE9SfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMH1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDF9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEVYQ09PUkQyfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEM31cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDR9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEVYQ09PUkQ1fVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENn1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDd9XG4gICAgICpcbiAgICAgKiBJZiB2ZXJ0ZXggZGF0YSBoYXMgYSBtZWFuaW5nIG90aGVyIHRoYXQgb25lIG9mIHRob3NlIGxpc3RlZCBhYm92ZSwgdXNlIHRoZSB1c2VyLWRlZmluZWRcbiAgICAgKiBzZW1hbnRpY3M6IHtAbGluayBTRU1BTlRJQ19BVFRSMH0gdG8ge0BsaW5rIFNFTUFOVElDX0FUVFIxNX0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc2NyaXB0aW9uW10uY29tcG9uZW50cyAtIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZS5cbiAgICAgKiBDYW4gYmUgMSwgMiwgMyBvciA0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXNjcmlwdGlvbltdLnR5cGUgLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUuIENhbiBiZTpcbiAgICAgKlxuICAgICAqIC0ge0BsaW5rIFRZUEVfSU5UOH1cbiAgICAgKiAtIHtAbGluayBUWVBFX1VJTlQ4fVxuICAgICAqIC0ge0BsaW5rIFRZUEVfSU5UMTZ9XG4gICAgICogLSB7QGxpbmsgVFlQRV9VSU5UMTZ9XG4gICAgICogLSB7QGxpbmsgVFlQRV9JTlQzMn1cbiAgICAgKiAtIHtAbGluayBUWVBFX1VJTlQzMn1cbiAgICAgKiAtIHtAbGluayBUWVBFX0ZMT0FUMzJ9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXNjcmlwdGlvbltdLm5vcm1hbGl6ZV0gLSBJZiB0cnVlLCB2ZXJ0ZXggYXR0cmlidXRlIGRhdGEgd2lsbCBiZSBtYXBwZWRcbiAgICAgKiBmcm9tIGEgMCB0byAyNTUgcmFuZ2UgZG93biB0byAwIHRvIDEgd2hlbiBmZWQgdG8gYSBzaGFkZXIuIElmIGZhbHNlLCB2ZXJ0ZXggYXR0cmlidXRlIGRhdGFcbiAgICAgKiBpcyBsZWZ0IHVuY2hhbmdlZC4gSWYgdGhpcyBwcm9wZXJ0eSBpcyB1bnNwZWNpZmllZCwgZmFsc2UgaXMgYXNzdW1lZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZlcnRleENvdW50XSAtIFdoZW4gc3BlY2lmaWVkLCB2ZXJ0ZXggZm9ybWF0IHdpbGwgYmUgc2V0IHVwIGZvclxuICAgICAqIG5vbi1pbnRlcmxlYXZlZCBmb3JtYXQgd2l0aCBhIHNwZWNpZmllZCBudW1iZXIgb2YgdmVydGljZXMuIChleGFtcGxlOiBQUFBQTk5OTkNDQ0MpLCB3aGVyZVxuICAgICAqIGFycmF5cyBvZiBpbmRpdmlkdWFsIGF0dHJpYnV0ZXMgd2lsbCBiZSBzdG9yZWQgb25lIHJpZ2h0IGFmdGVyIHRoZSBvdGhlciAoc3ViamVjdCB0b1xuICAgICAqIGFsaWdubWVudCByZXF1aXJlbWVudHMpLiBOb3RlIHRoYXQgaW4gdGhpcyBjYXNlLCB0aGUgZm9ybWF0IGRlcGVuZHMgb24gdGhlIG51bWJlciBvZlxuICAgICAqIHZlcnRpY2VzLCBhbmQgbmVlZHMgdG8gY2hhbmdlIHdoZW4gdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBjaGFuZ2VzLiBXaGVuIG5vdCBzcGVjaWZpZWQsXG4gICAgICogdmVydGV4IGZvcm1hdCB3aWxsIGJlIGludGVybGVhdmVkLiAoZXhhbXBsZTogUE5DUE5DUE5DUE5DKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNwZWNpZnkgMy1jb21wb25lbnQgcG9zaXRpb25zICh4LCB5LCB6KVxuICAgICAqIGNvbnN0IHZlcnRleEZvcm1hdCA9IG5ldyBwYy5WZXJ0ZXhGb3JtYXQoZ3JhcGhpY3NEZXZpY2UsIFtcbiAgICAgKiAgICAgeyBzZW1hbnRpYzogcGMuU0VNQU5USUNfUE9TSVRJT04sIGNvbXBvbmVudHM6IDMsIHR5cGU6IHBjLlRZUEVfRkxPQVQzMiB9XG4gICAgICogXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTcGVjaWZ5IDItY29tcG9uZW50IHBvc2l0aW9ucyAoeCwgeSksIGEgdGV4dHVyZSBjb29yZGluYXRlICh1LCB2KSBhbmQgYSB2ZXJ0ZXggY29sb3IgKHIsIGcsIGIsIGEpXG4gICAgICogY29uc3QgdmVydGV4Rm9ybWF0ID0gbmV3IHBjLlZlcnRleEZvcm1hdChncmFwaGljc0RldmljZSwgW1xuICAgICAqICAgICB7IHNlbWFudGljOiBwYy5TRU1BTlRJQ19QT1NJVElPTiwgY29tcG9uZW50czogMiwgdHlwZTogcGMuVFlQRV9GTE9BVDMyIH0sXG4gICAgICogICAgIHsgc2VtYW50aWM6IHBjLlNFTUFOVElDX1RFWENPT1JEMCwgY29tcG9uZW50czogMiwgdHlwZTogcGMuVFlQRV9GTE9BVDMyIH0sXG4gICAgICogICAgIHsgc2VtYW50aWM6IHBjLlNFTUFOVElDX0NPTE9SLCBjb21wb25lbnRzOiA0LCB0eXBlOiBwYy5UWVBFX1VJTlQ4LCBub3JtYWxpemU6IHRydWUgfVxuICAgICAqIF0pO1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdyYXBoaWNzRGV2aWNlLCBkZXNjcmlwdGlvbiwgdmVydGV4Q291bnQpIHtcbiAgICAgICAgdGhpcy5kZXZpY2UgPSBncmFwaGljc0RldmljZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5oYXNVdjAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNVdjEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb2xvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1RhbmdlbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmVydGljZXNCeXRlU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgPSB2ZXJ0ZXhDb3VudDtcbiAgICAgICAgdGhpcy5pbnRlcmxlYXZlZCA9IHZlcnRleENvdW50ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gdHJ1ZSBpZiB0aGUgdmVydGV4IGZvcm1hdCByZXByZXNlbnRzIGFuIGluc3RhbmNpbmcgdmVydGV4IGJ1ZmZlclxuICAgICAgICB0aGlzLmluc3RhbmNpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdG90YWwgc2l6ZSBvZiB0aGUgdmVydGV4XG4gICAgICAgIHRoaXMuc2l6ZSA9IGRlc2NyaXB0aW9uLnJlZHVjZSgodG90YWwsIGRlc2MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCArIE1hdGguY2VpbChkZXNjLmNvbXBvbmVudHMgKiB0eXBlZEFycmF5VHlwZXNCeXRlU2l6ZVtkZXNjLnR5cGVdIC8gNCkgKiA0O1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBsZXQgb2Zmc2V0ID0gMCwgZWxlbWVudFNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkZXNjcmlwdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudERlc2MgPSBkZXNjcmlwdGlvbltpXTtcblxuICAgICAgICAgICAgZWxlbWVudFNpemUgPSBlbGVtZW50RGVzYy5jb21wb25lbnRzICogdHlwZWRBcnJheVR5cGVzQnl0ZVNpemVbZWxlbWVudERlc2MudHlwZV07XG5cbiAgICAgICAgICAgIC8vIFdlYkdQVSBoYXMgbGltaXRlZCBlbGVtZW50IHNpemUgc3VwcG9ydCAoZm9yIGV4YW1wbGUgdWludDE2eDMgaXMgbm90IHN1cHBvcnRlZClcbiAgICAgICAgICAgIERlYnVnLmFzc2VydCghZ3JhcGhpY3NEZXZpY2UuaXNXZWJHUFUgfHwgWzIsIDQsIDgsIDEyLCAxNl0uaW5jbHVkZXMoZWxlbWVudFNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGBXZWJHUFUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgZm9ybWF0IG9mIHZlcnRleCBlbGVtZW50ICR7ZWxlbWVudERlc2Muc2VtYW50aWN9IDogJHt2ZXJ0ZXhUeXBlc05hbWVzW2VsZW1lbnREZXNjLnR5cGVdfSB4ICR7ZWxlbWVudERlc2MuY29tcG9uZW50c31gKTtcblxuICAgICAgICAgICAgLy8gYWxpZ24gdXAgdGhlIG9mZnNldCB0byBlbGVtZW50U2l6ZSAod2hlbiB2ZXJ0ZXhDb3VudCBpcyBzcGVjaWZpZWQgb25seSAtIGNhc2Ugb2Ygbm9uLWludGVybGVhdmVkIGZvcm1hdClcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhDb3VudCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1hdGgucm91bmRVcChvZmZzZXQsIGVsZW1lbnRTaXplKTtcblxuICAgICAgICAgICAgICAgIC8vIG5vbi1pbnRlcmxlYXZlZCBmb3JtYXQgd2l0aCBlbGVtZW50U2l6ZSBub3QgbXVsdGlwbGUgb2YgNCBtaWdodCBiZSBzbG93ZXIgb24gc29tZSBwbGF0Zm9ybXMgLSBwYWRkaW5nIGlzIHJlY29tbWVuZGVkIHRvIGFsaWduIGl0cyBzaXplXG4gICAgICAgICAgICAgICAgLy8gZXhhbXBsZTogdXNlIDQgeCBUWVBFX1VJTlQ4IGluc3RlYWQgb2YgMyB4IFRZUEVfVUlOVDhcbiAgICAgICAgICAgICAgICBEZWJ1Zy5hc3NlcnQoKGVsZW1lbnRTaXplICUgNCkgPT09IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBOb24taW50ZXJsZWF2ZWQgdmVydGV4IGZvcm1hdCB3aXRoIGVsZW1lbnQgc2l6ZSBub3QgbXVsdGlwbGUgb2YgNCBjYW4gaGF2ZSBwZXJmb3JtYW5jZSBpbXBhY3Qgb24gc29tZSBwbGF0Zm9ybXMuIEVsZW1lbnQgc2l6ZTogJHtlbGVtZW50U2l6ZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50RGVzYy5zZW1hbnRpYyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6ICh2ZXJ0ZXhDb3VudCA/IG9mZnNldCA6IChlbGVtZW50RGVzYy5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykgPyBlbGVtZW50RGVzYy5vZmZzZXQgOiBvZmZzZXQpKSxcbiAgICAgICAgICAgICAgICBzdHJpZGU6ICh2ZXJ0ZXhDb3VudCA/IGVsZW1lbnRTaXplIDogKGVsZW1lbnREZXNjLmhhc093blByb3BlcnR5KCdzdHJpZGUnKSA/IGVsZW1lbnREZXNjLnN0cmlkZSA6IHRoaXMuc2l6ZSkpLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBlbGVtZW50RGVzYy50eXBlLFxuICAgICAgICAgICAgICAgIG51bUNvbXBvbmVudHM6IGVsZW1lbnREZXNjLmNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplOiBlbGVtZW50RGVzYy5ub3JtYWxpemUgPz8gZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogZWxlbWVudFNpemVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAodmVydGV4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZWxlbWVudFNpemUgKiB2ZXJ0ZXhDb3VudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IE1hdGguY2VpbChlbGVtZW50U2l6ZSAvIDQpICogNDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnREZXNjLnNlbWFudGljID09PSBTRU1BTlRJQ19URVhDT09SRDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1V2MCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnREZXNjLnNlbWFudGljID09PSBTRU1BTlRJQ19URVhDT09SRDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1V2MSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnREZXNjLnNlbWFudGljID09PSBTRU1BTlRJQ19DT0xPUikge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQ29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50RGVzYy5zZW1hbnRpYyA9PT0gU0VNQU5USUNfVEFOR0VOVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzVGFuZ2VudHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnRleENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzQnl0ZVNpemUgPSBvZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmFsdWF0ZUhhc2goKTtcbiAgICB9XG5cbiAgICBnZXQgZWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VmVydGV4Rm9ybWF0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9kZWZhdWx0SW5zdGFuY2luZ0Zvcm1hdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIFZlcnRleEZvcm1hdH0gdXNlZCB0byBzdG9yZSBtYXRyaWNlcyBvZiB0eXBlIHtAbGluayBNYXQ0fSBmb3IgaGFyZHdhcmUgaW5zdGFuY2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuL2dyYXBoaWNzLWRldmljZS5qcycpLkdyYXBoaWNzRGV2aWNlfSBncmFwaGljc0RldmljZSAtIFRoZSBncmFwaGljcyBkZXZpY2VcbiAgICAgKiB1c2VkIHRvIGNyZWF0ZSB0aGlzIHZlcnRleCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VmVydGV4Rm9ybWF0fSBUaGUgZGVmYXVsdCBpbnN0YW5jaW5nIHZlcnRleCBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGdldERlZmF1bHRJbnN0YW5jaW5nRm9ybWF0KGdyYXBoaWNzRGV2aWNlKSB7XG5cbiAgICAgICAgaWYgKCFWZXJ0ZXhGb3JtYXQuX2RlZmF1bHRJbnN0YW5jaW5nRm9ybWF0KSB7XG4gICAgICAgICAgICBWZXJ0ZXhGb3JtYXQuX2RlZmF1bHRJbnN0YW5jaW5nRm9ybWF0ID0gbmV3IFZlcnRleEZvcm1hdChncmFwaGljc0RldmljZSwgW1xuICAgICAgICAgICAgICAgIHsgc2VtYW50aWM6IFNFTUFOVElDX0FUVFIxMiwgY29tcG9uZW50czogNCwgdHlwZTogVFlQRV9GTE9BVDMyIH0sXG4gICAgICAgICAgICAgICAgeyBzZW1hbnRpYzogU0VNQU5USUNfQVRUUjEzLCBjb21wb25lbnRzOiA0LCB0eXBlOiBUWVBFX0ZMT0FUMzIgfSxcbiAgICAgICAgICAgICAgICB7IHNlbWFudGljOiBTRU1BTlRJQ19BVFRSMTQsIGNvbXBvbmVudHM6IDQsIHR5cGU6IFRZUEVfRkxPQVQzMiB9LFxuICAgICAgICAgICAgICAgIHsgc2VtYW50aWM6IFNFTUFOVElDX0FUVFIxNSwgY29tcG9uZW50czogNCwgdHlwZTogVFlQRV9GTE9BVDMyIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFZlcnRleEZvcm1hdC5fZGVmYXVsdEluc3RhbmNpbmdGb3JtYXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhbnkgY2hhbmdlcyBtYWRlIHRvIHRoZSBWZXJ0ZXhGb3JtYXQncyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIHVzZWQgb25seSBieSB2ZXJ0ZXggYXR0cmlidXRlIG1vcnBoaW5nIG9uIHRoZSBXZWJHTC5cbiAgICAgICAgRGVidWcuYXNzZXJ0KCF0aGlzLmRldmljZS5pc1dlYkdQVSwgYFZlcnRleEZvcm1hdCN1cGRhdGUgaXMgbm90IHN1cHBvcnRlZCBvbiBXZWJHUFUgYW5kIFZlcnRleEZvcm1hdCBjYW5ub3QgYmUgbW9kaWZpZWQuYCk7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRlSGFzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBoYXNoIHZhbHVlcyBmb3IgdGhlIGZvcm1hdCBhbGxvd2luZyBmYXN0IGNvbXBhcmUgb2YgYmF0Y2hpbmcgLyByZW5kZXJpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V2YWx1YXRlSGFzaCgpIHtcbiAgICAgICAgbGV0IHN0cmluZ0VsZW1lbnRCYXRjaDtcbiAgICAgICAgY29uc3Qgc3RyaW5nRWxlbWVudHNCYXRjaCA9IFtdO1xuICAgICAgICBsZXQgc3RyaW5nRWxlbWVudFJlbmRlcjtcbiAgICAgICAgY29uc3Qgc3RyaW5nRWxlbWVudHNSZW5kZXIgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudHNbaV07XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzdHJpbmcgZGVzY3JpcHRpb24gb2YgZWFjaCBlbGVtZW50IHRoYXQgaXMgcmVsZXZhbnQgZm9yIGJhdGNoaW5nXG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50QmF0Y2ggPSBlbGVtZW50Lm5hbWU7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50QmF0Y2ggKz0gZWxlbWVudC5kYXRhVHlwZTtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRCYXRjaCArPSBlbGVtZW50Lm51bUNvbXBvbmVudHM7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50QmF0Y2ggKz0gZWxlbWVudC5ub3JtYWxpemU7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50c0JhdGNoLnB1c2goc3RyaW5nRWxlbWVudEJhdGNoKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHN0cmluZyBkZXNjcmlwdGlvbiBvZiBlYWNoIGVsZW1lbnQgdGhhdCBpcyByZWxldmFudCBmb3IgcmVuZGVyaW5nXG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50UmVuZGVyID0gc3RyaW5nRWxlbWVudEJhdGNoO1xuICAgICAgICAgICAgc3RyaW5nRWxlbWVudFJlbmRlciArPSBlbGVtZW50Lm9mZnNldDtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRSZW5kZXIgKz0gZWxlbWVudC5zdHJpZGU7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50UmVuZGVyICs9IGVsZW1lbnQuc2l6ZTtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRzUmVuZGVyLnB1c2goc3RyaW5nRWxlbWVudFJlbmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb3J0IGJhdGNoaW5nIG9uZXMgYWxwaGFiZXRpY2FsbHkgdG8gbWFrZSB0aGUgaGFzaCBvcmRlciBpbmRlcGVuZGVudFxuICAgICAgICBzdHJpbmdFbGVtZW50c0JhdGNoLnNvcnQoKTtcbiAgICAgICAgdGhpcy5iYXRjaGluZ0hhc2ggPSBoYXNoQ29kZShzdHJpbmdFbGVtZW50c0JhdGNoLmpvaW4oKSk7XG5cbiAgICAgICAgLy8gcmVuZGVyaW5nIGhhc2hcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdIYXNoU3RyaW5nID0gc3RyaW5nRWxlbWVudHNSZW5kZXIuam9pbignXycpO1xuICAgICAgICB0aGlzLnJlbmRlcmluZ0hhc2ggPSBoYXNoQ29kZSh0aGlzLnJlbmRlcmluZ0hhc2hTdHJpbmcpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVmVydGV4Rm9ybWF0IH07XG4iXSwibmFtZXMiOlsiVmVydGV4Rm9ybWF0IiwiY29uc3RydWN0b3IiLCJncmFwaGljc0RldmljZSIsImRlc2NyaXB0aW9uIiwidmVydGV4Q291bnQiLCJkZXZpY2UiLCJfZWxlbWVudHMiLCJoYXNVdjAiLCJoYXNVdjEiLCJoYXNDb2xvciIsImhhc1RhbmdlbnRzIiwidmVydGljZXNCeXRlU2l6ZSIsImludGVybGVhdmVkIiwidW5kZWZpbmVkIiwiaW5zdGFuY2luZyIsInNpemUiLCJyZWR1Y2UiLCJ0b3RhbCIsImRlc2MiLCJNYXRoIiwiY2VpbCIsImNvbXBvbmVudHMiLCJ0eXBlZEFycmF5VHlwZXNCeXRlU2l6ZSIsInR5cGUiLCJvZmZzZXQiLCJlbGVtZW50U2l6ZSIsImkiLCJsZW4iLCJsZW5ndGgiLCJfZWxlbWVudERlc2Mkbm9ybWFsaXoiLCJlbGVtZW50RGVzYyIsIkRlYnVnIiwiYXNzZXJ0IiwiaXNXZWJHUFUiLCJpbmNsdWRlcyIsInNlbWFudGljIiwidmVydGV4VHlwZXNOYW1lcyIsIm1hdGgiLCJyb3VuZFVwIiwiZWxlbWVudCIsIm5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsInN0cmlkZSIsImRhdGFUeXBlIiwibnVtQ29tcG9uZW50cyIsIm5vcm1hbGl6ZSIsInB1c2giLCJTRU1BTlRJQ19URVhDT09SRDAiLCJTRU1BTlRJQ19URVhDT09SRDEiLCJTRU1BTlRJQ19DT0xPUiIsIlNFTUFOVElDX1RBTkdFTlQiLCJfZXZhbHVhdGVIYXNoIiwiZWxlbWVudHMiLCJnZXREZWZhdWx0SW5zdGFuY2luZ0Zvcm1hdCIsIl9kZWZhdWx0SW5zdGFuY2luZ0Zvcm1hdCIsIlNFTUFOVElDX0FUVFIxMiIsIlRZUEVfRkxPQVQzMiIsIlNFTUFOVElDX0FUVFIxMyIsIlNFTUFOVElDX0FUVFIxNCIsIlNFTUFOVElDX0FUVFIxNSIsInVwZGF0ZSIsInN0cmluZ0VsZW1lbnRCYXRjaCIsInN0cmluZ0VsZW1lbnRzQmF0Y2giLCJzdHJpbmdFbGVtZW50UmVuZGVyIiwic3RyaW5nRWxlbWVudHNSZW5kZXIiLCJzb3J0IiwiYmF0Y2hpbmdIYXNoIiwiaGFzaENvZGUiLCJqb2luIiwicmVuZGVyaW5nSGFzaFN0cmluZyIsInJlbmRlcmluZ0hhc2giXSwibWFwcGluZ3MiOiI7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsWUFBWSxDQUFDO0FBQ2Y7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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
