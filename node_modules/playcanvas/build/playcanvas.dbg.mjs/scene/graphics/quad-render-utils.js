import { Debug, DebugHelper } from '../../core/debug.js';
import { Vec4 } from '../../core/math/vec4.js';
import { CULLFACE_NONE } from '../../platform/graphics/constants.js';
import { DebugGraphics } from '../../platform/graphics/debug-graphics.js';
import { DepthState } from '../../platform/graphics/depth-state.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { QuadRender } from './quad-render.js';

const _tempRect = new Vec4();

/**
 * Draws a screen-space quad using a specific shader.
 *
 * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} device - The graphics device used to draw
 * the quad.
 * @param {import('../../platform/graphics/render-target.js').RenderTarget|undefined} target - The destination render
 * target. If undefined, target is the frame buffer.
 * @param {import('../../platform/graphics/shader.js').Shader} shader - The shader used for rendering the quad. Vertex
 * shader should contain `attribute vec2 vertex_position`.
 * @param {import('../../core/math/vec4.js').Vec4} [rect] - The viewport rectangle of the quad, in
 * pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
 * @param {import('../../core/math/vec4.js').Vec4} [scissorRect] - The scissor rectangle of the
 * quad, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
 */
function drawQuadWithShader(device, target, shader, rect, scissorRect) {
  // a valid target or a null target (framebuffer) are supported
  Debug.assert(target !== undefined);
  const useBlend = arguments[5];
  Debug.call(() => {
    if (useBlend !== undefined) {
      Debug.warnOnce('pc.drawQuadWithShader no longer accepts useBlend parameter, and blending state needs to be set up using GraphicsDevice.setBlendState.');
    }
  });
  DebugGraphics.pushGpuMarker(device, "drawQuadWithShader");
  device.setCullMode(CULLFACE_NONE);
  device.setDepthState(DepthState.NODEPTH);
  device.setStencilState(null, null);

  // prepare the quad for rendering with the shader
  const quad = new QuadRender(shader);

  // by default render to the whole render target
  if (!rect) {
    rect = _tempRect;
    rect.x = 0;
    rect.y = 0;
    rect.z = target ? target.width : device.width;
    rect.w = target ? target.height : device.height;
  }

  // prepare a render pass to render the quad to the render target
  const renderPass = new RenderPass(device, () => {
    quad.render(rect, scissorRect);
  });
  DebugHelper.setName(renderPass, `RenderPass-drawQuadWithShader${target ? `-${target.name}` : 'Framebuffer'}`);
  renderPass.init(target);
  renderPass.colorOps.clear = false;
  renderPass.depthStencilOps.clearDepth = false;

  // TODO: This is a workaround for the case where post-effects are used together with multi-sampled framebuffer. Last post-effect
  // renders into multi-sampled framebuffer (render pass A), which is typically followed by further rendering to this framebuffer,
  // in a separate render pass B (e.g. rendering UI). Those two render passes need to be merged into one, as they both render into
  // the same framebuffer. The workaround here is to store multi-sampled color buffer, instead of only resolving it, which is wasted
  // memory bandwidth. Without this we end up with a black result (or just UI), as multi-sampled color buffer is never written to.
  if (device.isWebGPU && target === null) {
    var _target$samples;
    const samples = (_target$samples = target == null ? void 0 : target.samples) != null ? _target$samples : device.samples;
    if (samples > 1) renderPass.colorOps.store = true;
  }
  renderPass.render();
  quad.destroy();
  DebugGraphics.popGpuMarker(device);
}

/**
 * Draws a texture in screen-space. Mostly used by post-effects.
 *
 * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} device - The graphics device used to draw
 * the texture.
 * @param {import('../../platform/graphics/texture.js').Texture} texture - The source texture to be drawn. Accessible as
 * `uniform sampler2D * source` in shader.
 * @param {import('../../platform/graphics/render-target.js').RenderTarget} [target] - The destination render target.
 * Defaults to the frame buffer.
 * @param {import('../../platform/graphics/shader.js').Shader} [shader] - The shader used for rendering the texture.
 * Defaults to {@link GraphicsDevice#getCopyShader}.
 * @param {import('../../core/math/vec4.js').Vec4} [rect] - The viewport rectangle to use for the
 * texture, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
 * @param {import('../../core/math/vec4.js').Vec4} [scissorRect] - The scissor rectangle to use for
 * the texture, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
 */
function drawTexture(device, texture, target, shader, rect, scissorRect) {
  Debug.assert(!device.isWebGPU, 'pc.drawTexture is not currently supported on WebGPU platform.');
  const useBlend = arguments[6];
  Debug.call(() => {
    if (useBlend !== undefined) {
      Debug.warnOnce('pc.drawTexture no longer accepts useBlend parameter, and blending state needs to be set up using GraphicsDevice.setBlendState.');
    }
  });
  shader = shader || device.getCopyShader();
  device.constantTexSource.setValue(texture);
  drawQuadWithShader(device, target, shader, rect, scissorRect);
}

export { drawQuadWithShader, drawTexture };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVhZC1yZW5kZXItdXRpbHMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zY2VuZS9ncmFwaGljcy9xdWFkLXJlbmRlci11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJ1ZywgRGVidWdIZWxwZXIgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IFZlYzQgfSBmcm9tICcuLi8uLi9jb3JlL21hdGgvdmVjNC5qcyc7XG5cbmltcG9ydCB7IENVTExGQUNFX05PTkUgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgRGVidWdHcmFwaGljcyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL2RlYnVnLWdyYXBoaWNzLmpzJztcbmltcG9ydCB7IERlcHRoU3RhdGUgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9kZXB0aC1zdGF0ZS5qcyc7XG5pbXBvcnQgeyBSZW5kZXJQYXNzIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvcmVuZGVyLXBhc3MuanMnO1xuaW1wb3J0IHsgUXVhZFJlbmRlciB9IGZyb20gJy4vcXVhZC1yZW5kZXIuanMnO1xuXG5jb25zdCBfdGVtcFJlY3QgPSBuZXcgVmVjNCgpO1xuXG4vKipcbiAqIERyYXdzIGEgc2NyZWVuLXNwYWNlIHF1YWQgdXNpbmcgYSBzcGVjaWZpYyBzaGFkZXIuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL2dyYXBoaWNzLWRldmljZS5qcycpLkdyYXBoaWNzRGV2aWNlfSBkZXZpY2UgLSBUaGUgZ3JhcGhpY3MgZGV2aWNlIHVzZWQgdG8gZHJhd1xuICogdGhlIHF1YWQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvcmVuZGVyLXRhcmdldC5qcycpLlJlbmRlclRhcmdldHx1bmRlZmluZWR9IHRhcmdldCAtIFRoZSBkZXN0aW5hdGlvbiByZW5kZXJcbiAqIHRhcmdldC4gSWYgdW5kZWZpbmVkLCB0YXJnZXQgaXMgdGhlIGZyYW1lIGJ1ZmZlci5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9zaGFkZXIuanMnKS5TaGFkZXJ9IHNoYWRlciAtIFRoZSBzaGFkZXIgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBxdWFkLiBWZXJ0ZXhcbiAqIHNoYWRlciBzaG91bGQgY29udGFpbiBgYXR0cmlidXRlIHZlYzIgdmVydGV4X3Bvc2l0aW9uYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9jb3JlL21hdGgvdmVjNC5qcycpLlZlYzR9IFtyZWN0XSAtIFRoZSB2aWV3cG9ydCByZWN0YW5nbGUgb2YgdGhlIHF1YWQsIGluXG4gKiBwaXhlbHMuIERlZmF1bHRzIHRvIGZ1bGxzY3JlZW4gKGAwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHRgKS5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9jb3JlL21hdGgvdmVjNC5qcycpLlZlYzR9IFtzY2lzc29yUmVjdF0gLSBUaGUgc2Npc3NvciByZWN0YW5nbGUgb2YgdGhlXG4gKiBxdWFkLCBpbiBwaXhlbHMuIERlZmF1bHRzIHRvIGZ1bGxzY3JlZW4gKGAwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHRgKS5cbiAqL1xuZnVuY3Rpb24gZHJhd1F1YWRXaXRoU2hhZGVyKGRldmljZSwgdGFyZ2V0LCBzaGFkZXIsIHJlY3QsIHNjaXNzb3JSZWN0KSB7XG5cbiAgICAvLyBhIHZhbGlkIHRhcmdldCBvciBhIG51bGwgdGFyZ2V0IChmcmFtZWJ1ZmZlcikgYXJlIHN1cHBvcnRlZFxuICAgIERlYnVnLmFzc2VydCh0YXJnZXQgIT09IHVuZGVmaW5lZCk7XG5cbiAgICBjb25zdCB1c2VCbGVuZCA9IGFyZ3VtZW50c1s1XTtcbiAgICBEZWJ1Zy5jYWxsKCgpID0+IHtcbiAgICAgICAgaWYgKHVzZUJsZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIERlYnVnLndhcm5PbmNlKCdwYy5kcmF3UXVhZFdpdGhTaGFkZXIgbm8gbG9uZ2VyIGFjY2VwdHMgdXNlQmxlbmQgcGFyYW1ldGVyLCBhbmQgYmxlbmRpbmcgc3RhdGUgbmVlZHMgdG8gYmUgc2V0IHVwIHVzaW5nIEdyYXBoaWNzRGV2aWNlLnNldEJsZW5kU3RhdGUuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIERlYnVnR3JhcGhpY3MucHVzaEdwdU1hcmtlcihkZXZpY2UsIFwiZHJhd1F1YWRXaXRoU2hhZGVyXCIpO1xuXG4gICAgZGV2aWNlLnNldEN1bGxNb2RlKENVTExGQUNFX05PTkUpO1xuICAgIGRldmljZS5zZXREZXB0aFN0YXRlKERlcHRoU3RhdGUuTk9ERVBUSCk7XG4gICAgZGV2aWNlLnNldFN0ZW5jaWxTdGF0ZShudWxsLCBudWxsKTtcblxuICAgIC8vIHByZXBhcmUgdGhlIHF1YWQgZm9yIHJlbmRlcmluZyB3aXRoIHRoZSBzaGFkZXJcbiAgICBjb25zdCBxdWFkID0gbmV3IFF1YWRSZW5kZXIoc2hhZGVyKTtcblxuICAgIC8vIGJ5IGRlZmF1bHQgcmVuZGVyIHRvIHRoZSB3aG9sZSByZW5kZXIgdGFyZ2V0XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJlY3QgPSBfdGVtcFJlY3Q7XG4gICAgICAgIHJlY3QueCA9IDA7XG4gICAgICAgIHJlY3QueSA9IDA7XG4gICAgICAgIHJlY3QueiA9IHRhcmdldCA/IHRhcmdldC53aWR0aCA6IGRldmljZS53aWR0aDtcbiAgICAgICAgcmVjdC53ID0gdGFyZ2V0ID8gdGFyZ2V0LmhlaWdodCA6IGRldmljZS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBhIHJlbmRlciBwYXNzIHRvIHJlbmRlciB0aGUgcXVhZCB0byB0aGUgcmVuZGVyIHRhcmdldFxuICAgIGNvbnN0IHJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhkZXZpY2UsICgpID0+IHtcbiAgICAgICAgcXVhZC5yZW5kZXIocmVjdCwgc2Npc3NvclJlY3QpO1xuICAgIH0pO1xuICAgIERlYnVnSGVscGVyLnNldE5hbWUocmVuZGVyUGFzcywgYFJlbmRlclBhc3MtZHJhd1F1YWRXaXRoU2hhZGVyJHt0YXJnZXQgPyBgLSR7dGFyZ2V0Lm5hbWV9YCA6ICdGcmFtZWJ1ZmZlcid9YCk7XG4gICAgcmVuZGVyUGFzcy5pbml0KHRhcmdldCk7XG4gICAgcmVuZGVyUGFzcy5jb2xvck9wcy5jbGVhciA9IGZhbHNlO1xuICAgIHJlbmRlclBhc3MuZGVwdGhTdGVuY2lsT3BzLmNsZWFyRGVwdGggPSBmYWxzZTtcblxuICAgIC8vIFRPRE86IFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgY2FzZSB3aGVyZSBwb3N0LWVmZmVjdHMgYXJlIHVzZWQgdG9nZXRoZXIgd2l0aCBtdWx0aS1zYW1wbGVkIGZyYW1lYnVmZmVyLiBMYXN0IHBvc3QtZWZmZWN0XG4gICAgLy8gcmVuZGVycyBpbnRvIG11bHRpLXNhbXBsZWQgZnJhbWVidWZmZXIgKHJlbmRlciBwYXNzIEEpLCB3aGljaCBpcyB0eXBpY2FsbHkgZm9sbG93ZWQgYnkgZnVydGhlciByZW5kZXJpbmcgdG8gdGhpcyBmcmFtZWJ1ZmZlcixcbiAgICAvLyBpbiBhIHNlcGFyYXRlIHJlbmRlciBwYXNzIEIgKGUuZy4gcmVuZGVyaW5nIFVJKS4gVGhvc2UgdHdvIHJlbmRlciBwYXNzZXMgbmVlZCB0byBiZSBtZXJnZWQgaW50byBvbmUsIGFzIHRoZXkgYm90aCByZW5kZXIgaW50b1xuICAgIC8vIHRoZSBzYW1lIGZyYW1lYnVmZmVyLiBUaGUgd29ya2Fyb3VuZCBoZXJlIGlzIHRvIHN0b3JlIG11bHRpLXNhbXBsZWQgY29sb3IgYnVmZmVyLCBpbnN0ZWFkIG9mIG9ubHkgcmVzb2x2aW5nIGl0LCB3aGljaCBpcyB3YXN0ZWRcbiAgICAvLyBtZW1vcnkgYmFuZHdpZHRoLiBXaXRob3V0IHRoaXMgd2UgZW5kIHVwIHdpdGggYSBibGFjayByZXN1bHQgKG9yIGp1c3QgVUkpLCBhcyBtdWx0aS1zYW1wbGVkIGNvbG9yIGJ1ZmZlciBpcyBuZXZlciB3cml0dGVuIHRvLlxuICAgIGlmIChkZXZpY2UuaXNXZWJHUFUgJiYgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSB0YXJnZXQ/LnNhbXBsZXMgPz8gZGV2aWNlLnNhbXBsZXM7XG4gICAgICAgIGlmIChzYW1wbGVzID4gMSlcbiAgICAgICAgICAgIHJlbmRlclBhc3MuY29sb3JPcHMuc3RvcmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlbmRlclBhc3MucmVuZGVyKCk7XG4gICAgcXVhZC5kZXN0cm95KCk7XG5cbiAgICBEZWJ1Z0dyYXBoaWNzLnBvcEdwdU1hcmtlcihkZXZpY2UpO1xufVxuXG4vKipcbiAqIERyYXdzIGEgdGV4dHVyZSBpbiBzY3JlZW4tc3BhY2UuIE1vc3RseSB1c2VkIGJ5IHBvc3QtZWZmZWN0cy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvZ3JhcGhpY3MtZGV2aWNlLmpzJykuR3JhcGhpY3NEZXZpY2V9IGRldmljZSAtIFRoZSBncmFwaGljcyBkZXZpY2UgdXNlZCB0byBkcmF3XG4gKiB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy90ZXh0dXJlLmpzJykuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBzb3VyY2UgdGV4dHVyZSB0byBiZSBkcmF3bi4gQWNjZXNzaWJsZSBhc1xuICogYHVuaWZvcm0gc2FtcGxlcjJEICogc291cmNlYCBpbiBzaGFkZXIuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvcmVuZGVyLXRhcmdldC5qcycpLlJlbmRlclRhcmdldH0gW3RhcmdldF0gLSBUaGUgZGVzdGluYXRpb24gcmVuZGVyIHRhcmdldC5cbiAqIERlZmF1bHRzIHRvIHRoZSBmcmFtZSBidWZmZXIuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3Mvc2hhZGVyLmpzJykuU2hhZGVyfSBbc2hhZGVyXSAtIFRoZSBzaGFkZXIgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSB0ZXh0dXJlLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEdyYXBoaWNzRGV2aWNlI2dldENvcHlTaGFkZXJ9LlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2NvcmUvbWF0aC92ZWM0LmpzJykuVmVjNH0gW3JlY3RdIC0gVGhlIHZpZXdwb3J0IHJlY3RhbmdsZSB0byB1c2UgZm9yIHRoZVxuICogdGV4dHVyZSwgaW4gcGl4ZWxzLiBEZWZhdWx0cyB0byBmdWxsc2NyZWVuIChgMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0YCkuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vY29yZS9tYXRoL3ZlYzQuanMnKS5WZWM0fSBbc2Npc3NvclJlY3RdIC0gVGhlIHNjaXNzb3IgcmVjdGFuZ2xlIHRvIHVzZSBmb3JcbiAqIHRoZSB0ZXh0dXJlLCBpbiBwaXhlbHMuIERlZmF1bHRzIHRvIGZ1bGxzY3JlZW4gKGAwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHRgKS5cbiAqL1xuZnVuY3Rpb24gZHJhd1RleHR1cmUoZGV2aWNlLCB0ZXh0dXJlLCB0YXJnZXQsIHNoYWRlciwgcmVjdCwgc2Npc3NvclJlY3QpIHtcbiAgICBEZWJ1Zy5hc3NlcnQoIWRldmljZS5pc1dlYkdQVSwgJ3BjLmRyYXdUZXh0dXJlIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIG9uIFdlYkdQVSBwbGF0Zm9ybS4nKTtcblxuICAgIGNvbnN0IHVzZUJsZW5kID0gYXJndW1lbnRzWzZdO1xuICAgIERlYnVnLmNhbGwoKCkgPT4ge1xuICAgICAgICBpZiAodXNlQmxlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRGVidWcud2Fybk9uY2UoJ3BjLmRyYXdUZXh0dXJlIG5vIGxvbmdlciBhY2NlcHRzIHVzZUJsZW5kIHBhcmFtZXRlciwgYW5kIGJsZW5kaW5nIHN0YXRlIG5lZWRzIHRvIGJlIHNldCB1cCB1c2luZyBHcmFwaGljc0RldmljZS5zZXRCbGVuZFN0YXRlLicpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzaGFkZXIgPSBzaGFkZXIgfHwgZGV2aWNlLmdldENvcHlTaGFkZXIoKTtcbiAgICBkZXZpY2UuY29uc3RhbnRUZXhTb3VyY2Uuc2V0VmFsdWUodGV4dHVyZSk7XG4gICAgZHJhd1F1YWRXaXRoU2hhZGVyKGRldmljZSwgdGFyZ2V0LCBzaGFkZXIsIHJlY3QsIHNjaXNzb3JSZWN0KTtcbn1cblxuZXhwb3J0IHsgZHJhd1F1YWRXaXRoU2hhZGVyLCBkcmF3VGV4dHVyZSB9O1xuIl0sIm5hbWVzIjpbIl90ZW1wUmVjdCIsIlZlYzQiLCJkcmF3UXVhZFdpdGhTaGFkZXIiLCJkZXZpY2UiLCJ0YXJnZXQiLCJzaGFkZXIiLCJyZWN0Iiwic2Npc3NvclJlY3QiLCJEZWJ1ZyIsImFzc2VydCIsInVuZGVmaW5lZCIsInVzZUJsZW5kIiwiYXJndW1lbnRzIiwiY2FsbCIsIndhcm5PbmNlIiwiRGVidWdHcmFwaGljcyIsInB1c2hHcHVNYXJrZXIiLCJzZXRDdWxsTW9kZSIsIkNVTExGQUNFX05PTkUiLCJzZXREZXB0aFN0YXRlIiwiRGVwdGhTdGF0ZSIsIk5PREVQVEgiLCJzZXRTdGVuY2lsU3RhdGUiLCJxdWFkIiwiUXVhZFJlbmRlciIsIngiLCJ5IiwieiIsIndpZHRoIiwidyIsImhlaWdodCIsInJlbmRlclBhc3MiLCJSZW5kZXJQYXNzIiwicmVuZGVyIiwiRGVidWdIZWxwZXIiLCJzZXROYW1lIiwibmFtZSIsImluaXQiLCJjb2xvck9wcyIsImNsZWFyIiwiZGVwdGhTdGVuY2lsT3BzIiwiY2xlYXJEZXB0aCIsImlzV2ViR1BVIiwiX3RhcmdldCRzYW1wbGVzIiwic2FtcGxlcyIsInN0b3JlIiwiZGVzdHJveSIsInBvcEdwdU1hcmtlciIsImRyYXdUZXh0dXJlIiwidGV4dHVyZSIsImdldENvcHlTaGFkZXIiLCJjb25zdGFudFRleFNvdXJjZSIsInNldFZhbHVlIl0sIm1h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
