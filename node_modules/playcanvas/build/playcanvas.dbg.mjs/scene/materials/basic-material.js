import { Debug } from '../../core/debug.js';
import { Color } from '../../core/math/color.js';
import { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';
import { SHADERDEF_SKIN, SHADERDEF_SCREENSPACE, SHADERDEF_INSTANCING, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_TEXTURE_BASED } from '../constants.js';
import { getProgramLibrary } from '../shader-lib/get-program-library.js';
import { basic } from '../shader-lib/programs/basic.js';
import { Material } from './material.js';

/**
 * A BasicMaterial is for rendering unlit geometry, either using a constant color or a color map
 * modulated with a color.
 *
 * @augments Material
 */
class BasicMaterial extends Material {
  /**
   * Create a new BasicMaterial instance.
   *
   * @example
   * // Create a new Basic material
   * const material = new pc.BasicMaterial();
   *
   * // Set the material to have a texture map that is multiplied by a red color
   * material.color.set(1, 0, 0);
   * material.colorMap = diffuseMap;
   *
   * // Notify the material that it has been modified
   * material.update();
   */
  constructor() {
    super();

    /**
     * The flat color of the material (RGBA, where each component is 0 to 1).
     *
     * @type {Color}
     */
    this.color = new Color(1, 1, 1, 1);
    this.colorUniform = new Float32Array(4);

    /**
     * The color map of the material (default is null). If specified, the color map is
     * modulated by the color property.
     *
     * @type {import('../../platform/graphics/texture.js').Texture|null}
     */
    this.colorMap = null;
    this.vertexColors = false;
  }

  /**
   * Copy a `BasicMaterial`.
   *
   * @param {BasicMaterial} source - The material to copy from.
   * @returns {BasicMaterial} The destination material.
   */
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.colorMap = source.colorMap;
    this.vertexColors = source.vertexColors;
    return this;
  }
  updateUniforms(device, scene) {
    this.clearParameters();
    this.colorUniform[0] = this.color.r;
    this.colorUniform[1] = this.color.g;
    this.colorUniform[2] = this.color.b;
    this.colorUniform[3] = this.color.a;
    this.setParameter('uColor', this.colorUniform);
    if (this.colorMap) {
      this.setParameter('texture_diffuseMap', this.colorMap);
    }
  }
  getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {
    // Note: this is deprecated function Editor and possibly other projects use: they define
    // updateShader callback on their BasicMaterial, so we handle it here.
    if (this.updateShader) {
      Debug.deprecated('pc.BasicMaterial.updateShader is deprecated');
      this.updateShader(device, scene, objDefs, staticLightList, pass, sortedLights);
      return this.shader;
    }
    const options = {
      skin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,
      screenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,
      useInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,
      useMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
      useMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
      useMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,
      alphaTest: this.alphaTest > 0,
      vertexColors: this.vertexColors,
      diffuseMap: !!this.colorMap,
      pass: pass
    };
    const processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);
    const library = getProgramLibrary(device);
    library.register('basic', basic);
    return library.getProgram('basic', options, processingOptions);
  }
}

export { BasicMaterial };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzaWMtbWF0ZXJpYWwuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvYmFzaWMtbWF0ZXJpYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29yZS9tYXRoL2NvbG9yLmpzJztcblxuaW1wb3J0IHsgU2hhZGVyUHJvY2Vzc29yT3B0aW9ucyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci1wcm9jZXNzb3Itb3B0aW9ucy5qcyc7XG5cbmltcG9ydCB7XG4gICAgU0hBREVSREVGX0lOU1RBTkNJTkcsIFNIQURFUkRFRl9NT1JQSF9OT1JNQUwsIFNIQURFUkRFRl9NT1JQSF9QT1NJVElPTiwgU0hBREVSREVGX01PUlBIX1RFWFRVUkVfQkFTRUQsXG4gICAgU0hBREVSREVGX1NDUkVFTlNQQUNFLCBTSEFERVJERUZfU0tJTlxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0UHJvZ3JhbUxpYnJhcnkgfSBmcm9tICcuLi9zaGFkZXItbGliL2dldC1wcm9ncmFtLWxpYnJhcnkuanMnO1xuaW1wb3J0IHsgYmFzaWMgfSBmcm9tICcuLi9zaGFkZXItbGliL3Byb2dyYW1zL2Jhc2ljLmpzJztcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9tYXRlcmlhbC5qcyc7XG5cbi8qKlxuICogQSBCYXNpY01hdGVyaWFsIGlzIGZvciByZW5kZXJpbmcgdW5saXQgZ2VvbWV0cnksIGVpdGhlciB1c2luZyBhIGNvbnN0YW50IGNvbG9yIG9yIGEgY29sb3IgbWFwXG4gKiBtb2R1bGF0ZWQgd2l0aCBhIGNvbG9yLlxuICpcbiAqIEBhdWdtZW50cyBNYXRlcmlhbFxuICovXG5jbGFzcyBCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBCYXNpY01hdGVyaWFsIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQmFzaWMgbWF0ZXJpYWxcbiAgICAgKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBwYy5CYXNpY01hdGVyaWFsKCk7XG4gICAgICpcbiAgICAgKiAvLyBTZXQgdGhlIG1hdGVyaWFsIHRvIGhhdmUgYSB0ZXh0dXJlIG1hcCB0aGF0IGlzIG11bHRpcGxpZWQgYnkgYSByZWQgY29sb3JcbiAgICAgKiBtYXRlcmlhbC5jb2xvci5zZXQoMSwgMCwgMCk7XG4gICAgICogbWF0ZXJpYWwuY29sb3JNYXAgPSBkaWZmdXNlTWFwO1xuICAgICAqXG4gICAgICogLy8gTm90aWZ5IHRoZSBtYXRlcmlhbCB0aGF0IGl0IGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICogbWF0ZXJpYWwudXBkYXRlKCk7XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmbGF0IGNvbG9yIG9mIHRoZSBtYXRlcmlhbCAoUkdCQSwgd2hlcmUgZWFjaCBjb21wb25lbnQgaXMgMCB0byAxKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0NvbG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKTtcbiAgICAgICAgdGhpcy5jb2xvclVuaWZvcm0gPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29sb3IgbWFwIG9mIHRoZSBtYXRlcmlhbCAoZGVmYXVsdCBpcyBudWxsKS4gSWYgc3BlY2lmaWVkLCB0aGUgY29sb3IgbWFwIGlzXG4gICAgICAgICAqIG1vZHVsYXRlZCBieSB0aGUgY29sb3IgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3RleHR1cmUuanMnKS5UZXh0dXJlfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbG9yTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGEgYEJhc2ljTWF0ZXJpYWxgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCYXNpY01hdGVyaWFsfSBzb3VyY2UgLSBUaGUgbWF0ZXJpYWwgdG8gY29weSBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtCYXNpY01hdGVyaWFsfSBUaGUgZGVzdGluYXRpb24gbWF0ZXJpYWwuXG4gICAgICovXG4gICAgY29weShzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIuY29weShzb3VyY2UpO1xuXG4gICAgICAgIHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuICAgICAgICB0aGlzLmNvbG9yTWFwID0gc291cmNlLmNvbG9yTWFwO1xuICAgICAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlVW5pZm9ybXMoZGV2aWNlLCBzY2VuZSkge1xuICAgICAgICB0aGlzLmNsZWFyUGFyYW1ldGVycygpO1xuXG4gICAgICAgIHRoaXMuY29sb3JVbmlmb3JtWzBdID0gdGhpcy5jb2xvci5yO1xuICAgICAgICB0aGlzLmNvbG9yVW5pZm9ybVsxXSA9IHRoaXMuY29sb3IuZztcbiAgICAgICAgdGhpcy5jb2xvclVuaWZvcm1bMl0gPSB0aGlzLmNvbG9yLmI7XG4gICAgICAgIHRoaXMuY29sb3JVbmlmb3JtWzNdID0gdGhpcy5jb2xvci5hO1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcigndUNvbG9yJywgdGhpcy5jb2xvclVuaWZvcm0pO1xuICAgICAgICBpZiAodGhpcy5jb2xvck1hcCkge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoJ3RleHR1cmVfZGlmZnVzZU1hcCcsIHRoaXMuY29sb3JNYXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U2hhZGVyVmFyaWFudChkZXZpY2UsIHNjZW5lLCBvYmpEZWZzLCBzdGF0aWNMaWdodExpc3QsIHBhc3MsIHNvcnRlZExpZ2h0cywgdmlld1VuaWZvcm1Gb3JtYXQsIHZpZXdCaW5kR3JvdXBGb3JtYXQsIHZlcnRleEZvcm1hdCkge1xuXG4gICAgICAgIC8vIE5vdGU6IHRoaXMgaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiBFZGl0b3IgYW5kIHBvc3NpYmx5IG90aGVyIHByb2plY3RzIHVzZTogdGhleSBkZWZpbmVcbiAgICAgICAgLy8gdXBkYXRlU2hhZGVyIGNhbGxiYWNrIG9uIHRoZWlyIEJhc2ljTWF0ZXJpYWwsIHNvIHdlIGhhbmRsZSBpdCBoZXJlLlxuICAgICAgICBpZiAodGhpcy51cGRhdGVTaGFkZXIpIHtcbiAgICAgICAgICAgIERlYnVnLmRlcHJlY2F0ZWQoJ3BjLkJhc2ljTWF0ZXJpYWwudXBkYXRlU2hhZGVyIGlzIGRlcHJlY2F0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2hhZGVyKGRldmljZSwgc2NlbmUsIG9iakRlZnMsIHN0YXRpY0xpZ2h0TGlzdCwgcGFzcywgc29ydGVkTGlnaHRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBza2luOiBvYmpEZWZzICYmIChvYmpEZWZzICYgU0hBREVSREVGX1NLSU4pICE9PSAwLFxuICAgICAgICAgICAgc2NyZWVuU3BhY2U6IG9iakRlZnMgJiYgKG9iakRlZnMgJiBTSEFERVJERUZfU0NSRUVOU1BBQ0UpICE9PSAwLFxuICAgICAgICAgICAgdXNlSW5zdGFuY2luZzogb2JqRGVmcyAmJiAob2JqRGVmcyAmIFNIQURFUkRFRl9JTlNUQU5DSU5HKSAhPT0gMCxcbiAgICAgICAgICAgIHVzZU1vcnBoUG9zaXRpb246IG9iakRlZnMgJiYgKG9iakRlZnMgJiBTSEFERVJERUZfTU9SUEhfUE9TSVRJT04pICE9PSAwLFxuICAgICAgICAgICAgdXNlTW9ycGhOb3JtYWw6IG9iakRlZnMgJiYgKG9iakRlZnMgJiBTSEFERVJERUZfTU9SUEhfTk9STUFMKSAhPT0gMCxcbiAgICAgICAgICAgIHVzZU1vcnBoVGV4dHVyZUJhc2VkOiBvYmpEZWZzICYmIChvYmpEZWZzICYgU0hBREVSREVGX01PUlBIX1RFWFRVUkVfQkFTRUQpICE9PSAwLFxuXG4gICAgICAgICAgICBhbHBoYVRlc3Q6IHRoaXMuYWxwaGFUZXN0ID4gMCxcbiAgICAgICAgICAgIHZlcnRleENvbG9yczogdGhpcy52ZXJ0ZXhDb2xvcnMsXG4gICAgICAgICAgICBkaWZmdXNlTWFwOiAhIXRoaXMuY29sb3JNYXAsXG4gICAgICAgICAgICBwYXNzOiBwYXNzXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2luZ09wdGlvbnMgPSBuZXcgU2hhZGVyUHJvY2Vzc29yT3B0aW9ucyh2aWV3VW5pZm9ybUZvcm1hdCwgdmlld0JpbmRHcm91cEZvcm1hdCwgdmVydGV4Rm9ybWF0KTtcblxuICAgICAgICBjb25zdCBsaWJyYXJ5ID0gZ2V0UHJvZ3JhbUxpYnJhcnkoZGV2aWNlKTtcbiAgICAgICAgbGlicmFyeS5yZWdpc3RlcignYmFzaWMnLCBiYXNpYyk7XG5cbiAgICAgICAgcmV0dXJuIGxpYnJhcnkuZ2V0UHJvZ3JhbSgnYmFzaWMnLCBvcHRpb25zLCBwcm9jZXNzaW5nT3B0aW9ucyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYXNpY01hdGVyaWFsIH07XG4iXSwibmFtZXMiOlsiQmFzaWNNYXRlcmlhbCIsIk1hdGVyaWFsIiwiY29uc3RydWN0b3IiLCJjb2xvciIsIkNvbG9yIiwiY29sb3JVbmlmb3JtIiwiRmxvYXQzMkFycmF5IiwiY29sb3JNYXAiLCJ2ZXJ0ZXhDb2xvcnMiLCJjb3B5Iiwic291cmNlIiwidXBkYXRlVW5pZm9ybXMiLCJkZXZpY2UiLCJzY2VuZSIsImNsZWFyUGFyYW1ldGVycyIsInIiLCJnIiwiYiIsImEiLCJzZXRQYXJhbWV0ZXIiLCJnZXRTaGFkZXJWYXJpYW50Iiwib2JqRGVmcyIsInN0YXRpY0xpZ2h0TGlzdCIsInBhc3MiLCJzb3J0ZWRMaWdodHMiLCJ2aWV3VW5pZm9ybUZvcm1hdCIsInZpZXdCaW5kR3JvdXBGb3JtYXQiLCJ2ZXJ0ZXhGb3JtYXQiLCJ1cGRhdGVTaGFkZXIiLCJEZWJ1ZyIsImRlcHJlY2F0ZWQiLCJzaGFkZXIiLCJvcHRpb25zIiwic2tpbiIsIlNIQURFUkRFRl9TS0lOIiwic2NyZWVuU3BhY2UiLCJTSEFERVJERUZfU0NSRUVOU1BBQ0UiLCJ1c2VJbnN0YW5jaW5nIiwiU0hBREVSREVGX0lOU1RBTkNJTkciLCJ1c2VNb3JwaFBvc2l0aW9uIiwiU0hBREVSREVGX01PUlBIX1BPU0lUSU9OIiwidXNlTW9ycGhOb3JtYWwiLCJTSEFERVJERUZfTU9SUEhfTk9STUFMIiwidXNlTW9ycGhUZXh0dXJlQmFzZWQiLCJTSEFERVJERUZfTU9SUEhfVEVYVFVSRV9CQVNFRCIsImFscGhhVGVzdCIsImRpZmZ1c2VNYXAiLCJwcm9jZXNzaW5nT3B0aW9ucyIsIlNoYWRlclByb2Nlc3Nvck9wdGlvbnMiLCJsaWJyYXJ5IiwiZ2V0UHJvZ3JhbUxpYnJhcnkiLCJyZWdpc3RlciIsImJhc2ljIiwiZ2V0UHJvZ3JhbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxhQUFhLFNBQVNDLFFBQVEsQ0FBQztBQUNqQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lDLEVBQUFBLFdBQVdBLEdBQUc7QUFDVixJQUFBLEtBQUssRUFBRSxDQUFBOztBQUVQO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDUSxJQUFBLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlDLEtB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
