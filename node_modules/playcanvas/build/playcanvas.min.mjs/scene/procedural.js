import{Vec2 as t}from"../core/math/vec2.js";import{Vec3 as s}from"../core/math/vec3.js";import{SEMANTIC_TANGENT as e,SEMANTIC_BLENDINDICES as n,TYPE_UINT8 as a,SEMANTIC_BLENDWEIGHT as l}from"../platform/graphics/constants.js";import{Mesh as u}from"./mesh.js";const o=4/64,h=.875,r=[];function i(t,e){const n=e.length/3,a=t.length/3,l=new s,u=new s,o=new s,h=new s,r=new s,i=new s,c=[];for(let s=0;s<t.length;s++)c[s]=0;for(let s=0;s<n;s++){const n=e[3*s],a=e[3*s+1],p=e[3*s+2];l.set(t[3*n],t[3*n+1],t[3*n+2]),u.set(t[3*a],t[3*a+1],t[3*a+2]),o.set(t[3*p],t[3*p+1],t[3*p+2]),h.sub2(u,l),r.sub2(o,l),i.cross(h,r).normalize(),c[3*n]+=i.x,c[3*n+1]+=i.y,c[3*n+2]+=i.z,c[3*a]+=i.x,c[3*a+1]+=i.y,c[3*a+2]+=i.z,c[3*p]+=i.x,c[3*p+1]+=i.y,c[3*p+2]+=i.z}for(let t=0;t<a;t++){const s=c[3*t],e=c[3*t+1],n=c[3*t+2],a=1/Math.sqrt(s*s+e*e+n*n);c[3*t]*=a,c[3*t+1]*=a,c[3*t+2]*=a}return c}function c(e,n,a,l){const u=l.length/3,o=e.length/3,h=new s,r=new s,i=new s,c=new t,p=new t,M=new t,f=new s,g=new s,d=new Float32Array(3*o),m=new Float32Array(3*o),w=[];for(let t=0;t<u;t++){const s=l[3*t],n=l[3*t+1],u=l[3*t+2];h.set(e[3*s],e[3*s+1],e[3*s+2]),r.set(e[3*n],e[3*n+1],e[3*n+2]),i.set(e[3*u],e[3*u+1],e[3*u+2]),c.set(a[2*s],a[2*s+1]),p.set(a[2*n],a[2*n+1]),M.set(a[2*u],a[2*u+1]);const o=r.x-h.x,w=i.x-h.x,x=r.y-h.y,y=i.y-h.y,v=r.z-h.z,I=i.z-h.z,z=p.x-c.x,P=M.x-c.x,b=p.y-c.y,S=M.y-c.y,k=z*S-P*b;if(0===k)f.set(0,1,0),g.set(1,0,0);else{const t=1/k;f.set((S*o-b*w)*t,(S*x-b*y)*t,(S*v-b*I)*t),g.set((z*w-P*o)*t,(z*y-P*x)*t,(z*I-P*v)*t)}d[3*s+0]+=f.x,d[3*s+1]+=f.y,d[3*s+2]+=f.z,d[3*n+0]+=f.x,d[3*n+1]+=f.y,d[3*n+2]+=f.z,d[3*u+0]+=f.x,d[3*u+1]+=f.y,d[3*u+2]+=f.z,m[3*s+0]+=g.x,m[3*s+1]+=g.y,m[3*s+2]+=g.z,m[3*n+0]+=g.x,m[3*n+1]+=g.y,m[3*n+2]+=g.z,m[3*u+0]+=g.x,m[3*u+1]+=g.y,m[3*u+2]+=g.z}const x=new s,y=new s,v=new s,I=new s;for(let t=0;t<o;t++){v.set(n[3*t],n[3*t+1],n[3*t+2]),x.set(d[3*t],d[3*t+1],d[3*t+2]),y.set(m[3*t],m[3*t+1],m[3*t+2]);const s=v.dot(x);I.copy(v).mulScalar(s),I.sub2(x,I).normalize(),w[4*t]=I.x,w[4*t+1]=I.y,w[4*t+2]=I.z,I.cross(v,x),w[4*t+3]=I.dot(y)<0?-1:1}return w}function p(t,s,o){const h=new u(t);return h.setPositions(s),o&&(o.normals&&h.setNormals(o.normals),o.tangents&&h.setVertexStream(e,o.tangents,4),o.colors&&h.setColors32(o.colors),o.uvs&&h.setUvs(0,o.uvs),o.uvs1&&h.setUvs(1,o.uvs1),o.blendIndices&&h.setVertexStream(n,o.blendIndices,4,o.blendIndices.length/4,a),o.blendWeights&&h.setVertexStream(l,o.blendWeights,4),o.indices&&h.setIndices(o.indices)),h.update(),h}function M(t,s={}){var e,n,a,l,u;const o=null!=(e=s.tubeRadius)?e:.2,h=null!=(n=s.ringRadius)?n:.3,r=null!=(a=s.segments)?a:30,i=null!=(l=s.sides)?l:20,M=null!=(u=s.calculateTangents)&&u,f=[],g=[],d=[],m=[];for(let t=0;t<=i;t++)for(let s=0;s<=r;s++){const e=Math.cos(2*Math.PI*s/r)*(h+o*Math.cos(2*Math.PI*t/i)),n=Math.sin(2*Math.PI*t/i)*o,a=Math.sin(2*Math.PI*s/r)*(h+o*Math.cos(2*Math.PI*t/i)),l=Math.cos(2*Math.PI*s/r)*Math.cos(2*Math.PI*t/i),u=Math.sin(2*Math.PI*t/i),c=Math.sin(2*Math.PI*s/r)*Math.cos(2*Math.PI*t/i),p=t/i,M=1-s/r;if(f.push(e,n,a),g.push(l,u,c),d.push(p,1-M),t<i&&s<r){const e=t*(r+1)+s,n=(t+1)*(r+1)+s,a=t*(r+1)+(s+1),l=(t+1)*(r+1)+(s+1);m.push(e,n,a),m.push(n,l,a)}}const w={normals:g,uvs:d,uvs1:d,indices:m};return M&&(w.tangents=c(f,g,d,m)),p(t,f,w)}function f(t,e,n,a,l,u){const r=new s,i=new s,c=new s,p=new s,M=new s,f=new s,g=[],d=[],m=[],w=[],x=[];let y;if(n>0)for(let s=0;s<=a;s++)for(let u=0;u<=l;u++){const y=u/l*2*Math.PI-Math.PI,v=Math.sin(y),I=Math.cos(y);M.set(v*t,-n/2,I*t),p.set(v*e,n/2,I*e),r.lerp(M,p,s/a),i.sub2(p,M).normalize(),f.set(I,0,-v),c.cross(f,i).normalize(),g.push(r.x,r.y,r.z),d.push(c.x,c.y,c.z);let z=u/l,P=s/a;m.push(z,1-P);const b=P;if(P=z,z=b,z=z*h+o,P=P*h+o,z/=3,w.push(z,1-P),s<a&&u<l){const t=s*(l+1)+u,e=s*(l+1)+(u+1),n=(s+1)*(l+1)+u,a=(s+1)*(l+1)+(u+1);x.push(t,e,n),x.push(e,a,n)}}if(u){const t=Math.floor(l/2),s=l,u=n/2;for(let n=0;n<=t;n++){const a=n*Math.PI*.5/t,l=Math.sin(a),r=Math.cos(a);for(let a=0;a<=s;a++){const i=2*a*Math.PI/s-Math.PI/2,c=Math.sin(i),p=Math.cos(i)*l,M=r,f=c*l;let x=1-a/s,y=1-n/t;g.push(p*e,M*e+u,f*e),d.push(p,M,f),m.push(x,1-y),x=x*h+o,y=y*h+o,x/=3,y/=3,x+=1/3,w.push(x,1-y)}}y=(a+1)*(l+1);for(let e=0;e<t;++e)for(let t=0;t<s;++t){const n=e*(s+1)+t,a=n+s+1;x.push(y+n+1,y+a,y+n),x.push(y+n+1,y+a+1,y+a)}for(let n=0;n<=t;n++){const a=.5*Math.PI+n*Math.PI*.5/t,l=Math.sin(a),r=Math.cos(a);for(let a=0;a<=s;a++){const i=2*a*Math.PI/s-Math.PI/2,c=Math.sin(i),p=Math.cos(i)*l,M=r,f=c*l;let x=1-a/s,y=1-n/t;g.push(p*e,M*e-u,f*e),d.push(p,M,f),m.push(x,1-y),x=x*h+o,y=y*h+o,x/=3,y/=3,x+=2/3,w.push(x,1-y)}}y=(a+1)*(l+1)+(s+1)*(t+1);for(let e=0;e<t;++e)for(let t=0;t<s;++t){const n=e*(s+1)+t,a=n+s+1;x.push(y+n+1,y+a,y+n),x.push(y+n+1,y+a+1,y+a)}}else{if(y=(a+1)*(l+1),t>0)for(let s=0;s<l;s++){const e=s/l*2*Math.PI,a=Math.sin(e),u=-n/2,r=Math.cos(e);let i=1-(a+1)/2,c=(r+1)/2;g.push(a*t,u,r*t),d.push(0,-1,0),m.push(i,1-c),i=i*h+o,c=c*h+o,i/=3,c/=3,i+=1/3,w.push(i,1-c),s>1&&x.push(y,y+s,y+s-1)}if(y+=l,e>0)for(let t=0;t<l;t++){const s=t/l*2*Math.PI,a=Math.sin(s),u=n/2,r=Math.cos(s);let i=1-(a+1)/2,c=(r+1)/2;g.push(a*e,u,r*e),d.push(0,1,0),m.push(i,1-c),i=i*h+o,c=c*h+o,i/=3,c/=3,i+=2/3,w.push(i,1-c),t>1&&x.push(y,y+t-1,y+t)}}return{positions:g,normals:d,uvs:m,uvs1:w,indices:x}}function g(t,s={}){var e,n,a,l,u;const o=null!=(e=s.radius)?e:.5,h=null!=(n=s.height)?n:1,r=null!=(a=s.heightSegments)?a:5,i=null!=(l=s.capSegments)?l:20,M=null!=(u=s.calculateTangents)&&u,g=f(o,o,h,r,i,!1);return M&&(g.tangents=c(g.positions,g.normals,g.uvs,g.indices)),p(t,g.positions,g)}function d(t,s={}){var e,n,a,l,u;const o=null!=(e=s.radius)?e:.3,h=null!=(n=s.height)?n:1,r=null!=(a=s.heightSegments)?a:1,i=null!=(l=s.sides)?l:20,M=null!=(u=s.calculateTangents)&&u,g=f(o,o,h-2*o,r,i,!0);return M&&(g.tangents=c(g.positions,g.normals,g.uvs,g.indices)),p(t,g.positions,g)}function m(t,s={}){var e,n,a,l,u,o;const h=null!=(e=s.baseRadius)?e:.5,r=null!=(n=s.peakRadius)?n:0,i=null!=(a=s.height)?a:1,M=null!=(l=s.heightSegments)?l:5,g=null!=(u=s.capSegments)?u:18,d=null!=(o=s.calculateTangents)&&o,m=f(h,r,i,M,g,!1);return d&&(m.tangents=c(m.positions,m.normals,m.uvs,m.indices)),p(t,m.positions,m)}function w(t,s={}){var e,n,a,l;const u=null!=(e=s.radius)?e:.5,o=null!=(n=s.latitudeBands)?n:16,h=null!=(a=s.longitudeBands)?a:16,r=null!=(l=s.calculateTangents)&&l,i=[],M=[],f=[],g=[];for(let t=0;t<=o;t++){const s=t*Math.PI/o,e=Math.sin(s),n=Math.cos(s);for(let s=0;s<=h;s++){const a=2*s*Math.PI/h-Math.PI/2,l=Math.sin(a),r=Math.cos(a)*e,c=n,p=l*e,g=1-s/h,d=1-t/o;i.push(r*u,c*u,p*u),M.push(r,c,p),f.push(g,1-d)}}for(let t=0;t<o;++t)for(let s=0;s<h;++s){const e=t*(h+1)+s,n=e+h+1;g.push(e+1,n,e),g.push(e+1,n+1,n)}const d={normals:M,uvs:f,uvs1:f,indices:g};return r&&(d.tangents=c(i,M,f,g)),p(t,i,d)}function x(s,e={}){var n,a,l,u;const o=null!=(n=e.halfExtents)?n:new t(.5,.5),h=null!=(a=e.widthSegments)?a:5,r=null!=(l=e.lengthSegments)?l:5,i=null!=(u=e.calculateTangents)&&u,M=[],f=[],g=[],d=[];let m=0;for(let t=0;t<=h;t++)for(let s=0;s<=r;s++){const e=-o.x+2*o.x*t/h,n=0,a=-(-o.y+2*o.y*s/r),l=t/h,u=s/r;M.push(e,n,a),f.push(0,1,0),g.push(l,1-u),t<h&&s<r&&(d.push(m+r+1,m+1,m),d.push(m+r+1,m+r+2,m+1)),m++}const w={normals:f,uvs:g,uvs1:g,indices:d};return i&&(w.tangents=c(M,f,g,d)),p(s,M,w)}function y(t,e={}){var n,a,l,u,r;const i=null!=(n=e.halfExtents)?n:new s(.5,.5,.5),M=null!=(a=e.widthSegments)?a:1,f=null!=(l=e.lengthSegments)?l:1,g=null!=(u=e.heightSegments)?u:1,d=null!=(r=e.calculateTangents)&&r,m=[new s(-i.x,-i.y,i.z),new s(i.x,-i.y,i.z),new s(i.x,i.y,i.z),new s(-i.x,i.y,i.z),new s(i.x,-i.y,-i.z),new s(-i.x,-i.y,-i.z),new s(-i.x,i.y,-i.z),new s(i.x,i.y,-i.z)],w=[[0,1,3],[4,5,7],[3,2,6],[1,0,4],[1,4,2],[5,0,6]],x=[[0,0,1],[0,0,-1],[0,1,0],[0,-1,0],[1,0,0],[-1,0,0]],y=1,v=2,I=3,z=4,P=5,b=[],S=[],k=[],R=[],T=[];let j=0;const E=(t,e,n)=>{const a=new s,l=new s,u=new s,r=new s;for(let s=0;s<=e;s++)for(let i=0;i<=n;i++){a.lerp(m[w[t][0]],m[w[t][1]],s/e),l.lerp(m[w[t][0]],m[w[t][2]],i/n),u.sub2(l,m[w[t][0]]),r.add2(a,u);let c=s/e,p=i/n;b.push(r.x,r.y,r.z),S.push(x[t][0],x[t][1],x[t][2]),k.push(c,1-p),c=c*h+o,p=p*h+o,c/=3,p/=3,c+=t%3/3,p+=Math.floor(t/3)/3,R.push(c,1-p),s<e&&i<n&&(T.push(j+n+1,j+1,j),T.push(j+n+1,j+n+2,j+1)),j++}};E(0,M,g),E(y,M,g),E(v,M,f),E(I,M,f),E(z,f,g),E(P,f,g);const V={normals:S,uvs:k,uvs1:R,indices:T};return d&&(V.tangents=c(b,S,k,T)),p(t,b,V)}function v(s,e){let n=null;for(let t=0;t<r.length;t++)r[t].type===e&&r[t].device===s&&(n=r[t].primData);if(!n){let a,l;switch(e){case"box":a=y(s),l={x:2,y:2,z:2,uv:2/3};break;case"capsule":a=d(s,{radius:.5,height:2}),l={x:2*Math.PI,y:Math.PI,z:2*Math.PI,uv:1/3+1/3/3*2};break;case"cone":a=m(s,{baseRadius:.5,peakRadius:0,height:1}),l={x:2.54,y:2.54,z:2.54,uv:1/3+1/3/3};break;case"cylinder":a=g(s,{radius:.5,height:1}),l={x:Math.PI,y:1.58,z:Math.PI,uv:1/3+1/3/3*2};break;case"plane":a=x(s,{halfExtents:new t(.5,.5),widthSegments:1,lengthSegments:1}),l={x:0,y:1,z:0,uv:1};break;case"sphere":a=w(s,{radius:.5}),l={x:Math.PI,y:Math.PI,z:Math.PI,uv:1};break;case"torus":a=M(s,{tubeRadius:.2,ringRadius:.3}),l={x:.5*Math.PI*.5-.1*Math.PI*.1,y:.4,z:.4,uv:1};break;default:throw new Error("Invalid primitive type: "+e)}a.incRefCount(),n={mesh:a,area:l},r.push({type:e,device:s,primData:n})}return n}export{i as calculateNormals,c as calculateTangents,y as createBox,d as createCapsule,m as createCone,g as createCylinder,p as createMesh,x as createPlane,w as createSphere,M as createTorus,v as getShapePrimitive};
