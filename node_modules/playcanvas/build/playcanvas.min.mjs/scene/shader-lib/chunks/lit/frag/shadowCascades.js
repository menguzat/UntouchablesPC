var t="\nconst float maxCascades = 4.0;\n\n// shadow matrix for selected cascade\nmat4 cascadeShadowMat;\n\n// function which selects a shadow projection matrix based on cascade distances \nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\n\t\t// depth in 0 .. far plane range\n\t\tfloat depth = 1.0 / gl_FragCoord.w;\n\n\t\t// find cascade index based on the depth (loop as there is no per component vec compare operator in webgl)\n\t\tfloat cascadeIndex = 0.0;\n\t\tfor (float i = 0.0; i < maxCascades; i++) {\n\t\t\t\tif (depth < shadowCascadeDistances[int(i)]) {\n\t\t\t\t\t\tcascadeIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\n\t\t// limit to actual number of used cascades\n\t\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\n\t\t// pick shadow matrix\n\t\t#ifdef GL2\n\t\t\t\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n\t\t#else\n\t\t\t\t// webgl 1 does not allow non-cost index array lookup\n\t\t\t\tif (cascadeIndex == 0.0) {\n\t\t\t\t\t\tcascadeShadowMat = shadowMatrixPalette[0];\n\t\t\t\t}\n\t\t\t\telse if (cascadeIndex == 1.0) {\n\t\t\t\t\t\tcascadeShadowMat = shadowMatrixPalette[1];\n\t\t\t\t}\n\t\t\t\telse if (cascadeIndex == 2.0) {\n\t\t\t\t\t\tcascadeShadowMat = shadowMatrixPalette[2];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\tcascadeShadowMat = shadowMatrixPalette[3];\n\t\t\t\t}\n\t\t#endif\n}\n\nvoid fadeShadow(float shadowCascadeDistances[4]) {                  \n\n\t\t// if the pixel is past the shadow distance, remove shadow\n\t\t// this enforces straight line instead of corner of shadow which moves when camera rotates  \n\t\tfloat depth = 1.0 / gl_FragCoord.w;\n\t\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n\t\t\t\tdShadowCoord.z = -9999999.0;\n\t\t}\n}\n";export{t as default};
