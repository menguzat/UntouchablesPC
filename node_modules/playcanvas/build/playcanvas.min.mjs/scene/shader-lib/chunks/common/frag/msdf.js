var t="\nuniform sampler2D texture_msdfMap;\n\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n\n#ifdef GL2\n#define USE_FWIDTH\n#endif\n\nfloat median(float r, float g, float b) {\n\t\treturn max(min(r, g), min(max(r, g), b));\n}\n\nfloat map (float min, float max, float v) {\n\t\treturn (v - min) / (max - min);\n}\n\nuniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost\nuniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF\nuniform float font_textureWidth; // the width of the texture atlas\n\n#ifdef UNIFORM_TEXT_PARAMETERS\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\n#else\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\n#endif\n\nvec4 applyMsdf(vec4 color) {\n\t\t// sample the field\n\t\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\t\tvec2 uvShdw = vUv0 - shadow_offset;\n\t\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\t\t// get the signed distance value\n\t\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\t\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\n\t\t// smoothing limit - smaller value makes for sharper but more aliased text, especially on angles\n\t\t// too large value (0.5) creates a dark glow around the letters\n\t\tfloat smoothingMax = 0.2;\n\n\t\t#ifdef USE_FWIDTH\n\t\t// smoothing depends on size of texture on screen\n\t\tvec2 w = fwidth(vUv0);\n\t\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n\t\t#else\n\t\tfloat font_size = 16.0; // TODO fix this\n\t\t// smoothing gets smaller as the font size gets bigger\n\t\t// don't have fwidth we can approximate from font size, this doesn't account for scaling\n\t\t// so a big font scaled down will be wrong...\n\t\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n\t\t#endif\n\n\t\tfloat mapMin = 0.05;\n\t\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\n\t\t// remap to a smaller range (used on smaller font sizes)\n\t\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\t\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\t\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\n\t\tfloat center = 0.5;\n\t\t// calculate smoothing and use to generate opacity\n\t\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\t\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\t\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\n\t\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\t\ttcolor = mix(tcolor, color, inside);\n\n\t\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\t\ttcolor = mix(scolor, tcolor, outline);\n\t\t\n\t\treturn tcolor;\n}\n";export{t as default};
