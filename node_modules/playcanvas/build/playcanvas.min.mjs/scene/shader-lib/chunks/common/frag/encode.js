var t="\nvec4 encodeLinear(vec3 source) {\n\t\treturn vec4(source, 1.0);\n}\n\nvec4 encodeGamma(vec3 source) {\n\t\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\n\nvec4 encodeRGBM(vec3 source) { // modified RGBM\n\t\tvec4 result;\n\t\tresult.rgb = pow(source.rgb, vec3(0.5));\n\t\tresult.rgb *= 1.0 / 8.0;\n\n\t\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\t\tresult.a = ceil(result.a * 255.0) / 255.0;\n\n\t\tresult.rgb /= result.a;\n\t\treturn result;\n}\n\nvec4 encodeRGBP(vec3 source) {\n\t\t// convert incoming linear to gamma(ish)\n\t\tvec3 gamma = pow(source, vec3(0.5));\n\n\t\t// calculate the maximum component clamped to 1..8\n\t\tfloat maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\n\t\t// calculate storage factor\n\t\tfloat v = 1.0 - ((maxVal - 1.0) / 7.0);\n\n\t\t// round the value for storage in 8bit channel\n\t\tv = ceil(v * 255.0) / 255.0;\n\n\t\treturn vec4(gamma / (-v * 7.0 + 8.0), v);    \n}\n\nvec4 encodeRGBE(vec3 source) {\n\t\tfloat maxVal = max(source.x, max(source.y, source.z));\n\t\tif (maxVal < 1e-32) {\n\t\t\t\treturn vec4(0, 0, 0, 0);\n\t\t} else {\n\t\t\t\tfloat e = ceil(log2(maxVal));\n\t\t\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t\t}\n}\n";export{t as default};
