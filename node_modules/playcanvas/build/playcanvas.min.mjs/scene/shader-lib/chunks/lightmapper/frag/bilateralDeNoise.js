var t="\n// bilateral filter, based on https://www.shadertoy.com/view/4dfGDH# and\n// http://people.csail.mit.edu/sparis/bf_course/course_notes.pdf\n\n// A bilateral filter is a non-linear, edge-preserving, and noise-reducing smoothing filter for images.\n// It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels.\n// This weight can be based on a Gaussian distribution. Crucially, the weights depend not only on\n// Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such\n// as color intensity, depth distance, etc.). This preserves sharp edges.\n\nfloat normpdf3(in vec3 v, in float sigma) {\n\t\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\n\nvec3 decodeRGBM(vec4 rgbm) {\n\t\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\t\treturn color * color;\n}\n\nfloat saturate(float x) {\n\t\treturn clamp(x, 0.0, 1.0);\n}\n\nvec4 encodeRGBM(vec3 color) { // modified RGBM\n\t\tvec4 encoded;\n\t\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\t\tencoded.rgb *= 1.0 / 8.0;\n\n\t\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\t\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\n\t\tencoded.rgb /= encoded.a;\n\t\treturn encoded;\n}\n\n// filter size\n#define MSIZE 15\n\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\n\nvoid main(void) {\n\t\t\n\t\tvec4 pixelRgbm = texture2D(source, vUv0);\n\n\t\t// lightmap specific optimization - skip pixels that were not baked\n\t\t// this also allows dilate filter that work on the output of this to work correctly, as it depends on .a being zero\n\t\t// to dilate, which the following blur filter would otherwise modify\n\t\tif (pixelRgbm.a <= 0.0) {\n\t\t\t\tgl_FragColor = pixelRgbm;\n\t\t\t\treturn ;\n\t\t}\n\n\t\t// range sigma - controls blurriness based on a pixel distance\n\t\tfloat sigma = sigmas.x;\n\n\t\t// domain sigma - controls blurriness based on a pixel similarity (to preserve edges)\n\t\tfloat bSigma = sigmas.y;\n\n\t\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\n\t\tvec3 accumulatedHdr = vec3(0.0);\n\t\tfloat accumulatedFactor = 0.0;\n\n\t\t// read out the texels\n\t\tconst int kSize = (MSIZE-1)/2;\n\t\tfor (int i = -kSize; i <= kSize; ++i) {\n\t\t\t\tfor (int j = -kSize; j <= kSize; ++j) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// sample the pixel with offset\n\t\t\t\t\t\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n\t\t\t\t\t\tvec4 rgbm = texture2D(source, coord);\n\n\t\t\t\t\t\t// lightmap - only use baked pixels\n\t\t\t\t\t\tif (rgbm.a > 0.0) {\n\t\t\t\t\t\t\t\tvec3 hdr = decodeRGBM(rgbm);\n\n\t\t\t\t\t\t\t\t// bilateral factors\n\t\t\t\t\t\t\t\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\n\t\t\t\t\t\t\t\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\n\t\t\t\t\t\t\t\t// accumulate\n\t\t\t\t\t\t\t\taccumulatedHdr += factor * hdr;\n\t\t\t\t\t\t\t\taccumulatedFactor += factor;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n";export{t as default};
