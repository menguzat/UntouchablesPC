import"../../core/debug.js";import{version as e,revision as t}from"../../core/core.js";import{Shader as s}from"../../platform/graphics/shader.js";import{SHADER_FORWARD as i,SHADER_SHADOW as r,SHADER_DEPTH as a,SHADER_PICK as n}from"../constants.js";import{ShaderPass as o}from"../shader-pass.js";import{StandardMaterialOptions as h}from"../materials/standard-material-options.js";class c{constructor(e,t){this.processedCache=new Map,this.definitionsCache=new Map,this._device=e,this._generators={},this._isClearingCache=!1,this._precached=!1,this._programsCollection=[],this._defaultStdMatOption=new h,this._defaultStdMatOptionMin=new h,t.shaderOptBuilder.updateRef(this._defaultStdMatOption,{},t,null,[],i,null),t.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin,{},t,null,[],r,null),e.on("destroy:shader",(e=>{this.removeFromCache(e)}))}destroy(){this.clearCache()}register(e,t){this.isRegistered(e)||(this._generators[e]=t)}unregister(e){this.isRegistered(e)&&delete this._generators[e]}isRegistered(e){return void 0!==this._generators[e]}generateShaderDefinition(e,t,s,i){let r=this.definitionsCache.get(s);if(!r){var a,n,o;let h;null!=(a=i.litOptions)&&a.lights&&(h=i.litOptions.lights,i.litOptions.lights=h.map((function(e){const t=e.clone?e.clone():e;return t.key=e.key,t}))),this.storeNewProgram(t,i),null!=(n=i.litOptions)&&n.lights&&(i.litOptions.lights=h),this._precached;const c=this._device;r=e.createShaderDefinition(c,i),r.name=null!=(o=r.name)?o:i.pass?`${t}-pass:${i.pass}`:t,this.definitionsCache.set(s,r)}return r}getCachedShader(e){return this.processedCache.get(e)}setCachedShader(e,t){this.processedCache.set(e,t)}getProgram(e,t,i){const r=this._generators[e];if(!r)return null;const a=r.generateKey(t),n=`${a}#${i.generateKey()}`;let h=this.getCachedShader(n);if(!h){const c=this.generateShaderDefinition(r,e,a,t);let d="";if(void 0!==t.pass){d=`-${o.get(this._device).getByIndex(t.pass).name}`}const l={name:`${c.name}${d}-proc`,attributes:c.attributes,vshader:c.vshader,fshader:c.fshader,processingOptions:i};h=new s(this._device,l),this.setCachedShader(n,h)}return h}storeNewProgram(e,t){let s={};if("standard"===e){const e=this._getDefaultStdMatOptions(t.pass);for(const i in t)(t.hasOwnProperty(i)&&e[i]!==t[i]||"pass"===i)&&(s[i]=t[i]);for(const e in t.litOptions)s[e]=t.litOptions[e]}else s=t;this._programsCollection.push(JSON.stringify({name:e,options:s}))}dumpPrograms(){let s="let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n";s+="let shaders = [",this._programsCollection[0]&&(s+="\n\t"+this._programsCollection[0]);for(let e=1;e<this._programsCollection.length;++e)s+=",\n\t"+this._programsCollection[e];s+="\n];\n",s+="device.getProgramLibrary().precompile(shaders);\n",s+='if (pc.version != "'+e+'" || pc.revision != "'+t+'")\n',s+='\tconsole.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';const i=document.createElement("a");i.setAttribute("href","data:text/plain;charset=utf-8,"+encodeURIComponent(s)),i.setAttribute("download","precompile-shaders.js"),i.style.display="none",document.body.appendChild(i),i.click(),document.body.removeChild(i)}clearCache(){this._isClearingCache=!0,this.processedCache.forEach((e=>{e.destroy()})),this.processedCache.clear(),this._isClearingCache=!1}removeFromCache(e){this._isClearingCache||this.processedCache.forEach(((t,s)=>{e===t&&this.processedCache.delete(s)}))}_getDefaultStdMatOptions(e){const t=o.get(this._device).getByIndex(e);return e===a||e===n||t.isShadow?this._defaultStdMatOptionMin:this._defaultStdMatOption}precompile(e){if(e){const t=new Array(e.length);for(let s=0;s<e.length;s++){if("standard"===e[s].name){const t=e[s].options,i=this._getDefaultStdMatOptions(t.pass);for(const e in i)i.hasOwnProperty(e)&&void 0===t[e]&&(t[e]=i[e])}t[s]=this.getProgram(e[s].name,e[s].options)}}this._precached=!0}}export{c as ProgramLibrary};
