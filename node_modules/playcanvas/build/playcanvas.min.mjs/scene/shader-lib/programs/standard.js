import{hashCode as e}from"../../../core/hash.js";import"../../../core/debug.js";import{LIGHTTYPE_DIRECTIONAL as a,SPRITE_RENDERMODE_SLICED as n,SPRITE_RENDERMODE_TILED as t,SPECULAR_PHONG as s,FRESNEL_SCHLICK as p,BLEND_NONE as i}from"../../constants.js";import{ShaderPass as r}from"../../shader-pass.js";import{LitShader as d}from"./lit-shader.js";import{ChunkBuilder as o}from"../chunk-builder.js";import{ChunkUtils as l}from"../chunk-utils.js";import{StandardMaterialOptions as c}from"../../materials/standard-material-options.js";const h=[],u={optionsContext:new c,optionsContextMin:new c,generateKey:function(n){const t=function(e){const a=[];for(const n in e)e.hasOwnProperty(n)&&"chunks"!==n&&"lights"!==n&&a.push(n);return a.sort()};let s;n===this.optionsContextMin?(this.propsMin||(this.propsMin=t(n)),s=this.propsMin):n===this.optionsContext?(this.props||(this.props=t(n)),s=this.props):s=t(n);let p="standard";for(let e=0;e<s.length;e++)n[s[e]]&&(p+=s[e]+n[s[e]]);if(n.chunks){const e=[];for(const a in n.chunks)n.chunks.hasOwnProperty(a)&&e.push(a+n.chunks[a]);e.sort(),p+=e}if(n.litOptions)for(const e in n.litOptions)if("lights"===e){const e=n.litOptions.clusteredLightingEnabled;for(let t=0;t<n.litOptions.lights.length;t++){const s=n.litOptions.lights[t];e&&s._type!==a||(p+=s.key)}}else p+=e+n.litOptions[e];return e(p)},_getUvSourceExpression:function(e,a,s){const p=s[e],i=s[a],r=s.isForwardPass;let d;return r&&s.litOptions.nineSlicedMode===n||r&&s.litOptions.nineSlicedMode===t?d="nineSlicedUv":(d=0===p?"vUv"+i:"vUV"+i+"_"+p,s.heightMap&&"heightMapTransform"!==e&&(d+=" + dUvOffset")),d},_addMapDef:function(e,a){return a?`#define ${e}\n`:`#undef ${e}\n`},_addMapDefs:function(e,a,n,t,s){return this._addMapDef("MAPFLOAT",e)+this._addMapDef("MAPCOLOR",a)+this._addMapDef("MAPVERTEX",n)+this._addMapDef("MAPTEXTURE",t)+this._addMapDef("MAPINVERT",s)},_addMap:function(e,a,n,t,s,p=null){const i=e+"Map",r=i+"Uv",d=i+"Identifier",o=i+"Transform",c=i+"Channel",h=e+"VertexColorChannel",u=e+"VertexColor",g=e+"Mode",f=e+"Invert",S=n[e+"Tint"],m=n[u],M=n[i],_=n[d],A=n[g];let k=t[a];if(M){const e=this._getUvSourceExpression(o,r,n);if(k=k.replace(/\$UV/g,e).replace(/\$CH/g,n[c]),s&&-1!==k.search(/\$SAMPLER/g)){let e="texture_"+i;const a=s[_];a?e=a:s[_]=e,k=k.replace(/\$SAMPLER/g,e)}if(p&&(k="aaa"===n[c]?k.replace(/\$DECODE/g,"passThrough"):k.replace(/\$DECODE/g,l.decodeFunc(n.litOptions.gamma||"srgb"!==p?p:"linear")),k.indexOf("$texture2DSAMPLE"))){const e={linear:"texture2D",srgb:"texture2DSRGB",rgbm:"texture2DRGBM",rgbe:"texture2DRGBE"};k=k.replace(/\$texture2DSAMPLE/g,e[p]||"texture2D")}}m&&(k=k.replace(/\$VC/g,n[h])),A&&(k=k.replace(/\$DETAILMODE/g,A));const O=!!(1&S),P=!!(2&S),C=!!n[f];return k=this._addMapDefs(O,P,m,M,C)+k,k.replace(/\$/g,"")},_correctChannel:function(e,a,n){if(n[e]>0){if(n[e]<a.length)return a.substring(0,n[e]);if(n[e]>a.length){let t=a;const s=t.charAt(t.length-1),p=n[e]-t.length;for(let e=0;e<p;e++)t+=s;return t}return a}},createShaderDefinition:function(e,a){const n=r.get(e).getByIndex(a.pass).isForward;a.isForwardPass=n;const l=new d(e,a.litOptions),c=[],u=[],g=[],f={};for(const e in h){const n=e+"Map";if(a[e+"VertexColor"]){const n=e+"VertexColorChannel";a[n]=this._correctChannel(e,a[n],h)}if(a[n]){const t=n+"Channel",s=n+"Transform",p=n+"Uv";a[p]=Math.min(a[p],1),a[t]=this._correctChannel(e,a[t],h);const i=a[p];c[i]=!0,u[i]=u[i]||a[n]&&!a[s],a[s]&&g.push({name:e,id:a[s],uv:a[p]})}}a.forceUv1&&(c[1]=!0,u[1]=void 0===u[1]||u[1]),l.generateVertexShader(c,u,g),a.litOptions.shadingModel===s?(a.litOptions.fresnelModel=0,a.litOptions.ambientSH=!1):a.litOptions.fresnelModel=0===a.litOptions.fresnelModel?p:a.litOptions.fresnelModel;const S=new o,m=new o,M=new o,_=new o;let A="";if(a.litOptions.nineSlicedMode===t?S.append("const float textureBias = -1000.0;"):S.append("uniform float textureBias;"),n){if(a.heightMap&&(S.append("vec2 dUvOffset;"),m.append(this._addMap("height","parallaxPS",a,l.chunks,f)),M.append("getParallax();")),a.litOptions.blendType!==i||a.litOptions.alphaTest||a.litOptions.alphaToCoverage?(S.append("float dAlpha;"),m.append(this._addMap("opacity","opacityPS",a,l.chunks,f)),M.append("getOpacity();"),_.append("_litShaderArgs.opacity = dAlpha;"),a.litOptions.alphaTest&&(m.append(l.chunks.alphaTestPS),M.append("alphaTest(dAlpha);"))):S.append("float dAlpha = 1.0;"),l.needsNormal){if((a.normalMap||a.clearCoatNormalMap)&&(m.append(a.packedNormal?l.chunks.normalXYPS:l.chunks.normalXYZPS),!a.litOptions.hasTangents)){const e=a.normalMap?"normalMap":"clearCoatNormalMap";A=this._getUvSourceExpression(`${e}Transform`,`${e}Uv`,a)}S.append("vec3 dNormalW;"),m.append(this._addMap("normalDetail","normalDetailMapPS",a,l.chunks,f)),m.append(this._addMap("normal","normalMapPS",a,l.chunks,f)),M.append("getNormal();"),_.append("_litShaderArgs.worldNormal = dNormalW;")}if(l.needsSceneColor&&S.append("uniform sampler2D uSceneColorMap;"),l.needsScreenSize&&S.append("uniform vec4 uScreenSize;"),l.needsTransforms&&(S.append("uniform mat4 matrix_viewProjection;"),S.append("uniform mat4 matrix_model;")),S.append("vec3 dAlbedo;"),a.diffuseDetail&&m.append(this._addMap("diffuseDetail","diffuseDetailMapPS",a,l.chunks,f,a.diffuseDetailEncoding)),m.append(this._addMap("diffuse","diffusePS",a,l.chunks,f,a.diffuseEncoding)),M.append("getAlbedo();"),_.append("_litShaderArgs.albedo = dAlbedo;"),a.litOptions.useRefraction&&(S.append("float dTransmission;"),m.append(this._addMap("refraction","transmissionPS",a,l.chunks,f)),M.append("getRefraction();"),_.append("_litShaderArgs.transmission = dTransmission;"),S.append("float dThickness;"),m.append(this._addMap("thickness","thicknessPS",a,l.chunks,f)),M.append("getThickness();"),_.append("_litShaderArgs.thickness = dThickness;")),a.litOptions.useIridescence&&(S.append("float dIridescence;"),m.append(this._addMap("iridescence","iridescencePS",a,l.chunks,f)),M.append("getIridescence();"),_.append("_litShaderArgs.iridescence.intensity = dIridescence;"),S.append("float dIridescenceThickness;"),m.append(this._addMap("iridescenceThickness","iridescenceThicknessPS",a,l.chunks,f)),M.append("getIridescenceThickness();"),_.append("_litShaderArgs.iridescence.thickness = dIridescenceThickness;")),l.lighting&&a.litOptions.useSpecular||l.reflections?(S.append("vec3 dSpecularity;"),S.append("float dGlossiness;"),a.litOptions.useSheen&&(S.append("vec3 sSpecularity;"),m.append(this._addMap("sheen","sheenPS",a,l.chunks,f,a.sheenEncoding)),M.append("getSheen();"),_.append("_litShaderArgs.sheen.specularity = sSpecularity;"),S.append("float sGlossiness;"),m.append(this._addMap("sheenGloss","sheenGlossPS",a,l.chunks,f)),M.append("getSheenGlossiness();"),_.append("_litShaderArgs.sheen.gloss = sGlossiness;")),a.litOptions.useMetalness&&(S.append("float dMetalness;"),m.append(this._addMap("metalness","metalnessPS",a,l.chunks,f)),M.append("getMetalness();"),_.append("_litShaderArgs.metalness = dMetalness;")),a.litOptions.useSpecularityFactor&&(S.append("float dSpecularityFactor;"),m.append(this._addMap("specularityFactor","specularityFactorPS",a,l.chunks,f)),M.append("getSpecularityFactor();"),_.append("_litShaderArgs.specularityFactor = dSpecularityFactor;")),a.litOptions.useSpecularColor?m.append(this._addMap("specular","specularPS",a,l.chunks,f,a.specularEncoding)):m.append("void getSpecularity() { dSpecularity = vec3(1); }"),m.append(this._addMap("gloss","glossPS",a,l.chunks,f)),M.append("getGlossiness();"),M.append("getSpecularity();"),_.append("_litShaderArgs.specularity = dSpecularity;"),_.append("_litShaderArgs.gloss = dGlossiness;")):(S.append("vec3 dSpecularity = vec3(0.0);"),S.append("float dGlossiness = 0.0;")),(a.aoMap||a.aoVertexColor)&&(S.append("float dAo;"),m.append(this._addMap("ao","aoPS",a,l.chunks,f)),M.append("getAO();"),_.append("_litShaderArgs.ao = dAo;")),S.append("vec3 dEmission;"),m.append(this._addMap("emissive","emissivePS",a,l.chunks,f,a.emissiveEncoding)),M.append("getEmission();"),_.append("_litShaderArgs.emission = dEmission;"),a.litOptions.useClearCoat&&(S.append("float ccSpecularity;"),S.append("float ccGlossiness;"),S.append("vec3 ccNormalW;"),m.append(this._addMap("clearCoat","clearCoatPS",a,l.chunks,f)),m.append(this._addMap("clearCoatGloss","clearCoatGlossPS",a,l.chunks,f)),m.append(this._addMap("clearCoatNormal","clearCoatNormalPS",a,l.chunks,f)),M.append("getClearCoat();"),M.append("getClearCoatGlossiness();"),M.append("getClearCoatNormal();"),_.append("_litShaderArgs.clearcoat.specularity = ccSpecularity;"),_.append("_litShaderArgs.clearcoat.gloss = ccGlossiness;"),_.append("_litShaderArgs.clearcoat.worldNormal = ccNormalW;")),a.lightMap||a.lightVertexColor){const e=a.dirLightMap&&a.litOptions.useSpecular,n=e?"lightmapDirPS":"lightmapSinglePS";S.append("vec3 dLightmap;"),e&&S.append("vec3 dLightmapDir;"),m.append(this._addMap("light",n,a,l.chunks,f,a.lightMapEncoding)),M.append("getLightMap();"),_.append("_litShaderArgs.lightmap = dLightmap;"),e&&_.append("_litShaderArgs.lightmapDir = dLightmapDir;")}-1===m.code.indexOf("texture2DSRGB")&&-1===m.code.indexOf("texture2DRGBM")&&-1===m.code.indexOf("texture2DRGBE")||m.prepend(l.chunks.textureSamplePS)}else a.litOptions.alphaTest&&(S.append("float dAlpha;"),m.append(this._addMap("opacity","opacityPS",a,l.chunks,f)),m.append(l.chunks.alphaTestPS),M.append("getOpacity();"),M.append("alphaTest(dAlpha);"),_.append("_litShaderArgs.opacity = dAlpha;"));S.append(l.chunks.litShaderArgsPS),m.append(`LitShaderArguments evaluateFrontend() { LitShaderArguments _litShaderArgs; \n${M.code}\n${_.code}\n return _litShaderArgs;\n }\n`),M.code="LitShaderArguments litShaderArgs = evaluateFrontend();";for(const e in f)S.append(`uniform sampler2D ${f[e]};`);return M.code=`\n${M.code.split("\n").map((e=>`    ${e}`)).join("\n")}\n\n`,l.generateFragmentShader(S.code,m.code,M.code,A),l.getDefinition()}};export{h as _matTex2D,u as standard};
