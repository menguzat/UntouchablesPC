import"../../core/time.js";import"../../core/debug.js";import{Vec3 as t}from"../../core/math/vec3.js";import{Color as e}from"../../core/math/color.js";import{RenderPass as s}from"../../platform/graphics/render-pass.js";import{LIGHTSHAPE_PUNCTUAL as i,LIGHTTYPE_OMNI as a,LIGHTTYPE_SPOT as o,LIGHTTYPE_DIRECTIONAL as r,FOG_NONE as h,FOG_LINEAR as n,LAYERID_DEPTH as l,COMPUPDATED_LIGHTS as d}from"../constants.js";import{Renderer as c}from"./renderer.js";import{LightCamera as g}from"./light-camera.js";import"../lighting/world-clusters-debug.js";import{SceneGrab as u}from"../graphics/scene-grab.js";import{BlendState as f}from"../../platform/graphics/blend-state.js";const m=new e(254/255,254/255,254/255,254/255),p={drawCalls:[],isNewMaterial:[],lightMaskChanged:[],clear:function(){this.drawCalls.length=0,this.isNewMaterial.length=0,this.lightMaskChanged.length=0}};class _ extends c{constructor(t){super(t);const e=this.device;this._forwardDrawCalls=0,this._materialSwitches=0,this._depthMapTime=0,this._forwardTime=0,this._sortTime=0;const s=e.scope;this.fogColorId=s.resolve("fog_color"),this.fogStartId=s.resolve("fog_start"),this.fogEndId=s.resolve("fog_end"),this.fogDensityId=s.resolve("fog_density"),this.ambientId=s.resolve("light_globalAmbient"),this.skyboxIntensityId=s.resolve("skyboxIntensity"),this.cubeMapRotationMatrixId=s.resolve("cubeMapRotationMatrix"),this.lightColorId=[],this.lightDir=[],this.lightDirId=[],this.lightShadowMapId=[],this.lightShadowMatrixId=[],this.lightShadowParamsId=[],this.lightShadowIntensity=[],this.lightRadiusId=[],this.lightPos=[],this.lightPosId=[],this.lightWidth=[],this.lightWidthId=[],this.lightHeight=[],this.lightHeightId=[],this.lightInAngleId=[],this.lightOutAngleId=[],this.lightCookieId=[],this.lightCookieIntId=[],this.lightCookieMatrixId=[],this.lightCookieOffsetId=[],this.shadowMatrixPaletteId=[],this.shadowCascadeDistancesId=[],this.shadowCascadeCountId=[],this.screenSizeId=s.resolve("uScreenSize"),this._screenSize=new Float32Array(4),this.fogColor=new Float32Array(3),this.ambientColor=new Float32Array(3)}destroy(){super.destroy()}dispatchGlobalLights(t){if(this.ambientColor[0]=t.ambientLight.r,this.ambientColor[1]=t.ambientLight.g,this.ambientColor[2]=t.ambientLight.b,t.gammaCorrection)for(let t=0;t<3;t++)this.ambientColor[t]=Math.pow(this.ambientColor[t],2.2);if(t.physicalUnits)for(let e=0;e<3;e++)this.ambientColor[e]*=t.ambientLuminance;this.ambientId.setValue(this.ambientColor),this.skyboxIntensityId.setValue(t.physicalUnits?t.skyboxLuminance:t.skyboxIntensity),this.cubeMapRotationMatrixId.setValue(t._skyboxRotationMat3.data)}_resolveLight(t,e){const s="light"+e;this.lightColorId[e]=t.resolve(s+"_color"),this.lightDir[e]=new Float32Array(3),this.lightDirId[e]=t.resolve(s+"_direction"),this.lightShadowMapId[e]=t.resolve(s+"_shadowMap"),this.lightShadowMatrixId[e]=t.resolve(s+"_shadowMatrix"),this.lightShadowParamsId[e]=t.resolve(s+"_shadowParams"),this.lightShadowIntensity[e]=t.resolve(s+"_shadowIntensity"),this.lightRadiusId[e]=t.resolve(s+"_radius"),this.lightPos[e]=new Float32Array(3),this.lightPosId[e]=t.resolve(s+"_position"),this.lightWidth[e]=new Float32Array(3),this.lightWidthId[e]=t.resolve(s+"_halfWidth"),this.lightHeight[e]=new Float32Array(3),this.lightHeightId[e]=t.resolve(s+"_halfHeight"),this.lightInAngleId[e]=t.resolve(s+"_innerConeAngle"),this.lightOutAngleId[e]=t.resolve(s+"_outerConeAngle"),this.lightCookieId[e]=t.resolve(s+"_cookie"),this.lightCookieIntId[e]=t.resolve(s+"_cookieIntensity"),this.lightCookieMatrixId[e]=t.resolve(s+"_cookieMatrix"),this.lightCookieOffsetId[e]=t.resolve(s+"_cookieOffset"),this.shadowMatrixPaletteId[e]=t.resolve(s+"_shadowMatrixPalette[0]"),this.shadowCascadeDistancesId[e]=t.resolve(s+"_shadowCascadeDistances[0]"),this.shadowCascadeCountId[e]=t.resolve(s+"_shadowCascadeCount")}setLTCDirectionalLight(e,s,i,a,o){this.lightPos[s][0]=a.x-i.x*o,this.lightPos[s][1]=a.y-i.y*o,this.lightPos[s][2]=a.z-i.z*o,this.lightPosId[s].setValue(this.lightPos[s]);const r=e.transformVector(new t(-.5,0,0));this.lightWidth[s][0]=r.x*o,this.lightWidth[s][1]=r.y*o,this.lightWidth[s][2]=r.z*o,this.lightWidthId[s].setValue(this.lightWidth[s]);const h=e.transformVector(new t(0,0,.5));this.lightHeight[s][0]=h.x*o,this.lightHeight[s][1]=h.y*o,this.lightHeight[s][2]=h.z*o,this.lightHeightId[s].setValue(this.lightHeight[s])}dispatchDirectLights(t,e,s,a){let o=0;const r=this.device.scope;for(let h=0;h<t.length;h++){if(!(t[h].mask&s))continue;const n=t[h],l=n._node.getWorldTransform();if(this.lightColorId[o]||this._resolveLight(r,o),this.lightColorId[o].setValue(e.gammaCorrection?n._linearFinalColor:n._finalColor),l.getY(n._direction).mulScalar(-1),n._direction.normalize(),this.lightDir[o][0]=n._direction.x,this.lightDir[o][1]=n._direction.y,this.lightDir[o][2]=n._direction.z,this.lightDirId[o].setValue(this.lightDir[o]),n.shape!==i&&this.setLTCDirectionalLight(l,o,n._direction,a._node.getPosition(),a.farClip),n.castShadows){const t=n.getRenderData(a,0),e=n._getUniformBiasValues(t);this.lightShadowMapId[o].setValue(t.shadowBuffer),this.lightShadowMatrixId[o].setValue(t.shadowMatrix.data),this.shadowMatrixPaletteId[o].setValue(n._shadowMatrixPalette),this.shadowCascadeDistancesId[o].setValue(n._shadowCascadeDistances),this.shadowCascadeCountId[o].setValue(n.numCascades),this.lightShadowIntensity[o].setValue(n.shadowIntensity);const s=n._shadowRenderParams;s.length=3,s[0]=n._shadowResolution,s[1]=e.normalBias,s[2]=e.bias,this.lightShadowParamsId[o].setValue(s)}o++}return o}setLTCPositionalLight(e,s){const i=e.transformVector(new t(-.5,0,0));this.lightWidth[s][0]=i.x,this.lightWidth[s][1]=i.y,this.lightWidth[s][2]=i.z,this.lightWidthId[s].setValue(this.lightWidth[s]);const a=e.transformVector(new t(0,0,.5));this.lightHeight[s][0]=a.x,this.lightHeight[s][1]=a.y,this.lightHeight[s][2]=a.z,this.lightHeightId[s].setValue(this.lightHeight[s])}dispatchOmniLight(t,e,s,a){const o=s._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(e,a),this.lightRadiusId[a].setValue(s.attenuationEnd),this.lightColorId[a].setValue(t.gammaCorrection?s._linearFinalColor:s._finalColor),o.getTranslation(s._position),this.lightPos[a][0]=s._position.x,this.lightPos[a][1]=s._position.y,this.lightPos[a][2]=s._position.z,this.lightPosId[a].setValue(this.lightPos[a]),s.shape!==i&&this.setLTCPositionalLight(o,a),s.castShadows){const t=s.getRenderData(null,0);this.lightShadowMapId[a].setValue(t.shadowBuffer);const e=s._getUniformBiasValues(t),i=s._shadowRenderParams;i.length=4,i[0]=s._shadowResolution,i[1]=e.normalBias,i[2]=e.bias,i[3]=1/s.attenuationEnd,this.lightShadowParamsId[a].setValue(i),this.lightShadowIntensity[a].setValue(s.shadowIntensity)}s._cookie&&(this.lightCookieId[a].setValue(s._cookie),this.lightShadowMatrixId[a].setValue(o.data),this.lightCookieIntId[a].setValue(s.cookieIntensity))}dispatchSpotLight(t,e,s,a){const o=s._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(e,a),this.lightInAngleId[a].setValue(s._innerConeAngleCos),this.lightOutAngleId[a].setValue(s._outerConeAngleCos),this.lightRadiusId[a].setValue(s.attenuationEnd),this.lightColorId[a].setValue(t.gammaCorrection?s._linearFinalColor:s._finalColor),o.getTranslation(s._position),this.lightPos[a][0]=s._position.x,this.lightPos[a][1]=s._position.y,this.lightPos[a][2]=s._position.z,this.lightPosId[a].setValue(this.lightPos[a]),s.shape!==i&&this.setLTCPositionalLight(o,a),o.getY(s._direction).mulScalar(-1),s._direction.normalize(),this.lightDir[a][0]=s._direction.x,this.lightDir[a][1]=s._direction.y,this.lightDir[a][2]=s._direction.z,this.lightDirId[a].setValue(this.lightDir[a]),s.castShadows){const t=s.getRenderData(null,0);this.lightShadowMapId[a].setValue(t.shadowBuffer),this.lightShadowMatrixId[a].setValue(t.shadowMatrix.data);const e=s._getUniformBiasValues(t),i=s._shadowRenderParams;i.length=4,i[0]=s._shadowResolution,i[1]=e.normalBias,i[2]=e.bias,i[3]=1/s.attenuationEnd,this.lightShadowParamsId[a].setValue(i),this.lightShadowIntensity[a].setValue(s.shadowIntensity)}if(s._cookie){if(!s.castShadows){const t=g.evalSpotCookieMatrix(s);this.lightShadowMatrixId[a].setValue(t.data)}this.lightCookieId[a].setValue(s._cookie),this.lightCookieIntId[a].setValue(s.cookieIntensity),s._cookieTransform&&(s._cookieTransformUniform[0]=s._cookieTransform.x,s._cookieTransformUniform[1]=s._cookieTransform.y,s._cookieTransformUniform[2]=s._cookieTransform.z,s._cookieTransformUniform[3]=s._cookieTransform.w,this.lightCookieMatrixId[a].setValue(s._cookieTransformUniform),s._cookieOffsetUniform[0]=s._cookieOffset.x,s._cookieOffsetUniform[1]=s._cookieOffset.y,this.lightCookieOffsetId[a].setValue(s._cookieOffsetUniform))}}dispatchLocalLights(t,e,s,i,r){let h=i;const n=this.device.scope,l=t[a],d=l.length;for(let t=0;t<d;t++){const i=l[t];i.mask&s&&(i.isStatic||(this.dispatchOmniLight(e,n,i,h),h++))}let c=0;if(r){let t=r[c];for(;t&&t._type===a;)this.dispatchOmniLight(e,n,t,h),h++,c++,t=r[c]}const g=t[o],u=g.length;for(let t=0;t<u;t++){const i=g[t];i.mask&s&&(i.isStatic||(this.dispatchSpotLight(e,n,i,h),h++))}if(r){let t=r[c];for(;t&&t._type===o;)this.dispatchSpotLight(e,n,t,h),h++,c++,t=r[c]}}renderForwardPrepareMaterials(t,e,s,i,a,o,r){const h=(t,e,s)=>{p.drawCalls.push(t),p.isNewMaterial.push(e),p.lightMaskChanged.push(s)};p.clear();const n=this.device,l=this.scene,d=o?o._lightHash:0;let c,g,u,f=null;for(let t=0;t<s;t++){const s=e[t];if(!a||!s.mask||a&s.mask)if(s.command)h(s,!1,!1);else{s.ensureMaterial(n);const t=s.material,e=s._shaderDefs,a=s.mask;if(t&&t===f&&e!==c&&(f=null),(s.isStatic||g)&&(f=null),t!==f&&(this._materialSwitches++,t._scene=l,t.dirty&&(t.updateUniforms(n,l),t.dirty=!1),t._dirtyBlend&&(l.layers._dirtyBlend=!0)),!s._shader[r]||s._shaderDefs!==e||s._lightHash!==d){if(s.isStatic)s.updatePassShader(l,r,s._staticLightList,i,this.viewUniformFormat,this.viewBindGroupFormat);else{const a=r+"_"+e+"_"+d;s._shader[r]=t.variants[a],s._shader[r]||(s.updatePassShader(l,r,null,i,this.viewUniformFormat,this.viewBindGroupFormat),t.variants[a]=s._shader[r])}s._lightHash=d}h(s,t!==f,!f||a!==u),f=t,c=e,u=a,g=s.isStatic}}return null==n.endShaderBatch||n.endShaderBatch(),p}renderForwardInternal(t,e,s,i,a,o){const h=this.device,n=this.scene,l=1<<i,d=o?-1:1;let c=!1;const g=e.drawCalls.length;for(let o=0;o<g;o++){const m=e.drawCalls[o];if(m.command)m.command();else{var u,f;const p=e.isNewMaterial[o],_=e.lightMaskChanged[o],w=m.material;m._shaderDefs;const C=m.mask;if(p){const e=m._shader[i];if(!e.failed&&h.setShader(e),c=e.failed,c)break;if(w.setParameters(h),_){const e=this.dispatchDirectLights(s[r],n,C,t);this.dispatchLocalLights(s,n,C,e,m._staticLightList)}this.alphaTestId.setValue(w.alphaTest),h.setBlendState(w.blendState),h.setDepthState(w.depthState),h.setAlphaToCoverage(w.alphaToCoverage),w.depthBias||w.slopeDepthBias?(h.setDepthBias(!0),h.setDepthBiasValues(w.depthBias,w.slopeDepthBias)):h.setDepthBias(!1)}this.setupCullMode(t._cullFaces,d,m);const I=null!=(u=m.stencilFront)?u:w.stencilFront,S=null!=(f=m.stencilBack)?f:w.stencilBack;h.setStencilState(I,S);const P=m.mesh;m.setParameters(h,l),this.setVertexBuffers(h,P),this.setMorphing(h,m.morphInstance),this.setSkinning(h,m),this.setupMeshUniformBuffers(m,i);const v=m.renderStyle;if(h.setIndexBuffer(P.indexBuffer[v]),null==a||a(m,o),t.xr&&t.xr.session&&t.xr.views.length){const e=t.xr.views;for(let t=0;t<e.length;t++){const s=e[t];h.setViewport(s.viewport.x,s.viewport.y,s.viewport.z,s.viewport.w),this.projId.setValue(s.projMat.data),this.projSkyboxId.setValue(s.projMat.data),this.viewId.setValue(s.viewOffMat.data),this.viewInvId.setValue(s.viewInvOffMat.data),this.viewId3.setValue(s.viewMat3.data),this.viewProjId.setValue(s.projViewOffMat.data),this.viewPosId.setValue(s.position),0===t?this.drawInstance(h,m,P,v,!0):this.drawInstance2(h,m,P,v),this._forwardDrawCalls++}}else this.drawInstance(h,m,P,v,!0),this._forwardDrawCalls++;o<g-1&&!e.isNewMaterial[o+1]&&w.setParameters(h,m.parameters)}}}renderForward(t,e,s,i,a,o,r,h,n){const l=this.renderForwardPrepareMaterials(t,e,s,i,o,h,a);this.renderForwardInternal(t,l,i,a,r,n),p.clear()}setSceneConstants(){const t=this.scene;if(this.dispatchGlobalLights(t),t.fog!==h){if(this.fogColor[0]=t.fogColor.r,this.fogColor[1]=t.fogColor.g,this.fogColor[2]=t.fogColor.b,t.gammaCorrection)for(let t=0;t<3;t++)this.fogColor[t]=Math.pow(this.fogColor[t],2.2);this.fogColorId.setValue(this.fogColor),t.fog===n?(this.fogStartId.setValue(t.fogStart),this.fogEndId.setValue(t.fogEnd)):this.fogDensityId.setValue(t.fogDensity)}const e=this.device;this._screenSize[0]=e.width,this._screenSize[1]=e.height,this._screenSize[2]=1/e.width,this._screenSize[3]=1/e.height,this.screenSizeId.setValue(this._screenSize)}updateLightStats(t,e){}buildFrameGraph(t,e){const i=this.scene.clusteredLightingEnabled;if(t.reset(),this.update(e),i){{const i=new s(this.device,(()=>{this.scene.lighting.cookiesEnabled&&(this.renderCookies(e._splitLights[o]),this.renderCookies(e._splitLights[a]))}));i.requiresCubemaps=!1,t.addRenderPass(i)}{const i=new s(this.device);if(i.requiresCubemaps=!1,t.addRenderPass(i),this.scene.lighting.shadowsEnabled){const t=e._splitLights;this._shadowRendererLocal.prepareClusteredRenderPass(i,t[o],t[a])}i.after=()=>{this.updateClusters(e)}}}else{const s=e._splitLights;this._shadowRendererLocal.buildNonClusteredRenderPasses(t,s[o],s[a])}let r=0,h=!0,n=null;const d=e._renderActions;for(let i=r;i<d.length;i++){const a=d[i],o=e.layerList[a.layerIndex],c=o.cameras[a.cameraIndex];if(!a.isLayerEnabled(e))continue;const g=o.id===l&&(c.renderSceneColorMap||c.renderSceneDepthMap);a.hasDirectionalShadowLights&&c&&this._shadowRendererDirectional.buildFrameGraph(t,a,c),h&&(h=!1,r=i,n=a.renderTarget);let u=i+1;for(;d[u]&&!d[u].isLayerEnabled(e);)u++;const f=d[u],m=!!f&&e.layerList[f.layerIndex].id===l&&(c.renderSceneColorMap||c.renderSceneDepthMap);if(!f||f.renderTarget!==n||f.hasDirectionalShadowLights||m||g){if(this.addMainRenderPass(t,e,n,r,i,g),a.triggerPostprocess&&null!=c&&c.onPostprocessing){const i=new s(this.device,(()=>{this.renderPassPostprocessing(a,e)}));i.requiresCubemaps=!1,t.addRenderPass(i)}h=!0}}}addMainRenderPass(t,e,i,a,o,r){const h={start:a,end:o},n=new s(this.device,(()=>{this.renderPassRenderActions(e,h)})),l=e._renderActions,d=l[a],c=l[o],g=e.layerList[d.layerIndex].cameras[d.cameraIndex];g&&(d.firstCameraUse&&g.onPreRender&&(n.before=()=>{g.onPreRender()}),c.lastCameraUse&&g.onPostRender&&(n.after=()=>{g.onPostRender()}));const f=r&&u.requiresRenderPass(this.device,g);(!r||f)&&(n.init(i),n.fullSizeClearRect=g.camera.fullSizeClearRect,f?(n.setClearColor(m),n.setClearDepth(1)):n.fullSizeClearRect&&(d.clearColor&&n.setClearColor(g.camera.clearColor),d.clearDepth&&n.setClearDepth(g.camera.clearDepth),d.clearStencil&&n.setClearStencil(g.camera.clearStencil))),t.addRenderPass(n)}update(t){this.frameUpdate(),this.shadowRenderer.frameUpdate();const e=this.scene.clusteredLightingEnabled;this.scene._updateSky(this.device);const s=this.updateLayerComposition(t,e),i=0!=(s&d);this.updateLightStats(t,s),this.beginFrame(t,i),this.setSceneConstants(),this.cullComposition(t),this.gpuUpdate(t._meshInstances)}renderPassPostprocessing(t,e){e.layerList[t.layerIndex].cameras[t.cameraIndex].onPostprocessing()}renderPassRenderActions(t,e){const s=t._renderActions;for(let i=e.start;i<=e.end;i++)this.renderRenderAction(t,s[i],i===e.start)}renderRenderAction(t,e,s){const i=this.scene.clusteredLightingEnabled,a=this.device,o=e.layerIndex,r=t.layerList[o],h=t.subLayerList[o],n=e.cameraIndex,l=r.cameras[n];if(e.isLayerEnabled(t)){if(!h&&r.onPreRenderOpaque?r.onPreRenderOpaque(n):h&&r.onPreRenderTransparent&&r.onPreRenderTransparent(n),r._preRenderCalledForCameras&1<<n||(r.onPreRender&&r.onPreRender(n),r._preRenderCalledForCameras|=1<<n),l){var d,c,g;this.setupViewport(l.camera,e.renderTarget),s&&l.camera.fullSizeClearRect||this.clear(l.camera,e.clearColor,e.clearDepth,e.clearStencil),r._sortVisible(h,l.camera.node,n);const t=r.instances,o=h?t.visibleTransparent[n]:t.visibleOpaque[n];this.scene.immediate.onPreRenderLayer(r,o,h),i&&e.lightClusters&&(e.lightClusters.activate(this.lightTextureAtlas),this.clustersDebugRendered||this.scene.lighting.debugLayer!==r.id||(this.clustersDebugRendered=!0)),this.scene._activeCamera=l.camera;const u=this.setCameraUniforms(l.camera,e.renderTarget);a.supportsUniformBuffers&&this.setupViewUniformBuffers(e.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,u);const m=!!(l.camera._flipFaces^(null==e||null==(d=e.renderTarget)?void 0:d.flipY)),p=null!=(c=null==(g=l.camera.shaderPassInfo)?void 0:g.index)?c:r.shaderPass,_=this._forwardDrawCalls;this.renderForward(l.camera,o.list,o.length,r._splitLights,p,r.cullingMask,r.onDrawCall,r,m),r._forwardDrawCalls+=this._forwardDrawCalls-_,a.setBlendState(f.DEFAULT),a.setStencilState(null,null),a.setAlphaToCoverage(!1),a.setDepthBias(!1)}!h&&r.onPostRenderOpaque?r.onPostRenderOpaque(n):h&&r.onPostRenderTransparent&&r.onPostRenderTransparent(n),!r.onPostRender||r._postRenderCalledForCameras&1<<n||(r._postRenderCounter&=~(h?2:1),0===r._postRenderCounter&&(r.onPostRender(n),r._postRenderCalledForCameras|=1<<n,r._postRenderCounter=r._postRenderCounterMax))}}}export{_ as ForwardRenderer};
