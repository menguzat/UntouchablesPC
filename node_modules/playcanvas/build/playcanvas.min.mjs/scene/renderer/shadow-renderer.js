import"../../core/debug.js";import"../../core/time.js";import{Color as e}from"../../core/math/color.js";import{Mat4 as t}from"../../core/math/mat4.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Vec4 as r}from"../../core/math/vec4.js";import{UNIFORMTYPE_MAT4 as i,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as a,SHADERSTAGE_VERTEX as o,SHADERSTAGE_FRAGMENT as h}from"../../platform/graphics/constants.js";import{drawQuadWithShader as n}from"../graphics/quad-render-utils.js";import{SHADOW_VSM8 as d,SHADOW_VSM32 as l,SHADOW_PCF5 as p,SHADOW_PCF3 as c,LIGHTTYPE_OMNI as u,LIGHTTYPE_DIRECTIONAL as f,SORTKEY_DEPTH as m,SHADOWUPDATE_NONE as w,SHADOWUPDATE_THISFRAME as g,BLUR_GAUSSIAN as S,SHADER_SHADOW as V}from"../constants.js";import{ShaderPass as b}from"../shader-pass.js";import{shaderChunks as v}from"../shader-lib/chunks/chunks.js";import{createShaderFromCode as y}from"../shader-lib/utils.js";import{LightCamera as B}from"./light-camera.js";import{UniformBufferFormat as C,UniformFormat as _}from"../../platform/graphics/uniform-buffer-format.js";import{BindGroupFormat as P,BindBufferFormat as O}from"../../platform/graphics/bind-group-format.js";import{BlendState as M}from"../../platform/graphics/blend-state.js";import{DepthState as U}from"../../platform/graphics/depth-state.js";function D(e,t){return Math.exp(-e*e/(2*t*t))}const F=new t,j=new t,x=new Float32Array(2),R=new r(1,1,0,0),I={r:1,g:2,b:3,a:4},T=new t;function W(e){const t=e.material,s=e.skinInstance?10:0;let r=0;if(t.opacityMap){const e=t.opacityMapChannel;e&&(r=I[e])}return s+r}class k{constructor(e,t){this.shadowPassCache=[],this.device=e.device,this.renderer=e,this.lightTextureAtlas=t;const s=this.device.scope;this.polygonOffsetId=s.resolve("polygonOffset"),this.polygonOffset=new Float32Array(2),this.sourceId=s.resolve("source"),this.pixelOffsetId=s.resolve("pixelOffset"),this.weightId=s.resolve("weight[0]"),this.blurVsmShaderCode=[v.blurVSMPS,"#define GAUSS\n"+v.blurVSMPS];const r="#define PACKED\n";this.blurPackedVsmShaderCode=[r+this.blurVsmShaderCode[0],r+this.blurVsmShaderCode[1]],this.blurVsmShader=[{},{}],this.blurPackedVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=s.resolve("light_radius"),this.viewUniformFormat=null,this.viewBindGroupFormat=null,this.blendStateWrite=new M,this.blendStateNoWrite=new M,this.blendStateNoWrite.setColorWrite(!1,!1,!1,!1)}static createShadowCamera(t,s,r,i){const a=B.create("ShadowCamera",r,i);return a.clearColor=s>=d&&s<=l?new e(0,0,0,0):new e(1,1,1,1),a.clearDepthBuffer=!0,a.clearStencilBuffer=!1,a}static setShadowCameraSettings(e,t,s,r,i){let a=s===p||s===c&&t.supportsDepthShadow;r!==u||i||(a=!1),e.clearColorBuffer=!a}cullShadowCasters(e,t,s){let r=0;const i=e.length;for(let a=0;a<i;a++){const i=e[a];i.castShadow&&(i.cull&&!i._isVisible(s)||(i.visibleThisFrame=!0,t[r]=i,r++))}t.length=r,t.sort(this.renderer.sortCompareDepth)}setupRenderState(e,t){const s=this.renderer.scene.clusteredLightingEnabled;e.webgl2||e.isWebGPU?t._type!==u||s?(e.setDepthBias(!0),e.setDepthBiasValues(-1e3*t.shadowBias,-1e3*t.shadowBias)):e.setDepthBias(!1):e.extStandardDerivatives&&(t._type===u?(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset)):(this.polygonOffset[0]=-1e3*t.shadowBias,this.polygonOffset[1]=-1e3*t.shadowBias,this.polygonOffsetId.setValue(this.polygonOffset)));const r=e.webgl2||e.isWebGPU,i=s?t._isPcf&&r:t._isPcf&&r&&t._type!==u;e.setBlendState(i?this.blendStateNoWrite:this.blendStateWrite),e.setDepthState(U.DEFAULT),e.setStencilState(null,null)}restoreRenderState(e){e.webgl2||e.isWebGPU?e.setDepthBias(!1):e.extStandardDerivatives&&(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset))}dispatchUniforms(e,t,r,i){const a=t._node;e._type!==f&&(this.renderer.dispatchViewPos(a.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),F.setTRS(a.getPosition(),a.getRotation(),s.ONE).invert(),j.mul2(t.projectionMatrix,F);const o=r.shadowViewport;t.rect=o,t.scissorRect=r.shadowScissor,T.setViewport(o.x,o.y,o.z,o.w),r.shadowMatrix.mul2(T,j),e._type===f&&e._shadowMatrixPalette.set(r.shadowMatrix.data,16*i)}getShadowPass(e){var t;const s=e._type,r=e._shadowType;let i=null==(t=this.shadowPassCache[s])?void 0:t[r];if(!i){const e=`ShadowPass_${s}_${r}`;i=b.get(this.device).allocate(e,{isShadow:!0,lightType:s,shadowType:r}),this.shadowPassCache[s]||(this.shadowPassCache[s]=[]),this.shadowPassCache[s][r]=i}return i.index}submitCasters(e,t){const s=this.device,r=this.renderer,i=r.scene,a=1<<V,o=this.getShadowPass(t),h=e.length;for(let t=0;t<h;t++){const h=e[t],n=h.mesh;h.ensureMaterial(s);const d=h.material;r.setBaseConstants(s,d),r.setSkinning(s,h),d.dirty&&(d.updateUniforms(s,i),d.dirty=!1),d.chunks&&(r.setupCullMode(!0,1,h),d.setParameters(s),h.setParameters(s,a));let l=h._shader[o];l||(h.updatePassShader(i,o,null,null,this.viewUniformFormat,this.viewBindGroupFormat),l=h._shader[o],h._key[m]=W(h)),!l.failed&&s.setShader(l),r.setVertexBuffers(s,n),r.setMorphing(s,h.morphInstance),this.renderer.setupMeshUniformBuffers(h,o);const p=h.renderStyle;s.setIndexBuffer(n.indexBuffer[p]),r.drawInstance(s,h,n,p),r._shadowDrawCalls++}}needsShadowRendering(e){const t=e.enabled&&e.castShadows&&e.shadowUpdateMode!==w&&e.visibleThisFrame;return e.shadowUpdateMode===g&&(e.shadowUpdateMode=w),t&&(this.renderer._shadowMapUpdates+=e.numShadowFaces),t}getLightRenderData(e,t,s){return e.getRenderData(e._type===f?t:null,s)}setupRenderPass(e,t,s){const r=t.renderTarget;e.init(r),e.depthStencilOps.clearDepthValue=1,e.depthStencilOps.clearDepth=s,r.depthBuffer?e.depthStencilOps.storeDepth=!0:(e.colorOps.clearValue.copy(t.clearColor),e.colorOps.clear=s,e.depthStencilOps.storeDepth=!1),e.requiresCubemaps=!1}prepareFace(e,t,s){const r=e._type,i=e._shadowType,a=this.renderer.scene.clusteredLightingEnabled,o=this.getLightRenderData(e,t,s).shadowCamera;k.setShadowCameraSettings(o,this.device,i,r,a);const h=r===f?0:s;return o.renderTarget=e._shadowMap.renderTargets[h],o}renderFace(e,t,s,r,i=!0){const a=this.device,o=this.getLightRenderData(e,t,s),h=o.shadowCamera;this.dispatchUniforms(e,h,o,s);const n=h.renderTarget,d=this.renderer;d.setCameraUniforms(h,n),a.supportsUniformBuffers&&d.setupViewUniformBuffers(o.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,1),i?(d.setupViewport(h,n),r&&d.clear(h)):d.clearView(h,n,!0,!1),this.setupRenderState(a,e),this.submitCasters(o.visibleCasters,e),this.restoreRenderState(a)}render(e,t,s=!0){if(this.needsShadowRendering(e)){const r=e.numShadowFaces;for(let i=0;i<r;i++)this.prepareFace(e,t,i),this.renderFace(e,t,i,!0,s);this.renderVsm(e,t)}}renderVsm(e,t){if(e._isVsm&&e._vsmBlurSize>1){this.renderer.scene.clusteredLightingEnabled&&e._type!==f||this.applyVsmBlur(e,t)}}getVsmBlurShader(e,t,s){let r=(e?this.blurPackedVsmShader:this.blurVsmShader)[t][s];if(!r){this.blurVsmWeights[s]=function(e){const t=(e-1)/6,s=.5*(e-1),r=new Array(e);let i=0;for(let a=0;a<e;++a)r[a]=D(a-s,t),i+=r[a];for(let t=0;t<e;++t)r[t]/=i;return r}(s);const i=v.fullscreenQuadVS;let a="#define SAMPLES "+s+"\n";a+=e?this.blurPackedVsmShaderCode[t]:this.blurVsmShaderCode[t];const o="blurVsm"+t+s+e;r=y(this.device,i,a,o),e?this.blurPackedVsmShader[t][s]=r:this.blurVsmShader[t][s]=r}return r}applyVsmBlur(e,t){const s=this.device;s.setBlendState(M.DEFAULT);const r=e.getRenderData(e._type===f?t:null,0).shadowCamera.renderTarget,i=this.renderer.shadowMapCache.get(s,e),a=i.renderTargets[0],o=e._shadowType===d,h=e.vsmBlurMode,l=e._vsmBlurSize,p=this.getVsmBlurShader(o,h,l);R.z=e._shadowResolution-2,R.w=R.z,this.sourceId.setValue(r.colorBuffer),x[0]=1/e._shadowResolution,x[1]=0,this.pixelOffsetId.setValue(x),h===S&&this.weightId.setValue(this.blurVsmWeights[l]),n(s,a,p,null,R),this.sourceId.setValue(a.colorBuffer),x[1]=x[0],x[0]=0,this.pixelOffsetId.setValue(x),n(s,r,p,null,R),this.renderer.shadowMapCache.add(e,i)}initViewBindGroupFormat(){this.device.supportsUniformBuffers&&!this.viewUniformFormat&&(this.viewUniformFormat=new C(this.device,[new _("matrix_viewProjection",i)]),this.viewBindGroupFormat=new P(this.device,[new O(a,o|h)],[]))}frameUpdate(){this.initViewBindGroupFormat()}}export{k as ShadowRenderer};
