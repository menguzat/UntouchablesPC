function e(e,t){let r;const n=(e,t)=>{switch(t){case r.DT_INT8:return new Int8Array(e.buffer,e.byteOffset,e.byteLength);case r.DT_INT16:return new Int16Array(e.buffer,e.byteOffset,e.byteLength/2);case r.DT_INT32:return new Int32Array(e.buffer,e.byteOffset,e.byteLength/4);case r.DT_UINT8:return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);case r.DT_UINT16:return new Uint16Array(e.buffer,e.byteOffset,e.byteLength/2);case r.DT_UINT32:return new Uint32Array(e.buffer,e.byteOffset,e.byteLength/4);case r.DT_FLOAT32:return new Float32Array(e.buffer,e.byteOffset,e.byteLength/4)}return null},s=e=>e.num_components()*(e=>{switch(e){case r.DT_INT8:return 1;case r.DT_INT16:return 2;case r.DT_INT32:return 4;case r.DT_UINT8:return 1;case r.DT_UINT16:return 2;case r.DT_UINT32:case r.DT_FLOAT32:return 4}return 1})(e.data_type()),a={0:0,1:1,5:2,2:3,7:4,8:5,4:6,3:7},o=(e,t)=>{const r=(e,t,r)=>{e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2]},n=(e,t,r)=>{e[0]=t[1]*r[2]-r[1]*t[2],e[1]=t[2]*r[0]-r[2]*t[0],e[2]=t[0]*r[1]-r[0]*t[1]},s=(e,t)=>{const r=e[t+0],n=e[t+1],s=e[t+2],a=1/Math.sqrt(r*r+n*n+s*s);e[t+0]*=a,e[t+1]*=a,e[t+2]*=a},a=(e,t,r)=>{for(let n=0;n<3;++n)e[n]=t[r+n]},o=t.length/3,i=e.length/3,f=new Float32Array(e.length),c=[0,0,0],u=[0,0,0],l=[0,0,0],y=[0,0,0],b=[0,0,0],d=[0,0,0];for(let i=0;i<o;++i){const o=3*t[3*i+0],_=3*t[3*i+1],T=3*t[3*i+2];a(c,e,o),a(u,e,_),a(l,e,T),r(y,u,c),r(b,l,c),n(d,y,b),s(d,0);for(let e=0;e<3;++e)f[o+e]+=d[e],f[_+e]+=d[e],f[T+e]+=d[e]}for(let e=0;e<i;++e)s(f,3*e);return new Uint8Array(f.buffer)},i=e=>{const t=(e=>{const t={},i=new r.DecoderBuffer;i.Init(e,e.length);const f=new r.Decoder;if(f.GetEncodedGeometryType(i)!==r.TRIANGULAR_MESH)return t.error="Failed to decode draco mesh: not a mesh",t;const c=new r.Mesh,u=f.DecodeBufferToMesh(i,c);if(!u||!u.ok()||0===c.ptr)return t.error="Failed to decode draco asset",t;const l=3*c.num_faces(),y=c.num_points()<=65535,b=l*(y?2:4),d=r._malloc(b);y?(f.GetTrianglesUInt16Array(c,b,d),t.indices=new Uint16Array(r.HEAPU16.buffer,d,l).slice().buffer):(f.GetTrianglesUInt32Array(c,b,d),t.indices=new Uint32Array(r.HEAPU32.buffer,d,l).slice().buffer),r._free(d);const _=[];for(let e=0;e<c.num_attributes();++e)_.push(f.GetAttribute(c,e));_.sort(((e,t)=>{var r,n;return(null!=(r=a[e.attribute_type()])?r:a.length)-(null!=(n=a[t.attribute_type()])?n:a.length)})),t.attributes=_.map((e=>e.unique_id()));let T=0;const A=_.map((e=>{const t=T;return T+=4*Math.ceil(s(e)/4),t})),h=_.some((e=>1===e.attribute_type())),w=A[1];if(!h){for(let e=1;e<A.length;++e)A[e]+=12;T+=12}t.vertices=new ArrayBuffer(c.num_points()*T);const U=new Uint8Array(t.vertices);for(let e=0;e<c.num_attributes();++e){const a=_[e],i=s(a),u=c.num_points()*i,l=r._malloc(u);f.GetAttributeDataArrayForAllPoints(c,a,a.data_type(),u,l);const b=new Uint8Array(r.HEAPU8.buffer,l,u);for(let t=0;t<c.num_points();++t)for(let r=0;r<i;++r)U[t*T+A[e]+r]=b[t*i+r];if(!h&&0===a.attribute_type()){const e=o(n(b,a.data_type()),y?new Uint16Array(t.indices):new Uint32Array(t.indices));for(let t=0;t<c.num_points();++t)for(let r=0;r<12;++r)U[t*T+w+r]=e[12*t+r]}r._free(l)}return r.destroy(c),r.destroy(f),r.destroy(i),t})(new Uint8Array(e.buffer));self.postMessage({jobId:e.jobId,error:t.error,indices:t.indices,vertices:t.vertices,attributes:t.attributes},[t.indices,t.vertices].filter((e=>null!=e)))},f=[];self.onmessage=e=>{const t=e.data;switch(t.type){case"init":self.DracoDecoderModule({instantiateWasm:(e,r)=>(WebAssembly.instantiate(t.module,e).then((e=>r(e))).catch((e=>console.error("instantiate failed + "+e))),{})}).then((e=>{r=e,f.forEach((e=>i(e)))}));break;case"decodeMesh":r?i(t):f.push(t)}}}export{e as DracoWorker};
