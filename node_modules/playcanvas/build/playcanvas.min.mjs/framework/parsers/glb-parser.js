import"../../core/debug.js";import{path as e}from"../../core/path.js";import{Color as t}from"../../core/math/color.js";import{Mat4 as n}from"../../core/math/mat4.js";import{math as r}from"../../core/math/math.js";import{Vec2 as s}from"../../core/math/vec2.js";import{Vec3 as o}from"../../core/math/vec3.js";import{BoundingBox as a}from"../../core/shape/bounding-box.js";import{CULLFACE_NONE as i,CULLFACE_BACK as l,INDEXFORMAT_UINT32 as c,INDEXFORMAT_UINT16 as u,INDEXFORMAT_UINT8 as p,BUFFER_STATIC as h,FILTER_LINEAR_MIPMAP_LINEAR as f,FILTER_NEAREST_MIPMAP_LINEAR as m,FILTER_LINEAR_MIPMAP_NEAREST as d,FILTER_NEAREST_MIPMAP_NEAREST as y,FILTER_LINEAR as g,FILTER_NEAREST as w,ADDRESS_REPEAT as v,ADDRESS_MIRRORED_REPEAT as O,ADDRESS_CLAMP_TO_EDGE as x,PRIMITIVE_TRIANGLES as b,PRIMITIVE_TRIFAN as P,PRIMITIVE_TRISTRIP as M,PRIMITIVE_LINESTRIP as T,PRIMITIVE_LINELOOP as C,PRIMITIVE_LINES as _,PRIMITIVE_POINTS as R,SEMANTIC_NORMAL as A,SEMANTIC_COLOR as k,TYPE_UINT8 as E,TYPE_UINT16 as F,TYPE_FLOAT32 as j,TYPE_UINT32 as S,TYPE_INT32 as I,TYPE_INT16 as V,TYPE_INT8 as D,SEMANTIC_POSITION as U,SEMANTIC_TANGENT as H,SEMANTIC_BLENDINDICES as L,SEMANTIC_BLENDWEIGHT as N,SEMANTIC_TEXCOORD0 as K,SEMANTIC_TEXCOORD1 as G,SEMANTIC_TEXCOORD2 as z,SEMANTIC_TEXCOORD3 as B,SEMANTIC_TEXCOORD4 as $,SEMANTIC_TEXCOORD5 as X,SEMANTIC_TEXCOORD6 as W,SEMANTIC_TEXCOORD7 as J,typedArrayTypesByteSize as Y,typedArrayTypes as q}from"../../platform/graphics/constants.js";import{IndexBuffer as Q}from"../../platform/graphics/index-buffer.js";import{Texture as Z}from"../../platform/graphics/texture.js";import{VertexBuffer as ee}from"../../platform/graphics/vertex-buffer.js";import{VertexFormat as te}from"../../platform/graphics/vertex-format.js";import{http as ne}from"../../platform/net/http.js";import{SPECOCC_AO as re,BLEND_NONE as se,BLEND_NORMAL as oe,PROJECTION_ORTHOGRAPHIC as ae,PROJECTION_PERSPECTIVE as ie,ASPECT_AUTO as le,LIGHTFALLOFF_INVERSESQUARED as ce,ASPECT_MANUAL as ue}from"../../scene/constants.js";import{GraphNode as pe}from"../../scene/graph-node.js";import{Light as he,lightTypes as fe}from"../../scene/light.js";import{Mesh as me}from"../../scene/mesh.js";import{Morph as de}from"../../scene/morph.js";import{MorphTarget as ye}from"../../scene/morph-target.js";import{calculateNormals as ge}from"../../scene/procedural.js";import{Render as we}from"../../scene/render.js";import{Skin as ve}from"../../scene/skin.js";import{StandardMaterial as Oe}from"../../scene/materials/standard-material.js";import{Entity as xe}from"../entity.js";import{INTERPOLATION_LINEAR as be,INTERPOLATION_CUBIC as Pe,INTERPOLATION_STEP as Me}from"../anim/constants.js";import{AnimCurve as Te}from"../anim/evaluator/anim-curve.js";import{AnimData as Ce}from"../anim/evaluator/anim-data.js";import{AnimTrack as _e}from"../anim/evaluator/anim-track.js";import{Asset as Re}from"../asset/asset.js";import{ABSOLUTE_URL as Ae}from"../asset/constants.js";import{dracoDecode as ke}from"./draco-decoder.js";class Ee{constructor(){this.gltf=void 0,this.nodes=void 0,this.scenes=void 0,this.animations=void 0,this.textures=void 0,this.materials=void 0,this.variants=void 0,this.meshVariants=void 0,this.meshDefaultMaterials=void 0,this.renders=void 0,this.skins=void 0,this.lights=void 0,this.cameras=void 0}destroy(){this.renders&&this.renders.forEach((e=>{e.meshes=null}))}}const Fe=e=>/^data:.*,.*$/i.test(e),je=e=>{switch(e){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":default:return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16}},Se=e=>{switch(e){case 5120:return D;case 5121:return E;case 5122:return V;case 5123:return F;case 5124:return I;case 5125:return S;case 5126:return j;default:return 0}},Ie=e=>{switch(e){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5124:case 5125:case 5126:return 4;default:return 0}},Ve={POSITION:U,NORMAL:A,TANGENT:H,COLOR_0:k,JOINTS_0:L,WEIGHTS_0:N,TEXCOORD_0:K,TEXCOORD_1:G,TEXCOORD_2:z,TEXCOORD_3:B,TEXCOORD_4:$,TEXCOORD_5:X,TEXCOORD_6:W,TEXCOORD_7:J},De={[U]:0,[A]:1,[H]:2,[k]:3,[L]:4,[N]:5,[K]:6,[G]:7,[z]:8,[B]:9,[$]:10,[X]:11,[W]:12,[J]:13},Ue=(e,t,n)=>{const r=(e=>{switch(e){case D:return e=>Math.max(e/127,-1);case E:return e=>e/255;case V:return e=>Math.max(e/32767,-1);case F:return e=>e/65535;default:return e=>e}})(n),s=t.length;for(let n=0;n<s;++n)e[n]=r(t[n]);return e},He=(e,t,n=!1)=>{const r=je(e.type),s=(e=>{switch(e){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:return null}})(e.componentType);if(!s)return null;let o;if(e.sparse){const n=e.sparse,a={count:n.count,type:"SCALAR"},i=He(Object.assign(a,n.indices),t,!0),l={count:n.count,type:e.type,componentType:e.componentType},c=He(Object.assign(l,n.values),t,!0);if(e.hasOwnProperty("bufferView")){const n={bufferView:e.bufferView,byteOffset:e.byteOffset,componentType:e.componentType,count:e.count,type:e.type};o=He(n,t,!0).slice()}else o=new s(e.count*r);for(let e=0;e<n.count;++e){const t=i[e];for(let n=0;n<r;++n)o[t*r+n]=c[e*r+n]}}else if(e.hasOwnProperty("bufferView")){const a=t[e.bufferView];if(n&&a.hasOwnProperty("byteStride")){const t=r*s.BYTES_PER_ELEMENT,n=new ArrayBuffer(e.count*t),i=new Uint8Array(n);let l=0;for(let n=0;n<e.count;++n){let r=(e.byteOffset||0)+n*a.byteStride;for(let e=0;e<t;++e)i[l++]=a[r++]}o=new s(n)}else o=new s(a.buffer,a.byteOffset+(e.byteOffset||0),e.count*r)}else o=new s(e.count*r);return o},Le=(e,t)=>{const n=He(e,t,!0);if(n instanceof Float32Array||!e.normalized)return n;const r=new Float32Array(n.length);return Ue(r,n,Se(e.componentType)),r},Ne=e=>{let t=e.min,n=e.max;if(!t||!n)return null;if(e.normalized){const r=Se(e.componentType);t=Ue([],t,r),n=Ue([],n,r)}return new a(new o(.5*(n[0]+t[0]),.5*(n[1]+t[1]),.5*(n[2]+t[2])),new o(.5*(n[0]-t[0]),.5*(n[1]-t[1]),.5*(n[2]-t[2])))},Ke=e=>{if(!e.hasOwnProperty("mode"))return b;switch(e.mode){case 0:return R;case 1:return _;case 2:return C;case 3:return T;case 4:default:return b;case 5:return M;case 6:return P}},Ge=(e,t)=>{const n=e[U];if(!n||3!==n.components)return;let r;if(n.size!==n.stride){const e=n.stride/Y[n.type],t=new q[n.type](n.buffer,n.offset,n.count*e);r=new q[n.type](3*n.count);for(let s=0;s<n.count;++s)r[3*s+0]=t[s*e+0],r[3*s+1]=t[s*e+1],r[3*s+2]=t[s*e+2]}else r=new q[n.type](n.buffer,n.offset,3*n.count);const s=n.count;t||(t=(e=>{const t=new Uint16Array(e);for(let n=0;n<e;n++)t[n]=n;return t})(s));const o=ge(r,t),a=new Float32Array(o.length);a.set(o),e[A]={buffer:a.buffer,size:12,offset:0,stride:12,count:s,components:3,type:j}},ze=e=>{const t=new Re(e.name+"_clone",e.type,e.file,e.data,e.options);return t.loaded=!0,t.resource=(e=>{const t=new Z(e.device,e);return t._levels=(e=>{const t=[];for(let n=0;n<e._levels.length;++n){let r=[];if(e.cubemap)for(let t=0;t<6;++t)r.push(e._levels[n][t]);else r=e._levels[n];t.push(r)}return t})(e),t})(e.resource),e.registry.add(t),t},Be=(e,t,n)=>{const r=t[U];if(!r)return null;const s=r.count,o=[];for(const e in t)t.hasOwnProperty(e)&&o.push({semantic:e,components:t[e].components,type:t[e].type,normalize:!!t[e].normalize});let a,i,l,c,u,p;o.sort(((e,t)=>De[e.semantic]-De[t.semantic]));const f=new te(e,o);let m=!0;for(a=0;a<f.elements.length;++a)if(u=f.elements[a],c=t[u.name],p=c.offset-r.offset,c.buffer!==r.buffer||c.stride!==u.stride||c.size!==u.size||p!==u.offset){m=!1;break}const d=new ee(e,f,s,h),y=d.lock(),g=new Uint32Array(y);let w;if(m)w=new Uint32Array(r.buffer,r.offset,s*d.format.size/4),g.set(w);else{let e,n;for(a=0;a<d.format.elements.length;++a){u=d.format.elements[a],e=u.stride/4,c=t[u.name],n=c.stride/4,w=new Uint32Array(c.buffer,c.offset,(c.count-1)*n+(c.size+3)/4);let r=0,o=u.offset/4;const p=Math.floor((c.size+3)/4);for(i=0;i<s;++i){for(l=0;l<p;++l)g[o+l]=w[r+l];r+=n,o+=e}}}return n&&(e=>{let t,n;const r=[],s=[],o=[];for(t=0;t<e.format.elements.length;++t){const n=e.format.elements[t];if(n.name===K||n.name===G)switch(n.dataType){case j:r.push({offset:n.offset/4+1,stride:n.stride/4});break;case F:s.push({offset:n.offset/2+1,stride:n.stride/2});break;case E:o.push({offset:n.offset+1,stride:n.stride})}}const a=(r,s,o)=>{const a=new s(e.storage);for(t=0;t<r.length;++t){let s=r[t].offset;const i=r[t].stride;for(n=0;n<e.numVertices;++n)a[s]=o-a[s],s+=i}};r.length>0&&a(r,Float32Array,1),s.length>0&&a(s,Uint16Array,65535),o.length>0&&a(o,Uint8Array,255)})(d),d.unlock(),d},$e=(e,t,n,r,s,o,a,i,l,f)=>{const m=[];return t.primitives.forEach((d=>{var y;if(null!=(y=d.extensions)&&y.KHR_draco_mesh_compression)m.push(((e,t,n,r,s,o,a)=>{var i,l;const p=new me(e);p.aabb=Ne(n[t.attributes.POSITION]);const f=[];for(const[e,r]of Object.entries(t.attributes)){var m;const t=n[r],s=Ve[e],o=Se(t.componentType);f.push({semantic:s,components:je(t.type),type:o,normalize:null!=(m=t.normalized)?m:s===k&&(o===E||o===F)})}if(null!=t&&null!=(i=t.attributes)&&i.NORMAL||f.push({semantic:"NORMAL",components:3,type:j}),a.push(new Promise(((n,s)=>{const o=t.extensions.KHR_draco_mesh_compression;ke(r[o.bufferView].slice().buffer,((r,a)=>{if(r)console.log(r),s(r);else{const r={};for(const[e,t]of Object.entries(o.attributes))r[Ve[e]]=a.attributes.indexOf(t);f.sort(((e,t)=>r[e.semantic]-r[t.semantic]));const s=new te(e,f),i=a.vertices.byteLength/s.size,l=i<=65535?u:c,m=a.indices.byteLength/(i<=65535?2:4),d=new ee(e,s,i,h,a.vertices),y=new Q(e,l,m,h,a.indices);p.vertexBuffer=d,p.indexBuffer[0]=y,p.primitive[0].type=Ke(t),p.primitive[0].base=0,p.primitive[0].count=y?m:i,p.primitive[0].indexed=!!y,n()}}))}))),null!=t&&null!=(l=t.extensions)&&l.KHR_materials_variants){const e=t.extensions.KHR_materials_variants,n={};e.mappings.forEach((e=>{e.variants.forEach((t=>{n[t]=e.material}))})),s[p.id]=n}return o[p.id]=t.material,p})(e,d,n,r,a,i,f));else{let f=d.hasOwnProperty("indices")?He(n[d.indices],r,!0):null;const y=((e,t,n,r,s,o,a)=>{const i={},l=[];for(const e in t)t.hasOwnProperty(e)&&Ve.hasOwnProperty(e)&&(i[e]=t[e],l.push(e+":"+t[e]));l.sort();const c=l.join();let u=a[c];if(!u){const l={};for(const e in i){const n=r[t[e]],o=He(n,s),a=s[n.bufferView],i=Ve[e],c=je(n.type)*Ie(n.componentType),u=a&&a.hasOwnProperty("byteStride")?a.byteStride:c;l[i]={buffer:o.buffer,size:c,offset:o.byteOffset,stride:u,count:n.count,components:je(n.type),type:Se(n.componentType),normalize:n.normalized}}l.hasOwnProperty(A)||Ge(l,n),u=Be(e,l,o),a[c]=u}return u})(e,d.attributes,f,n,r,s,o),g=Ke(d),w=new me(e);if(w.vertexBuffer=y,w.primitive[0].type=g,w.primitive[0].base=0,w.primitive[0].indexed=null!==f,null!==f){let t;t=f instanceof Uint8Array?p:f instanceof Uint16Array?u:c,t!==c||e.extUintElement||(t=u,f=new Uint16Array(f)),t===p&&e.isWebGPU&&(t=u,f=new Uint16Array(f));const n=new Q(e,t,f.length,h,f);w.indexBuffer[0]=n,w.primitive[0].count=f.length}else w.primitive[0].count=y.numVertices;if(d.hasOwnProperty("extensions")&&d.extensions.hasOwnProperty("KHR_materials_variants")){const e=d.extensions.KHR_materials_variants,t={};e.mappings.forEach((e=>{e.variants.forEach((n=>{t[n]=e.material}))})),a[w.id]=t}i[w.id]=d.material;let v=n[d.attributes.POSITION];if(w.aabb=Ne(v),d.hasOwnProperty("targets")){const s=[];d.targets.forEach(((e,o)=>{const a={};e.hasOwnProperty("POSITION")&&(v=n[e.POSITION],a.deltaPositions=Le(v,r),a.deltaPositionsType=j,a.aabb=Ne(v)),e.hasOwnProperty("NORMAL")&&(v=n[e.NORMAL],a.deltaNormals=Le(v,r),a.deltaNormalsType=j),t.hasOwnProperty("extras")&&t.extras.hasOwnProperty("targetNames")?a.name=t.extras.targetNames[o]:a.name=o.toString(10),t.hasOwnProperty("weights")&&(a.defaultWeight=t.weights[o]),a.preserveData=l.morphPreserveData,s.push(new ye(a))})),w.morph=new de(s,e,{preferHighPrecision:l.morphPreferHighPrecision})}m.push(w)}})),m},Xe=(e,t,n)=>{var o;let a;const i=e.texCoord;if(i)for(a=0;a<n.length;++a)t[n[a]+"MapUv"]=i;const l=[0,0],c=[1,1],u=null==(o=e.extensions)?void 0:o.KHR_texture_transform;if(u){const e=u.offset||l,o=u.scale||c,i=u.rotation?-u.rotation*r.RAD_TO_DEG:0,p=new s(o[0],o[1]),h=new s(e[0],1-o[1]-e[1]);for(a=0;a<n.length;++a)t[`${n[a]}MapTiling`]=p,t[`${n[a]}MapOffset`]=h,t[`${n[a]}MapRotation`]=i}},We=(e,t,n)=>{let r,s;if(e.hasOwnProperty("diffuseFactor")?(r=e.diffuseFactor,t.diffuse.set(Math.pow(r[0],1/2.2),Math.pow(r[1],1/2.2),Math.pow(r[2],1/2.2)),t.opacity=r[3]):(t.diffuse.set(1,1,1),t.opacity=1),e.hasOwnProperty("diffuseTexture")){const r=e.diffuseTexture;s=n[r.index],t.diffuseMap=s,t.diffuseMapChannel="rgb",t.opacityMap=s,t.opacityMapChannel="a",Xe(r,t,["diffuse","opacity"])}if(t.useMetalness=!1,e.hasOwnProperty("specularFactor")?(r=e.specularFactor,t.specular.set(Math.pow(r[0],1/2.2),Math.pow(r[1],1/2.2),Math.pow(r[2],1/2.2))):t.specular.set(1,1,1),e.hasOwnProperty("glossinessFactor")?t.gloss=e.glossinessFactor:t.gloss=1,e.hasOwnProperty("specularGlossinessTexture")){const r=e.specularGlossinessTexture;t.specularEncoding="srgb",t.specularMap=t.glossMap=n[r.index],t.specularMapChannel="rgb",t.glossMapChannel="a",Xe(r,t,["gloss","metalness"])}},Je=(e,t,n)=>{if(e.hasOwnProperty("clearcoatFactor")?t.clearCoat=.25*e.clearcoatFactor:t.clearCoat=0,e.hasOwnProperty("clearcoatTexture")){const r=e.clearcoatTexture;t.clearCoatMap=n[r.index],t.clearCoatMapChannel="r",Xe(r,t,["clearCoat"])}if(e.hasOwnProperty("clearcoatRoughnessFactor")?t.clearCoatGloss=e.clearcoatRoughnessFactor:t.clearCoatGloss=0,e.hasOwnProperty("clearcoatRoughnessTexture")){const r=e.clearcoatRoughnessTexture;t.clearCoatGlossMap=n[r.index],t.clearCoatGlossMapChannel="g",Xe(r,t,["clearCoatGloss"])}if(e.hasOwnProperty("clearcoatNormalTexture")){const r=e.clearcoatNormalTexture;t.clearCoatNormalMap=n[r.index],Xe(r,t,["clearCoatNormal"]),r.hasOwnProperty("scale")&&(t.clearCoatBumpiness=r.scale)}t.clearCoatGlossInvert=!0},Ye=(e,t,n)=>{t.useLighting=!1,t.emissive.copy(t.diffuse),t.emissiveTint=t.diffuseTint,t.emissiveMap=t.diffuseMap,t.emissiveMapUv=t.diffuseMapUv,t.emissiveMapTiling.copy(t.diffuseMapTiling),t.emissiveMapOffset.copy(t.diffuseMapOffset),t.emissiveMapRotation=t.diffuseMapRotation,t.emissiveMapChannel=t.diffuseMapChannel,t.emissiveVertexColor=t.diffuseVertexColor,t.emissiveVertexColorChannel=t.diffuseVertexColorChannel,t.useLighting=!1,t.useSkybox=!1,t.diffuse.set(0,0,0),t.diffuseTint=!1,t.diffuseMap=null,t.diffuseVertexColor=!1},qe=(e,t,n)=>{if(t.useMetalnessSpecularColor=!0,e.hasOwnProperty("specularColorTexture")&&(t.specularEncoding="srgb",t.specularMap=n[e.specularColorTexture.index],t.specularMapChannel="rgb",Xe(e.specularColorTexture,t,["specular"])),e.hasOwnProperty("specularColorFactor")){const n=e.specularColorFactor;t.specular.set(Math.pow(n[0],1/2.2),Math.pow(n[1],1/2.2),Math.pow(n[2],1/2.2))}else t.specular.set(1,1,1);e.hasOwnProperty("specularFactor")?t.specularityFactor=e.specularFactor:t.specularityFactor=1,e.hasOwnProperty("specularTexture")&&(t.specularityFactorMapChannel="a",t.specularityFactorMap=n[e.specularTexture.index],Xe(e.specularTexture,t,["specularityFactor"]))},Qe=(e,t,n)=>{e.hasOwnProperty("ior")&&(t.refractionIndex=1/e.ior)},Ze=(e,t,n)=>{t.blendType=oe,t.useDynamicRefraction=!0,e.hasOwnProperty("transmissionFactor")&&(t.refraction=e.transmissionFactor),e.hasOwnProperty("transmissionTexture")&&(t.refractionMapChannel="r",t.refractionMap=n[e.transmissionTexture.index],Xe(e.transmissionTexture,t,["refraction"]))},et=(e,t,n)=>{if(t.useSheen=!0,e.hasOwnProperty("sheenColorFactor")){const n=e.sheenColorFactor;t.sheen.set(Math.pow(n[0],1/2.2),Math.pow(n[1],1/2.2),Math.pow(n[2],1/2.2))}else t.sheen.set(1,1,1);e.hasOwnProperty("sheenColorTexture")&&(t.sheenMap=n[e.sheenColorTexture.index],t.sheenEncoding="srgb",Xe(e.sheenColorTexture,t,["sheen"])),e.hasOwnProperty("sheenRoughnessFactor")?t.sheenGloss=e.sheenRoughnessFactor:t.sheenGloss=0,e.hasOwnProperty("sheenRoughnessTexture")&&(t.sheenGlossMap=n[e.sheenRoughnessTexture.index],t.sheenGlossMapChannel="a",Xe(e.sheenRoughnessTexture,t,["sheenGloss"])),t.sheenGlossInvert=!0},tt=(e,t,n)=>{if(t.blendType=oe,t.useDynamicRefraction=!0,e.hasOwnProperty("thicknessFactor")&&(t.thickness=e.thicknessFactor),e.hasOwnProperty("thicknessTexture")&&(t.thicknessMap=n[e.thicknessTexture.index],t.thicknessMapChannel="g",Xe(e.thicknessTexture,t,["thickness"])),e.hasOwnProperty("attenuationDistance")&&(t.attenuationDistance=e.attenuationDistance),e.hasOwnProperty("attenuationColor")){const n=e.attenuationColor;t.attenuation.set(Math.pow(n[0],1/2.2),Math.pow(n[1],1/2.2),Math.pow(n[2],1/2.2))}},nt=(e,t,n)=>{e.hasOwnProperty("emissiveStrength")&&(t.emissiveIntensity=e.emissiveStrength)},rt=(e,t,n)=>{t.useIridescence=!0,e.hasOwnProperty("iridescenceFactor")&&(t.iridescence=e.iridescenceFactor),e.hasOwnProperty("iridescenceTexture")&&(t.iridescenceMapChannel="r",t.iridescenceMap=n[e.iridescenceTexture.index],Xe(e.iridescenceTexture,t,["iridescence"])),e.hasOwnProperty("iridescenceIor")&&(t.iridescenceRefractionIndex=e.iridescenceIor),e.hasOwnProperty("iridescenceThicknessMinimum")&&(t.iridescenceThicknessMin=e.iridescenceThicknessMinimum),e.hasOwnProperty("iridescenceThicknessMaximum")&&(t.iridescenceThicknessMax=e.iridescenceThicknessMaximum),e.hasOwnProperty("iridescenceThicknessTexture")&&(t.iridescenceThicknessMapChannel="g",t.iridescenceThicknessMap=n[e.iridescenceThicknessTexture.index],Xe(e.iridescenceThicknessTexture,t,["iridescenceThickness"]))},st=(e,t,n)=>{const r=new Oe;let s,o;if(r.occludeSpecular=re,r.diffuseTint=!0,r.diffuseVertexColor=!0,r.specularTint=!0,r.specularVertexColor=!0,e.hasOwnProperty("name")&&(r.name=e.name),e.hasOwnProperty("pbrMetallicRoughness")){const n=e.pbrMetallicRoughness;if(n.hasOwnProperty("baseColorFactor")?(s=n.baseColorFactor,r.diffuse.set(Math.pow(s[0],1/2.2),Math.pow(s[1],1/2.2),Math.pow(s[2],1/2.2)),r.opacity=s[3]):(r.diffuse.set(1,1,1),r.opacity=1),n.hasOwnProperty("baseColorTexture")){const e=n.baseColorTexture;o=t[e.index],r.diffuseMap=o,r.diffuseMapChannel="rgb",r.opacityMap=o,r.opacityMapChannel="a",Xe(e,r,["diffuse","opacity"])}if(r.useMetalness=!0,r.specular.set(1,1,1),n.hasOwnProperty("metallicFactor")?r.metalness=n.metallicFactor:r.metalness=1,n.hasOwnProperty("roughnessFactor")?r.gloss=n.roughnessFactor:r.gloss=1,r.glossInvert=!0,n.hasOwnProperty("metallicRoughnessTexture")){const e=n.metallicRoughnessTexture;r.metalnessMap=r.glossMap=t[e.index],r.metalnessMapChannel="b",r.glossMapChannel="g",Xe(e,r,["gloss","metalness"])}}if(e.hasOwnProperty("normalTexture")){const n=e.normalTexture;r.normalMap=t[n.index],Xe(n,r,["normal"]),n.hasOwnProperty("scale")&&(r.bumpiness=n.scale)}if(e.hasOwnProperty("occlusionTexture")){const n=e.occlusionTexture;r.aoMap=t[n.index],r.aoMapChannel="r",Xe(n,r,["ao"])}if(e.hasOwnProperty("emissiveFactor")?(s=e.emissiveFactor,r.emissive.set(Math.pow(s[0],1/2.2),Math.pow(s[1],1/2.2),Math.pow(s[2],1/2.2)),r.emissiveTint=!0):(r.emissive.set(0,0,0),r.emissiveTint=!1),e.hasOwnProperty("emissiveTexture")){const n=e.emissiveTexture;r.emissiveMap=t[n.index],Xe(n,r,["emissive"])}if(e.hasOwnProperty("alphaMode"))switch(e.alphaMode){case"MASK":r.blendType=se,e.hasOwnProperty("alphaCutoff")?r.alphaTest=e.alphaCutoff:r.alphaTest=.5;break;case"BLEND":r.blendType=oe,r.depthWrite=!1;break;default:r.blendType=se}else r.blendType=se;e.hasOwnProperty("doubleSided")?(r.twoSidedLighting=e.doubleSided,r.cull=e.doubleSided?i:l):(r.twoSidedLighting=!1,r.cull=l);const a={KHR_materials_clearcoat:Je,KHR_materials_emissive_strength:nt,KHR_materials_ior:Qe,KHR_materials_iridescence:rt,KHR_materials_pbrSpecularGlossiness:We,KHR_materials_sheen:et,KHR_materials_specular:qe,KHR_materials_transmission:Ze,KHR_materials_unlit:Ye,KHR_materials_volume:tt};if(e.hasOwnProperty("extensions"))for(const n in e.extensions){const s=a[n];void 0!==s&&s(e.extensions[n],r,t)}return r.update(),r},ot=new n,at=new o,it=(e,t)=>{const n=new pe;if(e.hasOwnProperty("name")&&e.name.length>0?n.name=e.name:n.name="node_"+t,e.hasOwnProperty("matrix")&&(ot.data.set(e.matrix),ot.getTranslation(at),n.setLocalPosition(at),ot.getEulerAngles(at),n.setLocalEulerAngles(at),ot.getScale(at),n.setLocalScale(at)),e.hasOwnProperty("rotation")){const t=e.rotation;n.setLocalRotation(t[0],t[1],t[2],t[3])}if(e.hasOwnProperty("translation")){const t=e.translation;n.setLocalPosition(t[0],t[1],t[2])}if(e.hasOwnProperty("scale")){const t=e.scale;n.setLocalScale(t[0],t[1],t[2])}return n},lt=(e,t)=>{const n="orthographic"===e.type?ae:ie,s=n===ae?e.orthographic:e.perspective,o={enabled:!1,projection:n,nearClip:s.znear,aspectRatioMode:le};s.zfar&&(o.farClip=s.zfar),n===ae?(o.orthoHeight=.5*s.ymag,s.ymag&&(o.aspectRatioMode=ue,o.aspectRatio=s.xmag/s.ymag)):(o.fov=s.yfov*r.RAD_TO_DEG,s.aspectRatio&&(o.aspectRatioMode=ue,o.aspectRatio=s.aspectRatio));const a=new xe(e.name);return a.addComponent("camera",o),a},ct=(e,n)=>{const s={enabled:!1,type:"point"===e.type?"omni":e.type,color:e.hasOwnProperty("color")?new t(e.color):t.WHITE,range:e.hasOwnProperty("range")?e.range:9999,falloffMode:ce,intensity:e.hasOwnProperty("intensity")?r.clamp(e.intensity,0,2):1};e.hasOwnProperty("spot")&&(s.innerConeAngle=e.spot.hasOwnProperty("innerConeAngle")?e.spot.innerConeAngle*r.RAD_TO_DEG:0,s.outerConeAngle=e.spot.hasOwnProperty("outerConeAngle")?e.spot.outerConeAngle*r.RAD_TO_DEG:Math.PI/4),e.hasOwnProperty("intensity")&&(s.luminance=e.intensity*he.getLightUnitConversion(fe[s.type],s.outerConeAngle,s.innerConeAngle));const o=new xe(n.name);return o.rotateLocal(90,0,0),o.addComponent("light",s),o},ut=(e,t,r,s)=>{if(!t.hasOwnProperty("skins")||0===t.skins.length)return[];const o=new Map;return t.skins.map((a=>((e,t,r,s,o,a)=>{let i,l,c;const u=t.joints,p=u.length,h=[];if(t.hasOwnProperty("inverseBindMatrices")){const e=t.inverseBindMatrices,o=He(r[e],s,!0),a=[];for(i=0;i<p;i++){for(l=0;l<16;l++)a[l]=o[16*i+l];c=new n,c.set(a),h.push(c)}}else for(i=0;i<p;i++)c=new n,h.push(c);const f=[];for(i=0;i<p;i++)f[i]=o[u[i]].name;const m=f.join("#");let d=a.get(m);return d||(d=new ve(e,h,f),a.set(m,d)),d})(e,a,t.accessors,s,r,o)))},pt=(e,t,n,r)=>{var s,o;if(!e.hasOwnProperty("animations")||0===e.animations.length)return[];const a=null==r||null==(s=r.animation)?void 0:s.preprocess,i=null==r||null==(o=r.animation)?void 0:o.postprocess;return e.animations.map(((r,s)=>{a&&a(r);const o=((e,t,n,r,s,o,a)=>{const i=e=>new Ce(je(e.type),Le(e,r)),l={STEP:Me,LINEAR:be,CUBICSPLINE:Pe},c={},u={},p={};let h,f=1;for(h=0;h<e.samplers.length;++h){const t=e.samplers[h];c.hasOwnProperty(t.input)||(c[t.input]=i(n[t.input])),u.hasOwnProperty(t.output)||(u[t.output]=i(n[t.output]));const r=t.hasOwnProperty("interpolation")&&l.hasOwnProperty(t.interpolation)?l[t.interpolation]:be,s={paths:[],input:t.input,output:t.output,interpolation:r};p[h]=s}const m=[],d={translation:"localPosition",rotation:"localRotation",scale:"localScale"},y=e=>{const t=[];for(;e;)t.unshift(e.name),e=e.parent;return t},g=(e,t,n)=>{const r=u[e.output];if(!r)return;let s;if(o&&o[t.mesh]){const e=o[t.mesh];e.hasOwnProperty("extras")&&e.extras.hasOwnProperty("targetNames")&&(s=e.extras.targetNames)}const a=r.data,i=a.length/c[e.input].data.length,l=a.length/i,m=4*l,d=new ArrayBuffer(m*i);for(let t=0;t<i;t++){var y;const r=new Float32Array(d,m*t,l);for(let e=0;e<l;e++)r[e]=a[e*i+t];const o=new Ce(1,r),c=null!=(y=s)&&y[t]?`name.${s[t]}`:t;u[-f]=o;const g={paths:[{entityPath:n,component:"graph",propertyPath:[`weight.${c}`]}],input:e.input,output:-f,interpolation:e.interpolation};f++,p[`morphCurve-${h}-${t}`]=g}};for(h=0;h<e.channels.length;++h){const t=e.channels[h],n=t.target,r=p[t.sampler],o=s[n.node],i=a[n.node],l=y(o);n.path.startsWith("weights")?(g(r,i,l),p[t.sampler].morphCurve=!0):r.paths.push({entityPath:l,component:"graph",propertyPath:[d[n.path]]})}const w=[],v=[],O=[];for(const e in c)w.push(c[e]),c[e]=w.length-1;for(const e in u)v.push(u[e]),u[e]=v.length-1;for(const e in p){const t=p[e];t.morphCurve||(O.push(new Te(t.paths,c[t.input],u[t.output],t.interpolation)),t.paths.length>0&&"localRotation"===t.paths[0].propertyPath[0]&&t.interpolation!==Pe&&m.push(O[O.length-1].output))}m.sort();let x,b=null;for(h=0;h<m.length;++h){const e=m[h];if(0===h||e!==b){if(x=v[e],4===x.components){const e=x.data,t=e.length-4;for(let n=0;n<t;n+=4)e[n+0]*e[n+4]+e[n+1]*e[n+5]+e[n+2]*e[n+6]+e[n+3]*e[n+7]<0&&(e[n+4]*=-1,e[n+5]*=-1,e[n+6]*=-1,e[n+7]*=-1)}b=e}}let P=0;for(h=0;h<w.length;h++)x=w[h]._data,P=Math.max(P,0===x.length?0:x[x.length-1]);return new _e(e.hasOwnProperty("name")?e.name:"animation_"+t,P,w,v,O)})(r,s,e.accessors,n,t,e.meshes,e.nodes);return i&&i(r,o),o}))},ht=async(e,t,n,r,s)=>{var o,a;const i=null==s||null==(o=s.global)?void 0:o.preprocess,l=null==s||null==(a=s.global)?void 0:a.postprocess;i&&i(t);const c=t.asset&&"PlayCanvas"===t.asset.generator,u=((e,t)=>{var n,r,s,o;if(!e.hasOwnProperty("nodes")||0===e.nodes.length)return[];const a=null==t||null==(n=t.node)?void 0:n.preprocess,i=null!=(r=null==t||null==(s=t.node)?void 0:s.process)?r:it,l=null==t||null==(o=t.node)?void 0:o.postprocess,c=e.nodes.map(((e,t)=>{a&&a(e);const n=i(e,t);return l&&l(e,n),n}));for(let t=0;t<e.nodes.length;++t){const n=e.nodes[t];if(n.hasOwnProperty("children")){const e=c[t],r={};for(let t=0;t<n.children.length;++t){const s=c[n.children[t]];s.parent||(r.hasOwnProperty(s.name)?s.name+=r[s.name]++:r[s.name]=1,e.addChild(s))}}}return c})(t,s),p=((e,t)=>{var n;const r=[],s=e.scenes.length;if(1===s&&1===(null==(n=e.scenes[0].nodes)?void 0:n.length)){const n=e.scenes[0].nodes[0];r.push(t[n])}else for(let n=0;n<s;n++){const s=e.scenes[n];if(s.nodes){const e=new pe(s.name);for(let n=0;n<s.nodes.length;n++){const r=t[s.nodes[n]];e.addChild(r)}r.push(e)}}return r})(t,u),h=((e,t,n)=>{let r=null;if(e.hasOwnProperty("nodes")&&e.hasOwnProperty("extensions")&&e.extensions.hasOwnProperty("KHR_lights_punctual")&&e.extensions.KHR_lights_punctual.hasOwnProperty("lights")){const l=e.extensions.KHR_lights_punctual.lights;if(l.length){var s,o,a,i;const c=null==n||null==(s=n.light)?void 0:s.preprocess,u=null!=(o=null==n||null==(a=n.light)?void 0:a.process)?o:ct,p=null==n||null==(i=n.light)?void 0:i.postprocess;e.nodes.forEach(((e,n)=>{if(e.hasOwnProperty("extensions")&&e.extensions.hasOwnProperty("KHR_lights_punctual")&&e.extensions.KHR_lights_punctual.hasOwnProperty("light")){const s=e.extensions.KHR_lights_punctual.light,o=l[s];if(o){c&&c(o);const s=u(o,t[n]);p&&p(o,s),s&&(r||(r=new Map),r.set(e,s))}}}))}}return r})(t,u,s),f=((e,t,n)=>{let r=null;if(e.hasOwnProperty("nodes")&&e.hasOwnProperty("cameras")&&e.cameras.length>0){var s,o,a,i;const l=null==n||null==(s=n.camera)?void 0:s.preprocess,c=null!=(o=null==n||null==(a=n.camera)?void 0:a.process)?o:lt,u=null==n||null==(i=n.camera)?void 0:i.postprocess;e.nodes.forEach(((n,s)=>{if(n.hasOwnProperty("camera")){const o=e.cameras[n.camera];if(o){l&&l(o);const e=c(o,t[s]);u&&u(o,e),e&&(r||(r=new Map),r.set(n,e))}}}))}return r})(t,u,s),m=(e=>{if(!e.hasOwnProperty("extensions")||!e.extensions.hasOwnProperty("KHR_materials_variants"))return null;const t=e.extensions.KHR_materials_variants.variants,n={};for(let e=0;e<t.length;e++)n[t[e].name]=e;return n})(t),d=await Promise.all(n),{meshes:y,meshVariants:g,meshDefaultMaterials:w,promises:v}=((e,t,n,r,s)=>{var o,a,i;const l={},c={},u={},p=[];return{meshes:!s.skipMeshes&&(null==t||null==(o=t.meshes)?void 0:o.length)&&(null==t||null==(a=t.accessors)?void 0:a.length)&&(null==t||null==(i=t.bufferViews)?void 0:i.length)?t.meshes.map((o=>$e(e,o,t.accessors,n,r,l,c,u,s,p))):[],meshVariants:c,meshDefaultMaterials:u,promises:p}})(e,t,d,c,s),O=pt(t,u,d,s),x=await Promise.all(r),b=((e,t,n,r)=>{var s,o,a,i;if(!e.hasOwnProperty("materials")||0===e.materials.length)return[];const l=null==n||null==(s=n.material)?void 0:s.preprocess,c=null!=(o=null==n||null==(a=n.material)?void 0:a.process)?o:st,u=null==n||null==(i=n.material)?void 0:i.postprocess;return e.materials.map((e=>{l&&l(e);const n=c(e,t,r);return u&&u(e,n),n}))})(t,x.map((e=>e.resource)),s,c),P=ut(e,t,u,d),M=[];for(let e=0;e<y.length;e++)M[e]=new we,M[e].meshes=y[e];((e,t,n)=>{e.nodes.forEach((e=>{e.hasOwnProperty("mesh")&&e.hasOwnProperty("skin")&&t[e.mesh].meshes.forEach((t=>{t.skin=n[e.skin]}))}))})(t,M,P);const T=new Ee;return T.gltf=t,T.nodes=u,T.scenes=p,T.animations=O,T.textures=x,T.materials=b,T.variants=m,T.meshVariants=g,T.meshDefaultMaterials=w,T.renders=M,T.skins=P,T.lights=h,T.cameras=f,l&&l(t,T),await Promise.all(v),T};let ft=0;const mt=(e,t,n)=>{var r,s,o,a,i;if(null==e||null==(r=e.images)||!r.length||null==e||null==(s=e.textures)||!s.length)return[];const l=null==n||null==(o=n.texture)?void 0:o.preprocess,c=null==n||null==(a=n.texture)?void 0:a.processAsync,u=null==n||null==(i=n.texture)?void 0:i.postprocess,p=new Set;return e.textures.map((n=>{let r;return l&&l(n),r=new Promise(c?(t,r)=>{c(n,e.images,((e,n)=>{e?r(e):t(n)}))}:e=>{e(null)}),r=r.then((r=>{var s,o,a,i;r=null!=(s=null!=(o=r)?o:null==n||null==(a=n.extensions)||null==(i=a.KHR_texture_basisu)?void 0:i.source)?s:n.source;const l=p.has(r);return p.add(r),t[r].then((t=>{var r;const s=l?ze(t):t;return((e,t)=>{const n=(e,t)=>{switch(e){case 9728:return w;case 9729:return g;case 9984:return y;case 9985:return d;case 9986:return m;case 9987:return f;default:return t}},r=(e,t)=>{switch(e){case 33071:return x;case 33648:return O;case 10497:return v;default:return t}};var s;e&&(t=null!=(s=t)?s:{},e.minFilter=n(t.minFilter,f),e.magFilter=n(t.magFilter,g),e.addressU=r(t.wrapS,v),e.addressV=r(t.wrapT,v))})(s.resource,(null!=(r=e.samplers)?r:[])[n.sampler]),s}))})),u&&(r=r.then((e=>(u(n,e),e)))),r}))},dt=(e,t,n)=>{e&&e.toLowerCase().endsWith(".glb")||(()=>{const e=new Uint8Array(t);return 103===e[0]&&108===e[1]&&84===e[2]&&70===e[3]})()?((e,t)=>{const n=e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength),r=n.getUint32(0,!0),s=n.getUint32(4,!0),o=n.getUint32(8,!0);if(1179937895!==r)return void t("Invalid magic number found in glb header. Expected 0x46546C67, found 0x"+r.toString(16));if(2!==s)return void t("Invalid version number found in glb header. Expected 2, found "+s);if(o<=0||o>n.byteLength)return void t("Invalid length found in glb header. Found "+o);const a=[];let i=12;for(;i<o;){const e=n.getUint32(i,!0);i+e+8>n.byteLength&&t(`Invalid chunk length found in glb. Found ${e}`);const r=n.getUint32(i+4,!0),s=new Uint8Array(n.buffer,n.byteOffset+i+8,e);a.push({length:e,type:r,data:s}),i+=e+8}1===a.length||2===a.length?1313821514===a[0].type?a.length>1&&5130562!==a[1].type?t(`Invalid chunk type found in glb file. Expected 0x004E4942, found 0x${a[1].type.toString(16)}`):t(null,{gltfChunk:a[0].data,binaryChunk:2===a.length?a[1].data:null}):t(`Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x${a[0].type.toString(16)}`):t("Invalid number of chunks found in glb file.")})(t,n):n(null,{gltfChunk:t,binaryChunk:null})};class yt{static parse(t,n,r,s,o,a,i){dt(t,r,((t,r)=>{t?i(t):((e,t)=>{const n=JSON.parse((e=>{if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return decodeURIComponent(escape(t))})(e));n.asset&&n.asset.version&&parseFloat(n.asset.version)<2?t(`Invalid gltf version. Expected version 2.0 or above but found version '${n.asset.version}'.`):t(null,n)})(r.gltfChunk,((t,l)=>{if(t)return void i(t);const c=((t,n,r,s)=>{var o,a,i;if(!t.buffers||0===t.buffers.length)return[];const l=null==s||null==(o=s.buffer)?void 0:o.preprocess,c=null==s||null==(a=s.buffer)?void 0:a.processAsync,u=null==s||null==(i=s.buffer)?void 0:i.postprocess;return t.buffers.map(((s,o)=>{let a;return l&&l(s),a=new Promise(c?(e,t)=>{c(s,((n,r)=>{n?t(n):e(r)}))}:e=>{e(null)}),a=a.then((t=>{if(t)return t;if(s.hasOwnProperty("uri")){if(Fe(s.uri)){const e=atob(s.uri.split(",")[1]),t=new Uint8Array(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}return new Promise(((t,n)=>{ne.get(Ae.test(s.uri)?s.uri:e.join(r,s.uri),{cache:!0,responseType:"arraybuffer",retry:!1},((e,r)=>{e?n(e):t(new Uint8Array(r))}))}))}return n})),u&&(a=a.then((e=>(u(t.buffers[o],e),e)))),a}))})(l,r.binaryChunk,n,a),u=((e,t,n)=>{var r,s,o,a;const i=[],l=null==n||null==(r=n.bufferView)?void 0:r.preprocess,c=null==n||null==(s=n.bufferView)?void 0:s.processAsync,u=null==n||null==(o=n.bufferView)?void 0:o.postprocess;if(null==(a=e.bufferViews)||!a.length)return i;for(let n=0;n<e.bufferViews.length;++n){const r=e.bufferViews[n];let s;l&&l(r),s=new Promise(c?(e,n)=>{c(r,t,((t,r)=>{t?n(t):e(r)}))}:e=>{e(null)}),s=s.then((e=>e||t[r.buffer].then((e=>new Uint8Array(e.buffer,e.byteOffset+(r.byteOffset||0),r.byteLength))))),r.hasOwnProperty("byteStride")&&(s=s.then((e=>(e.byteStride=r.byteStride,e)))),u&&(s=s.then((e=>(u(r,e),e)))),i.push(s)}return i})(l,c,a),p=((t,n,r,s,o)=>{var a,i,l;if(!t.images||0===t.images.length)return[];const c=null==o||null==(a=o.image)?void 0:a.preprocess,u=null==o||null==(i=o.image)?void 0:i.processAsync,p=null==o||null==(l=o.image)?void 0:l.postprocess,h={"image/png":"png","image/jpeg":"jpg","image/basis":"basis","image/ktx":"ktx","image/ktx2":"ktx2","image/vnd-ms.dds":"dds"},f=(e,t,n,r,o)=>new Promise(((a,i)=>{const l=n=>{const l=(e.name||"gltf-texture")+"-"+ft++,c={url:t||l};if(n&&(c.contents=n.slice(0).buffer),r){const e=h[r];e&&(c.filename=c.url+"."+e)}const u=new Re(l,"texture",c,null,o);u.on("load",(e=>a(e))),u.on("error",(e=>i(e))),s.add(u),s.load(u)};n?n.then((e=>l(e))):l(null)}));return t.images.map(((t,s)=>{let o;return c&&c(t),o=new Promise(u?(e,n)=>{u(t,((t,r)=>{t?n(t):e(r)}))}:e=>{e(null)}),o=o.then((o=>{return o||(t.hasOwnProperty("uri")?Fe(t.uri)?f(t,t.uri,null,(a=t.uri).substring(a.indexOf(":")+1,a.indexOf(";")),null):f(t,Ae.test(t.uri)?t.uri:e.join(r,t.uri),null,null,{crossOrigin:"anonymous"}):t.hasOwnProperty("bufferView")&&t.hasOwnProperty("mimeType")?f(t,null,n[t.bufferView],t.mimeType,null):Promise.reject(new Error(`Invalid image found in gltf (neither uri or bufferView found). index=${s}`)));var a})),p&&(o=o.then((e=>(p(t,e),e)))),o}))})(l,u,n,o,a),h=mt(l,p,a);ht(s,l,u,h,a).then((e=>i(null,e))).catch((e=>i(e)))}))}))}static createDefaultMaterial(){return st({name:"defaultGlbMaterial"},[])}}export{yt as GlbParser};
