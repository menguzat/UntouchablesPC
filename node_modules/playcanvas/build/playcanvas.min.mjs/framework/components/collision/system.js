import"../../../core/debug.js";import{Mat4 as e}from"../../../core/math/mat4.js";import{Quat as t}from"../../../core/math/quat.js";import{Vec3 as a}from"../../../core/math/vec3.js";import{SEMANTIC_POSITION as s}from"../../../platform/graphics/constants.js";import{GraphNode as o}from"../../../scene/graph-node.js";import{Model as n}from"../../../scene/model.js";import{Component as i}from"../component.js";import{ComponentSystem as r}from"../system.js";import{CollisionComponent as d}from"./component.js";import{CollisionComponentData as l}from"./data.js";import{Trigger as m}from"./trigger.js";const c=new e,h=new a,p=new a,y=new t,f=new o,u=["enabled","type","halfExtents","linearOffset","angularOffset","radius","axis","height","asset","renderAsset","shape","model","render"];class g{constructor(e){this.system=e}beforeInitialize(e,t){t.shape=null,t.model=new n,t.model.graph=new o}afterInitialize(e,t){this.recreatePhysicalShapes(e),e.data.initialized=!0}reset(e,t){this.beforeInitialize(e,t),this.afterInitialize(e,t)}recreatePhysicalShapes(e){const t=e.entity,a=e.data;if("undefined"!=typeof Ammo){t.trigger&&(t.trigger.destroy(),delete t.trigger),a.shape&&(e._compoundParent&&(this.system._removeCompoundChild(e._compoundParent,a.shape),e._compoundParent.entity.rigidbody&&e._compoundParent.entity.rigidbody.activate()),Ammo.destroy(a.shape),a.shape=null),a.shape=this.createPhysicalShape(e.entity,a);const s=!e._compoundParent;if("compound"!==a.type||e._compoundParent&&e!==e._compoundParent){if("compound"!==a.type&&(e._compoundParent&&e===e._compoundParent&&t.forEach(this.system.implementations.compound._updateEachDescendant,e),!e.rigidbody)){e._compoundParent=null;let a=t.parent;for(;a;){if(a.collision&&"compound"===a.collision.type){e._compoundParent=a.collision;break}a=a.parent}}}else e._compoundParent=e,t.forEach(this._addEachDescendant,e);e._compoundParent&&e!==e._compoundParent&&(s&&0===e._compoundParent.shape.getNumChildShapes()?this.system.recreatePhysicalShapes(e._compoundParent):(this.system.updateCompoundChildTransform(t),e._compoundParent.entity.rigidbody&&e._compoundParent.entity.rigidbody.activate())),t.rigidbody?(t.rigidbody.disableSimulation(),t.rigidbody.createBody(),t.enabled&&t.rigidbody.enabled&&t.rigidbody.enableSimulation()):e._compoundParent||(t.trigger?t.trigger.initialize(a):t.trigger=new m(this.system.app,e,a))}}createPhysicalShape(e,t){}updateTransform(e,t,a,s){e.entity.trigger&&e.entity.trigger.updateTransform()}beforeRemove(e,t){t.data.shape&&(t._compoundParent&&!t._compoundParent.entity._destroying&&(this.system._removeCompoundChild(t._compoundParent,t.data.shape),t._compoundParent.entity.rigidbody&&t._compoundParent.entity.rigidbody.activate()),t._compoundParent=null,Ammo.destroy(t.data.shape),t.data.shape=null)}remove(e,t){e.rigidbody&&e.rigidbody.body&&e.rigidbody.disableSimulation(),e.trigger&&(e.trigger.destroy(),delete e.trigger)}clone(e,t){const a=this.system.store[e.getGuid()],s={enabled:a.data.enabled,type:a.data.type,halfExtents:[a.data.halfExtents.x,a.data.halfExtents.y,a.data.halfExtents.z],linearOffset:[a.data.linearOffset.x,a.data.linearOffset.y,a.data.linearOffset.z],angularOffset:[a.data.angularOffset.x,a.data.angularOffset.y,a.data.angularOffset.z,a.data.angularOffset.w],radius:a.data.radius,axis:a.data.axis,height:a.data.height,asset:a.data.asset,renderAsset:a.data.renderAsset,model:a.data.model,render:a.data.render};return this.system.addComponent(t,s)}}class b extends g{createPhysicalShape(e,t){if("undefined"!=typeof Ammo){const e=t.halfExtents,a=new Ammo.btVector3(e?e.x:.5,e?e.y:.5,e?e.z:.5),s=new Ammo.btBoxShape(a);return Ammo.destroy(a),s}}}class A extends g{createPhysicalShape(e,t){if("undefined"!=typeof Ammo)return new Ammo.btSphereShape(t.radius)}}class _ extends g{createPhysicalShape(e,t){var a,s,o;const n=null!=(a=t.axis)?a:1,i=null!=(s=t.radius)?s:.5,r=Math.max((null!=(o=t.height)?o:2)-2*i,0);let d=null;if("undefined"!=typeof Ammo)switch(n){case 0:d=new Ammo.btCapsuleShapeX(i,r);break;case 1:d=new Ammo.btCapsuleShape(i,r);break;case 2:d=new Ammo.btCapsuleShapeZ(i,r)}return d}}class S extends g{createPhysicalShape(e,t){var a,s,o;const n=null!=(a=t.axis)?a:1,i=null!=(s=t.radius)?s:.5,r=null!=(o=t.height)?o:1;let d=null,l=null;if("undefined"!=typeof Ammo)switch(n){case 0:d=new Ammo.btVector3(.5*r,i,i),l=new Ammo.btCylinderShapeX(d);break;case 1:d=new Ammo.btVector3(i,.5*r,i),l=new Ammo.btCylinderShape(d);break;case 2:d=new Ammo.btVector3(i,i,.5*r),l=new Ammo.btCylinderShapeZ(d)}return d&&Ammo.destroy(d),l}}class P extends g{createPhysicalShape(e,t){var a,s,o;const n=null!=(a=t.axis)?a:1,i=null!=(s=t.radius)?s:.5,r=null!=(o=t.height)?o:1;let d=null;if("undefined"!=typeof Ammo)switch(n){case 0:d=new Ammo.btConeShapeX(i,r);break;case 1:d=new Ammo.btConeShape(i,r);break;case 2:d=new Ammo.btConeShapeZ(i,r)}return d}}class w extends g{beforeInitialize(e,t){}createAmmoMesh(e,t,a){let o;if(this.system._triMeshCache[e.id])o=this.system._triMeshCache[e.id];else{const t=e.vertexBuffer,a=t.getFormat();let n,i;for(let e=0;e<a.elements.length;e++){const o=a.elements[e];if(o.name===s){i=new Float32Array(t.lock(),o.offset),n=o.stride/4;break}}const r=[];e.getIndices(r);const d=e.primitive[0].count/3,l=new Ammo.btVector3,m=new Ammo.btVector3,c=new Ammo.btVector3;let h,p,y;const f=e.primitive[0].base;o=new Ammo.btTriangleMesh,this.system._triMeshCache[e.id]=o;for(let e=0;e<d;e++)h=r[f+3*e]*n,p=r[f+3*e+1]*n,y=r[f+3*e+2]*n,l.setValue(i[h],i[h+1],i[h+2]),m.setValue(i[p],i[p+1],i[p+2]),c.setValue(i[y],i[y+1],i[y+2]),o.addTriangle(l,m,c,!0);Ammo.destroy(l),Ammo.destroy(m),Ammo.destroy(c)}const n=new Ammo.btBvhTriangleMeshShape(o,!0),i=this.system._getNodeScaling(t);n.setLocalScaling(i),Ammo.destroy(i);const r=this.system._getNodeTransform(t);a.addChildShape(r,n),Ammo.destroy(r)}createPhysicalShape(e,t){if("undefined"!=typeof Ammo&&(t.model||t.render)){const a=new Ammo.btCompoundShape;if(t.model){const e=t.model.meshInstances;for(let t=0;t<e.length;t++)this.createAmmoMesh(e[t].mesh,e[t].node,a)}else if(t.render){const e=t.render.meshes;for(let t=0;t<e.length;t++)this.createAmmoMesh(e[t],f,a)}const s=e.getWorldTransform().getScale(),o=new Ammo.btVector3(s.x,s.y,s.z);return a.setLocalScaling(o),Ammo.destroy(o),a}}recreatePhysicalShapes(e){const t=e.data;(t.renderAsset||t.asset)&&e.enabled&&e.entity.enabled?this.loadAsset(e,t.renderAsset||t.asset,t.renderAsset?"render":"model"):this.doRecreatePhysicalShape(e)}loadAsset(e,t,a){const s=e.data,o=this.system.app.assets,n=o.get(t);n?(n.ready((t=>{s[a]=t.resource,this.doRecreatePhysicalShape(e)})),o.load(n)):o.once("add:"+t,(t=>{t.ready((t=>{s[a]=t.resource,this.doRecreatePhysicalShape(e)})),o.load(t)}))}doRecreatePhysicalShape(e){const t=e.entity,a=e.data;a.model||a.render?(this.destroyShape(a),a.shape=this.createPhysicalShape(t,a),t.rigidbody?(t.rigidbody.disableSimulation(),t.rigidbody.createBody(),t.enabled&&t.rigidbody.enabled&&t.rigidbody.enableSimulation()):t.trigger?t.trigger.initialize(a):t.trigger=new m(this.system.app,e,a)):(this.beforeRemove(t,e),this.remove(t,a))}updateTransform(e,t,a,s){if(e.shape){const t=e.entity.getWorldTransform().getScale(),a=e.shape.getLocalScaling();t.x===a.x()&&t.y===a.y()&&t.z===a.z()||this.doRecreatePhysicalShape(e)}super.updateTransform(e,t,a,s)}destroyShape(e){if(!e.shape)return;const t=e.shape.getNumChildShapes();for(let a=0;a<t;a++){const t=e.shape.getChildShape(a);Ammo.destroy(t)}Ammo.destroy(e.shape),e.shape=null}remove(e,t){this.destroyShape(t),super.remove(e,t)}}class x extends g{createPhysicalShape(e,t){if("undefined"!=typeof Ammo)return new Ammo.btCompoundShape}_addEachDescendant(e){e.collision&&!e.rigidbody&&(e.collision._compoundParent=this,e!==this.entity&&e.collision.system.recreatePhysicalShapes(e.collision))}_updateEachDescendant(e){e.collision&&e.collision._compoundParent===this&&(e.collision._compoundParent=null,e===this.entity||e.rigidbody||e.collision.system.recreatePhysicalShapes(e.collision))}_updateEachDescendantTransform(e){e.collision&&e.collision._compoundParent===this.collision._compoundParent&&this.collision.system.updateCompoundChildTransform(e)}}class C extends r{constructor(e){super(e),this.id="collision",this.ComponentType=d,this.DataType=l,this.schema=u,this.implementations={},this._triMeshCache={},this.on("beforeremove",this.onBeforeRemove,this),this.on("remove",this.onRemove,this)}initializeComponentData(e,s,o){const n={};for(let e=0,t=(o=["type","halfExtents","radius","axis","height","shape","model","asset","render","renderAsset","enabled","linearOffset","angularOffset"]).length;e<t;e++){const t=o[e];n[t]=s[t]}let i;if(s.hasOwnProperty("asset")?(i=o.indexOf("model"),-1!==i&&o.splice(i,1),i=o.indexOf("render"),-1!==i&&o.splice(i,1)):s.hasOwnProperty("model")&&(i=o.indexOf("asset"),-1!==i&&o.splice(i,1)),n.type||(n.type=e.data.type),e.data.type=n.type,Array.isArray(n.halfExtents)&&(n.halfExtents=new a(n.halfExtents)),Array.isArray(n.linearOffset)&&(n.linearOffset=new a(n.linearOffset)),Array.isArray(n.angularOffset)){const e=n.angularOffset;3===e.length?n.angularOffset=(new t).setFromEulerAngles(e[0],e[1],e[2]):n.angularOffset=new t(n.angularOffset)}const r=this._createImplementation(n.type);r.beforeInitialize(e,n),super.initializeComponentData(e,n,o),r.afterInitialize(e,n)}_createImplementation(e){if(void 0===this.implementations[e]){let t;switch(e){case"box":t=new b(this);break;case"sphere":t=new A(this);break;case"capsule":t=new _(this);break;case"cylinder":t=new S(this);break;case"cone":t=new P(this);break;case"mesh":t=new w(this);break;case"compound":t=new x(this)}this.implementations[e]=t}return this.implementations[e]}_getImplementation(e){return this.implementations[e.collision.data.type]}cloneComponent(e,t){return this._getImplementation(e).clone(e,t)}onBeforeRemove(e,t){this.implementations[t.data.type].beforeRemove(e,t),t.onBeforeRemove()}onRemove(e,t){this.implementations[t.type].remove(e,t)}updateCompoundChildTransform(e){if(this._removeCompoundChild(e.collision._compoundParent,e.collision.data.shape),e.enabled&&e.collision.enabled){const t=this._getNodeTransform(e,e.collision._compoundParent.entity);e.collision._compoundParent.shape.addChildShape(t,e.collision.data.shape),Ammo.destroy(t)}}_removeCompoundChild(e,t){if(e.shape.removeChildShape)e.shape.removeChildShape(t);else{const a=e._getCompoundChildShapeIndex(t);null!==a&&e.shape.removeChildShapeByIndex(a)}}onTransformChanged(e,t,a,s){this.implementations[e.data.type].updateTransform(e,t,a,s)}changeType(e,t,a){this.implementations[t].beforeRemove(e.entity,e),this.implementations[t].remove(e.entity,e.data),this._createImplementation(a).reset(e,e.data)}recreatePhysicalShapes(e){this.implementations[e.data.type].recreatePhysicalShapes(e)}_calculateNodeRelativeTransform(e,t){if(e===t){const t=e.getWorldTransform().getScale();c.setScale(t.x,t.y,t.z)}else this._calculateNodeRelativeTransform(e.parent,t),c.mul(e.getLocalTransform())}_getNodeScaling(e){const t=e.getWorldTransform().getScale();return new Ammo.btVector3(t.x,t.y,t.z)}_getNodeTransform(e,t){let a,s;t?(this._calculateNodeRelativeTransform(e,t),a=h,s=y,c.getTranslation(a),s.setFromMat4(c)):(a=e.getPosition(),s=e.getRotation());const o=new Ammo.btQuaternion,n=new Ammo.btTransform;n.setIdentity();const i=n.getOrigin(),r=e.collision;if(r&&r._hasOffset){const e=r.data.linearOffset,t=r.data.angularOffset,n=p;y.copy(s).transformVector(e,n),n.add(a),y.copy(s).mul(t),i.setValue(n.x,n.y,n.z),o.setValue(y.x,y.y,y.z,y.w)}else i.setValue(a.x,a.y,a.z),o.setValue(s.x,s.y,s.z,s.w);return n.setRotation(o),Ammo.destroy(o),Ammo.destroy(i),n}destroy(){for(const e in this._triMeshCache)Ammo.destroy(this._triMeshCache[e]);this._triMeshCache=null,super.destroy()}}i._buildAccessors(d.prototype,u);export{C as CollisionComponentSystem};
