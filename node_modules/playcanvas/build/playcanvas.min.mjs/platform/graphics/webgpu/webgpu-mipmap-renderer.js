import{Shader as t}from"../shader.js";import{SHADERLANGUAGE_WGSL as e}from"../constants.js";import"../../../core/debug.js";class r{constructor(r){this.device=void 0,this.device=r;const n=r.wgpu,i="\n \n\t\t\t\t\t\tvar<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n\t\t\t\t\t\t\t\tvec2(-1.0, 1.0), vec2(1.0, 1.0),\n\t\t\t\t\t\t\t\tvec2(-1.0, -1.0), vec2(1.0, -1.0)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tstruct VertexOutput {\n\t\t\t\t\t\t\t\t@builtin(position) position : vec4f,\n\t\t\t\t\t\t\t\t@location(0) texCoord : vec2f\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t@vertex\n\t\t\t\t\t\tfn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n\t\t\t\t\t\t\tvar output : VertexOutput;\n\t\t\t\t\t\t\toutput.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);\n\t\t\t\t\t\t\toutput.position = vec4f(pos[vertexIndex], 0, 1);\n\t\t\t\t\t\t\treturn output;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@group(0) @binding(0) var imgSampler : sampler;\n\t\t\t\t\t\t@group(0) @binding(1) var img : texture_2d<f32>;\n\n\t\t\t\t\t\t@fragment\n\t\t\t\t\t\tfn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {\n\t\t\t\t\t\t\treturn textureSample(img, imgSampler, texCoord);\n\t\t\t\t\t\t}\n\t\t\t\t";this.shader=new t(r,{name:"WebGPUMipmapRendererShader",shaderLanguage:e,vshader:i,fshader:i}),this.minSampler=n.createSampler({minFilter:"linear"})}generate(t){const e=t.descr;if(e.mipLevelCount<=1)return;if(t.texture.cubemap||t.texture.volume)return;const r=this.device,n=r.wgpu,i=this.shader.impl,o=n.createRenderPipeline({layout:"auto",vertex:{module:i.getVertexShaderModule(),entryPoint:i.vertexEntryPoint},fragment:{module:i.getFragmentShaderModule(),entryPoint:i.fragmentEntryPoint,targets:[{format:e.format}]},primitive:{topology:"triangle-strip"}});let a=t.createView({baseMipLevel:0,mipLevelCount:1});const u=n.createCommandEncoder();for(let r=1;r<e.mipLevelCount;r++){const e=t.createView({baseMipLevel:r,mipLevelCount:1}),i=u.beginRenderPass({colorAttachments:[{view:e,loadOp:"clear",storeOp:"store"}]}),p=n.createBindGroup({layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:this.minSampler},{binding:1,resource:a}]});i.setPipeline(o),i.setBindGroup(0,p),i.draw(4),i.end(),a=e}n.queue.submit([u.finish()]),r.pipeline=null}}export{r as WebgpuMipmapRenderer};
