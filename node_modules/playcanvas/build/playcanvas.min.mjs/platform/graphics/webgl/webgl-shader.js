import"../../../core/debug.js";import"../../../core/time.js";import{WebglShaderInput as e}from"./webgl-shader-input.js";import{semanticToLocation as t}from"../constants.js";import{DeviceCache as r}from"../device-cache.js";const s=["gl_VertexID","gl_InstanceID","gl_DrawID","gl_BaseVertex","gl_BaseInstance"];class i{constructor(){this.map=new Map}destroy(e){this.map.forEach((t=>{e.gl.deleteShader(t)}))}loseContext(e){this.map.clear()}}class a{constructor(){this.shaders=[]}loseContext(e){this.shaders=[]}}const o=new r,n=new r,h=new r;class c{constructor(e){this.compileDuration=0,this.init(),this.compile(e.device,e),c.getBatchShaders(e.device).push(e),e.device.shaders.push(e)}destroy(e){this.glProgram&&(e.device.gl.deleteProgram(this.glProgram),this.glProgram=null)}init(){this.uniforms=[],this.samplers=[],this.attributes=[],this.glProgram=null,this.glVertexShader=null,this.glFragmentShader=null}static getBatchShaders(e){return h.get(e,(()=>new a)).shaders}static endShaderBatch(e){const t=c.getBatchShaders(e);t.forEach((t=>t.impl.link(e,t))),t.length=0}loseContext(){this.init()}restoreContext(e,t){this.compile(e,t)}compile(e,t){const r=t.definition;this.glVertexShader=this._compileShaderSource(e,r.vshader,!0),this.glFragmentShader=this._compileShaderSource(e,r.fshader,!1)}link(e,r){if(this.glProgram)return;const s=e.gl,i=s.createProgram();this.glProgram=i,s.attachShader(i,this.glVertexShader),s.attachShader(i,this.glFragmentShader);const a=r.definition,o=a.attributes;if(e.webgl2&&a.useTransformFeedback){const e=[];for(const t in o)o.hasOwnProperty(t)&&e.push("out_"+t);s.transformFeedbackVaryings(i,e,s.INTERLEAVED_ATTRIBS)}for(const e in o)if(o.hasOwnProperty(e)){const r=o[e],a=t[r];s.bindAttribLocation(i,a,e)}s.linkProgram(i)}_compileShaderSource(e,t,r){const s=e.gl,a=(r?o:n).get(e,(()=>new i));let h=a.map.get(t);return h||(h=s.createShader(r?s.VERTEX_SHADER:s.FRAGMENT_SHADER),s.shaderSource(h,t),s.compileShader(h),a.map.set(t,h)),h}finalize(t,r){this.glProgram||this.link(t,r);const i=t.gl,a=this.glProgram,o=r.definition;if(!i.getProgramParameter(a,i.LINK_STATUS)){if(!this._isCompiled(t,r,this.glVertexShader,o.vshader,"vertex"))return!1;if(!this._isCompiled(t,r,this.glFragmentShader,o.fshader,"fragment"))return!1;const e="Failed to link shader program. Error: "+i.getProgramInfoLog(a);return console.error(e),!1}let n=0;const h=i.getProgramParameter(a,i.ACTIVE_ATTRIBUTES);for(;n<h;){const h=i.getActiveAttrib(a,n++),c=i.getAttribLocation(a,h.name);if(-1!==s.indexOf(h.name))continue;void 0===o.attributes[h.name]&&(console.error(`Vertex shader attribute "${h.name}" is not mapped to a semantic in shader definition, shader [${r.label}]`,r),r.failed=!0);const l=new e(t,o.attributes[h.name],t.pcUniformType[h.type],c);this.attributes.push(l)}n=0;const c=i.getProgramParameter(a,i.ACTIVE_UNIFORMS);for(;n<c;){const r=i.getActiveUniform(a,n++),s=i.getUniformLocation(a,r.name),o=new e(t,r.name,t.pcUniformType[r.type],s);r.type===i.SAMPLER_2D||r.type===i.SAMPLER_CUBE||t.webgl2&&(r.type===i.SAMPLER_2D_SHADOW||r.type===i.SAMPLER_CUBE_SHADOW||r.type===i.SAMPLER_3D)?this.samplers.push(o):this.uniforms.push(o)}return r.ready=!0,!0}_isCompiled(e,t,r,s,i){const a=e.gl;if(!a.getShaderParameter(r,a.COMPILE_STATUS)){const e=a.getShaderInfoLog(r),[t,o]=this._processError(s,e),n=`Failed to compile ${i} shader:\n\n${e}\n${t}`;return console.error(n),!1}return!0}_processError(e,t){const r={};let s="";if(e){const i=e.split("\n");let a=0,o=i.length;if(t&&t.startsWith("ERROR:")){const e=t.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);e&&(r.message=e[3],r.line=parseInt(e[2],10),a=Math.max(0,r.line-6),o=Math.min(i.length,r.line+5))}for(let e=a;e<o;e++)s+=e+1+":\t"+i[e]+"\n";r.source=e}return[s,r]}}export{c as WebglShader};
